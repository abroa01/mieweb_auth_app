{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/anshul/Masters/Internship/POC/Meteor_Mobile/mieweb_push_auth/node_modules/framer-motion/dist/es/render/dom/scroll/offsets/inset.mjs","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","topLevelAwait","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"web.browser"},"sourceFileName":"node_modules/framer-motion/dist/es/render/dom/scroll/offsets/inset.mjs","filename":"/Users/anshul/Masters/Internship/POC/Meteor_Mobile/mieweb_push_auth/node_modules/framer-motion/dist/es/render/dom/scroll/offsets/inset.mjs","inputSourceMap":{"version":3,"names":["calcInset","element","container","inset","x","y","current","HTMLElement","offsetLeft","offsetTop","offsetParent","tagName","svgBoundingBox","getBoundingClientRect","parentElement","parentBoundingBox","left","top","SVGGraphicsElement","getBBox","svg","parent","parentNode"],"sources":["node_modules/framer-motion/dist/es/render/dom/scroll/offsets/inset.mjs"],"sourcesContent":["function calcInset(element, container) {\n    const inset = { x: 0, y: 0 };\n    let current = element;\n    while (current && current !== container) {\n        if (current instanceof HTMLElement) {\n            inset.x += current.offsetLeft;\n            inset.y += current.offsetTop;\n            current = current.offsetParent;\n        }\n        else if (current.tagName === \"svg\") {\n            /**\n             * This isn't an ideal approach to measuring the offset of <svg /> tags.\n             * It would be preferable, given they behave like HTMLElements in most ways\n             * to use offsetLeft/Top. But these don't exist on <svg />. Likewise we\n             * can't use .getBBox() like most SVG elements as these provide the offset\n             * relative to the SVG itself, which for <svg /> is usually 0x0.\n             */\n            const svgBoundingBox = current.getBoundingClientRect();\n            current = current.parentElement;\n            const parentBoundingBox = current.getBoundingClientRect();\n            inset.x += svgBoundingBox.left - parentBoundingBox.left;\n            inset.y += svgBoundingBox.top - parentBoundingBox.top;\n        }\n        else if (current instanceof SVGGraphicsElement) {\n            const { x, y } = current.getBBox();\n            inset.x += x;\n            inset.y += y;\n            let svg = null;\n            let parent = current.parentNode;\n            while (!svg) {\n                if (parent.tagName === \"svg\") {\n                    svg = parent;\n                }\n                parent = current.parentNode;\n            }\n            current = svg;\n        }\n        else {\n            break;\n        }\n    }\n    return inset;\n}\n\nexport { calcInset };\n"],"mappings":";AAAA,SAASA,SAASA,CAACC,OAAO,EAAEC,SAAS,EAAE;EACnC,MAAMC,KAAK,GAAG;IAAEC,CAAC,EAAE,CAAC;IAAEC,CAAC,EAAE;EAAE,CAAC;EAC5B,IAAIC,OAAO,GAAGL,OAAO;EACrB,OAAOK,OAAO,IAAIA,OAAO,KAAKJ,SAAS,EAAE;IACrC,IAAII,OAAO,YAAYC,WAAW,EAAE;MAChCJ,KAAK,CAACC,CAAC,IAAIE,OAAO,CAACE,UAAU;MAC7BL,KAAK,CAACE,CAAC,IAAIC,OAAO,CAACG,SAAS;MAC5BH,OAAO,GAAGA,OAAO,CAACI,YAAY;IAClC,CAAC,MACI,IAAIJ,OAAO,CAACK,OAAO,KAAK,KAAK,EAAE;MAChC;AACZ;AACA;AACA;AACA;AACA;AACA;MACY,MAAMC,cAAc,GAAGN,OAAO,CAACO,qBAAqB,CAAC,CAAC;MACtDP,OAAO,GAAGA,OAAO,CAACQ,aAAa;MAC/B,MAAMC,iBAAiB,GAAGT,OAAO,CAACO,qBAAqB,CAAC,CAAC;MACzDV,KAAK,CAACC,CAAC,IAAIQ,cAAc,CAACI,IAAI,GAAGD,iBAAiB,CAACC,IAAI;MACvDb,KAAK,CAACE,CAAC,IAAIO,cAAc,CAACK,GAAG,GAAGF,iBAAiB,CAACE,GAAG;IACzD,CAAC,MACI,IAAIX,OAAO,YAAYY,kBAAkB,EAAE;MAC5C,MAAM;QAAEd,CAAC;QAAEC;MAAE,CAAC,GAAGC,OAAO,CAACa,OAAO,CAAC,CAAC;MAClChB,KAAK,CAACC,CAAC,IAAIA,CAAC;MACZD,KAAK,CAACE,CAAC,IAAIA,CAAC;MACZ,IAAIe,GAAG,GAAG,IAAI;MACd,IAAIC,MAAM,GAAGf,OAAO,CAACgB,UAAU;MAC/B,OAAO,CAACF,GAAG,EAAE;QACT,IAAIC,MAAM,CAACV,OAAO,KAAK,KAAK,EAAE;UAC1BS,GAAG,GAAGC,MAAM;QAChB;QACAA,MAAM,GAAGf,OAAO,CAACgB,UAAU;MAC/B;MACAhB,OAAO,GAAGc,GAAG;IACjB,CAAC,MACI;MACD;IACJ;EACJ;EACA,OAAOjB,KAAK;AAChB;AAEA,SAASH,SAAS","ignoreList":[]},"targets":{},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/Users/anshul/Masters/Internship/POC/Meteor_Mobile/mieweb_push_auth","root":"/Users/anshul/Masters/Internship/POC/Meteor_Mobile/mieweb_push_auth","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true},"externalDependencies":[]},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.17.2","helpers":true,"useESModules":false,"corejs":false},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-react-jsx","visitor":{"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXFragment":{"exit":[null]},"JSXElement":{"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false},"externalDependencies":[]},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-nullish-coalescing-operator","visitor":{"LogicalExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-chaining","visitor":{"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-catch-binding","visitor":{"CatchClause":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"proposal-logical-assignment-operators","visitor":{"AssignmentExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]}],"presets":[],"generatorOpts":{"filename":"/Users/anshul/Masters/Internship/POC/Meteor_Mobile/mieweb_push_auth/node_modules/framer-motion/dist/es/render/dom/scroll/offsets/inset.mjs","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"node_modules/framer-motion/dist/es/render/dom/scroll/offsets/inset.mjs","inputSourceMap":{"version":3,"names":["calcInset","element","container","inset","x","y","current","HTMLElement","offsetLeft","offsetTop","offsetParent","tagName","svgBoundingBox","getBoundingClientRect","parentElement","parentBoundingBox","left","top","SVGGraphicsElement","getBBox","svg","parent","parentNode"],"sources":["node_modules/framer-motion/dist/es/render/dom/scroll/offsets/inset.mjs"],"sourcesContent":["function calcInset(element, container) {\n    const inset = { x: 0, y: 0 };\n    let current = element;\n    while (current && current !== container) {\n        if (current instanceof HTMLElement) {\n            inset.x += current.offsetLeft;\n            inset.y += current.offsetTop;\n            current = current.offsetParent;\n        }\n        else if (current.tagName === \"svg\") {\n            /**\n             * This isn't an ideal approach to measuring the offset of <svg /> tags.\n             * It would be preferable, given they behave like HTMLElements in most ways\n             * to use offsetLeft/Top. But these don't exist on <svg />. Likewise we\n             * can't use .getBBox() like most SVG elements as these provide the offset\n             * relative to the SVG itself, which for <svg /> is usually 0x0.\n             */\n            const svgBoundingBox = current.getBoundingClientRect();\n            current = current.parentElement;\n            const parentBoundingBox = current.getBoundingClientRect();\n            inset.x += svgBoundingBox.left - parentBoundingBox.left;\n            inset.y += svgBoundingBox.top - parentBoundingBox.top;\n        }\n        else if (current instanceof SVGGraphicsElement) {\n            const { x, y } = current.getBBox();\n            inset.x += x;\n            inset.y += y;\n            let svg = null;\n            let parent = current.parentNode;\n            while (!svg) {\n                if (parent.tagName === \"svg\") {\n                    svg = parent;\n                }\n                parent = current.parentNode;\n            }\n            current = svg;\n        }\n        else {\n            break;\n        }\n    }\n    return inset;\n}\n\nexport { calcInset };\n"],"mappings":";AAAA,SAASA,SAASA,CAACC,OAAO,EAAEC,SAAS,EAAE;EACnC,MAAMC,KAAK,GAAG;IAAEC,CAAC,EAAE,CAAC;IAAEC,CAAC,EAAE;EAAE,CAAC;EAC5B,IAAIC,OAAO,GAAGL,OAAO;EACrB,OAAOK,OAAO,IAAIA,OAAO,KAAKJ,SAAS,EAAE;IACrC,IAAII,OAAO,YAAYC,WAAW,EAAE;MAChCJ,KAAK,CAACC,CAAC,IAAIE,OAAO,CAACE,UAAU;MAC7BL,KAAK,CAACE,CAAC,IAAIC,OAAO,CAACG,SAAS;MAC5BH,OAAO,GAAGA,OAAO,CAACI,YAAY;IAClC,CAAC,MACI,IAAIJ,OAAO,CAACK,OAAO,KAAK,KAAK,EAAE;MAChC;AACZ;AACA;AACA;AACA;AACA;AACA;MACY,MAAMC,cAAc,GAAGN,OAAO,CAACO,qBAAqB,CAAC,CAAC;MACtDP,OAAO,GAAGA,OAAO,CAACQ,aAAa;MAC/B,MAAMC,iBAAiB,GAAGT,OAAO,CAACO,qBAAqB,CAAC,CAAC;MACzDV,KAAK,CAACC,CAAC,IAAIQ,cAAc,CAACI,IAAI,GAAGD,iBAAiB,CAACC,IAAI;MACvDb,KAAK,CAACE,CAAC,IAAIO,cAAc,CAACK,GAAG,GAAGF,iBAAiB,CAACE,GAAG;IACzD,CAAC,MACI,IAAIX,OAAO,YAAYY,kBAAkB,EAAE;MAC5C,MAAM;QAAEd,CAAC;QAAEC;MAAE,CAAC,GAAGC,OAAO,CAACa,OAAO,CAAC,CAAC;MAClChB,KAAK,CAACC,CAAC,IAAIA,CAAC;MACZD,KAAK,CAACE,CAAC,IAAIA,CAAC;MACZ,IAAIe,GAAG,GAAG,IAAI;MACd,IAAIC,MAAM,GAAGf,OAAO,CAACgB,UAAU;MAC/B,OAAO,CAACF,GAAG,EAAE;QACT,IAAIC,MAAM,CAACV,OAAO,KAAK,KAAK,EAAE;UAC1BS,GAAG,GAAGC,MAAM;QAChB;QACAA,MAAM,GAAGf,OAAO,CAACgB,UAAU;MAC/B;MACAhB,OAAO,GAAGc,GAAG;IACjB,CAAC,MACI;MACD;IACJ;EACJ;EACA,OAAOjB,KAAK;AAChB;AAEA,SAASH,SAAS","ignoreList":[]}}},"code":"!function (module1) {\n  module1.export({\n    calcInset: () => calcInset\n  });\n  ___INIT_METEOR_FAST_REFRESH(module);\n  function calcInset(element, container) {\n    const inset = {\n      x: 0,\n      y: 0\n    };\n    let current = element;\n    while (current && current !== container) {\n      if (current instanceof HTMLElement) {\n        inset.x += current.offsetLeft;\n        inset.y += current.offsetTop;\n        current = current.offsetParent;\n      } else if (current.tagName === \"svg\") {\n        /**\n         * This isn't an ideal approach to measuring the offset of <svg /> tags.\n         * It would be preferable, given they behave like HTMLElements in most ways\n         * to use offsetLeft/Top. But these don't exist on <svg />. Likewise we\n         * can't use .getBBox() like most SVG elements as these provide the offset\n         * relative to the SVG itself, which for <svg /> is usually 0x0.\n         */\n        const svgBoundingBox = current.getBoundingClientRect();\n        current = current.parentElement;\n        const parentBoundingBox = current.getBoundingClientRect();\n        inset.x += svgBoundingBox.left - parentBoundingBox.left;\n        inset.y += svgBoundingBox.top - parentBoundingBox.top;\n      } else if (current instanceof SVGGraphicsElement) {\n        const {\n          x,\n          y\n        } = current.getBBox();\n        inset.x += x;\n        inset.y += y;\n        let svg = null;\n        let parent = current.parentNode;\n        while (!svg) {\n          if (parent.tagName === \"svg\") {\n            svg = parent;\n          }\n          parent = current.parentNode;\n        }\n        current = svg;\n      } else {\n        break;\n      }\n    }\n    return inset;\n  }\n}.call(this, module);","map":{"version":3,"names":["calcInset","element","container","inset","x","y","current","HTMLElement","offsetLeft","offsetTop","offsetParent","tagName","svgBoundingBox","getBoundingClientRect","parentElement","parentBoundingBox","left","top","SVGGraphicsElement","getBBox","svg","parent","parentNode","call","module"],"sources":["node_modules/framer-motion/dist/es/render/dom/scroll/offsets/inset.mjs"],"sourcesContent":["function calcInset(element, container) {\n    const inset = { x: 0, y: 0 };\n    let current = element;\n    while (current && current !== container) {\n        if (current instanceof HTMLElement) {\n            inset.x += current.offsetLeft;\n            inset.y += current.offsetTop;\n            current = current.offsetParent;\n        }\n        else if (current.tagName === \"svg\") {\n            /**\n             * This isn't an ideal approach to measuring the offset of <svg /> tags.\n             * It would be preferable, given they behave like HTMLElements in most ways\n             * to use offsetLeft/Top. But these don't exist on <svg />. Likewise we\n             * can't use .getBBox() like most SVG elements as these provide the offset\n             * relative to the SVG itself, which for <svg /> is usually 0x0.\n             */\n            const svgBoundingBox = current.getBoundingClientRect();\n            current = current.parentElement;\n            const parentBoundingBox = current.getBoundingClientRect();\n            inset.x += svgBoundingBox.left - parentBoundingBox.left;\n            inset.y += svgBoundingBox.top - parentBoundingBox.top;\n        }\n        else if (current instanceof SVGGraphicsElement) {\n            const { x, y } = current.getBBox();\n            inset.x += x;\n            inset.y += y;\n            let svg = null;\n            let parent = current.parentNode;\n            while (!svg) {\n                if (parent.tagName === \"svg\") {\n                    svg = parent;\n                }\n                parent = current.parentNode;\n            }\n            current = svg;\n        }\n        else {\n            break;\n        }\n    }\n    return inset;\n}\n\nexport { calcInset };\n"],"mappings":";;;;;EAAA,SAASA,SAASA,CAACC,OAAO,EAAEC,SAAS,EAAE;IACnC,MAAMC,KAAK,GAAG;MAAEC,CAAC,EAAE,CAAC;MAAEC,CAAC,EAAE;IAAE,CAAC;IAC5B,IAAIC,OAAO,GAAGL,OAAO;IACrB,OAAOK,OAAO,IAAIA,OAAO,KAAKJ,SAAS,EAAE;MACrC,IAAII,OAAO,YAAYC,WAAW,EAAE;QAChCJ,KAAK,CAACC,CAAC,IAAIE,OAAO,CAACE,UAAU;QAC7BL,KAAK,CAACE,CAAC,IAAIC,OAAO,CAACG,SAAS;QAC5BH,OAAO,GAAGA,OAAO,CAACI,YAAY;MAClC,CAAC,MACI,IAAIJ,OAAO,CAACK,OAAO,KAAK,KAAK,EAAE;QAChC;AACZ;AACA;AACA;AACA;AACA;AACA;QACY,MAAMC,cAAc,GAAGN,OAAO,CAACO,qBAAqB,CAAC,CAAC;QACtDP,OAAO,GAAGA,OAAO,CAACQ,aAAa;QAC/B,MAAMC,iBAAiB,GAAGT,OAAO,CAACO,qBAAqB,CAAC,CAAC;QACzDV,KAAK,CAACC,CAAC,IAAIQ,cAAc,CAACI,IAAI,GAAGD,iBAAiB,CAACC,IAAI;QACvDb,KAAK,CAACE,CAAC,IAAIO,cAAc,CAACK,GAAG,GAAGF,iBAAiB,CAACE,GAAG;MACzD,CAAC,MACI,IAAIX,OAAO,YAAYY,kBAAkB,EAAE;QAC5C,MAAM;UAAEd,CAAC;UAAEC;QAAE,CAAC,GAAGC,OAAO,CAACa,OAAO,CAAC,CAAC;QAClChB,KAAK,CAACC,CAAC,IAAIA,CAAC;QACZD,KAAK,CAACE,CAAC,IAAIA,CAAC;QACZ,IAAIe,GAAG,GAAG,IAAI;QACd,IAAIC,MAAM,GAAGf,OAAO,CAACgB,UAAU;QAC/B,OAAO,CAACF,GAAG,EAAE;UACT,IAAIC,MAAM,CAACV,OAAO,KAAK,KAAK,EAAE;YAC1BS,GAAG,GAAGC,MAAM;UAChB;UACAA,MAAM,GAAGf,OAAO,CAACgB,UAAU;QAC/B;QACAhB,OAAO,GAAGc,GAAG;MACjB,CAAC,MACI;QACD;MACJ;IACJ;IACA,OAAOjB,KAAK;EAChB;AAAA,EAAAoB,IAAA,OAAAC,MAAA","ignoreList":[]},"sourceType":"module","externalDependencies":{},"hash":"c69f1e5f4ecec5f58e7c50ef1a927e4c7ca7d172"}
