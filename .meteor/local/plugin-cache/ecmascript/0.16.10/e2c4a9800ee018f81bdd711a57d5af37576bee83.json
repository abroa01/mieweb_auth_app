{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/anshul/Masters/Internship/POC/Meteor_Mobile/mieweb_push_auth/node_modules/framer-motion/dist/es/motion/utils/use-visual-element.mjs","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","topLevelAwait","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"web.browser"},"sourceFileName":"node_modules/framer-motion/dist/es/motion/utils/use-visual-element.mjs","filename":"/Users/anshul/Masters/Internship/POC/Meteor_Mobile/mieweb_push_auth/node_modules/framer-motion/dist/es/motion/utils/use-visual-element.mjs","inputSourceMap":{"version":3,"names":["useContext","useRef","useInsertionEffect","useEffect","PresenceContext","MotionContext","useIsomorphicLayoutEffect","LazyContext","MotionConfigContext","optimizedAppearDataAttribute","microtask","isRefObject","SwitchLayoutGroupContext","useVisualElement","Component","visualState","props","createVisualElement","ProjectionNodeConstructor","_s","_a","_b","visualElement","parent","lazyContext","presenceContext","reducedMotionConfig","reducedMotion","visualElementRef","renderer","current","blockInitialAnimation","initial","initialLayoutGroupConfig","projection","type","createProjectionNode","isMounted","update","optimisedAppearId","wantsHandoff","Boolean","window","MotionHandoffIsComplete","call","MotionHasOptimisedAnimation","MotionIsMounted","updateFeatures","render","animationState","animateChanges","queueMicrotask","MotionHandoffMarkAsComplete","initialPromotionConfig","layoutId","layout","drag","dragConstraints","layoutScroll","layoutRoot","latestValues","undefined","getClosestProjectingNode","setOptions","alwaysMeasureLayout","animationType","options","allowProjection"],"sources":["node_modules/framer-motion/dist/es/motion/utils/use-visual-element.mjs"],"sourcesContent":["import { useContext, useRef, useInsertionEffect, useEffect } from 'react';\nimport { PresenceContext } from '../../context/PresenceContext.mjs';\nimport { MotionContext } from '../../context/MotionContext/index.mjs';\nimport { useIsomorphicLayoutEffect } from '../../utils/use-isomorphic-effect.mjs';\nimport { LazyContext } from '../../context/LazyContext.mjs';\nimport { MotionConfigContext } from '../../context/MotionConfigContext.mjs';\nimport { optimizedAppearDataAttribute } from '../../animation/optimized-appear/data-id.mjs';\nimport { microtask } from '../../frameloop/microtask.mjs';\nimport { isRefObject } from '../../utils/is-ref-object.mjs';\nimport { SwitchLayoutGroupContext } from '../../context/SwitchLayoutGroupContext.mjs';\n\nfunction useVisualElement(Component, visualState, props, createVisualElement, ProjectionNodeConstructor) {\n    var _a, _b;\n    const { visualElement: parent } = useContext(MotionContext);\n    const lazyContext = useContext(LazyContext);\n    const presenceContext = useContext(PresenceContext);\n    const reducedMotionConfig = useContext(MotionConfigContext).reducedMotion;\n    const visualElementRef = useRef(null);\n    /**\n     * If we haven't preloaded a renderer, check to see if we have one lazy-loaded\n     */\n    createVisualElement = createVisualElement || lazyContext.renderer;\n    if (!visualElementRef.current && createVisualElement) {\n        visualElementRef.current = createVisualElement(Component, {\n            visualState,\n            parent,\n            props,\n            presenceContext,\n            blockInitialAnimation: presenceContext\n                ? presenceContext.initial === false\n                : false,\n            reducedMotionConfig,\n        });\n    }\n    const visualElement = visualElementRef.current;\n    /**\n     * Load Motion gesture and animation features. These are rendered as renderless\n     * components so each feature can optionally make use of React lifecycle methods.\n     */\n    const initialLayoutGroupConfig = useContext(SwitchLayoutGroupContext);\n    if (visualElement &&\n        !visualElement.projection &&\n        ProjectionNodeConstructor &&\n        (visualElement.type === \"html\" || visualElement.type === \"svg\")) {\n        createProjectionNode(visualElementRef.current, props, ProjectionNodeConstructor, initialLayoutGroupConfig);\n    }\n    const isMounted = useRef(false);\n    useInsertionEffect(() => {\n        /**\n         * Check the component has already mounted before calling\n         * `update` unnecessarily. This ensures we skip the initial update.\n         */\n        if (visualElement && isMounted.current) {\n            visualElement.update(props, presenceContext);\n        }\n    });\n    /**\n     * Cache this value as we want to know whether HandoffAppearAnimations\n     * was present on initial render - it will be deleted after this.\n     */\n    const optimisedAppearId = props[optimizedAppearDataAttribute];\n    const wantsHandoff = useRef(Boolean(optimisedAppearId) &&\n        !((_a = window.MotionHandoffIsComplete) === null || _a === void 0 ? void 0 : _a.call(window, optimisedAppearId)) &&\n        ((_b = window.MotionHasOptimisedAnimation) === null || _b === void 0 ? void 0 : _b.call(window, optimisedAppearId)));\n    useIsomorphicLayoutEffect(() => {\n        if (!visualElement)\n            return;\n        isMounted.current = true;\n        window.MotionIsMounted = true;\n        visualElement.updateFeatures();\n        microtask.render(visualElement.render);\n        /**\n         * Ideally this function would always run in a useEffect.\n         *\n         * However, if we have optimised appear animations to handoff from,\n         * it needs to happen synchronously to ensure there's no flash of\n         * incorrect styles in the event of a hydration error.\n         *\n         * So if we detect a situtation where optimised appear animations\n         * are running, we use useLayoutEffect to trigger animations.\n         */\n        if (wantsHandoff.current && visualElement.animationState) {\n            visualElement.animationState.animateChanges();\n        }\n    });\n    useEffect(() => {\n        if (!visualElement)\n            return;\n        if (!wantsHandoff.current && visualElement.animationState) {\n            visualElement.animationState.animateChanges();\n        }\n        if (wantsHandoff.current) {\n            // This ensures all future calls to animateChanges() in this component will run in useEffect\n            queueMicrotask(() => {\n                var _a;\n                (_a = window.MotionHandoffMarkAsComplete) === null || _a === void 0 ? void 0 : _a.call(window, optimisedAppearId);\n            });\n            wantsHandoff.current = false;\n        }\n    });\n    return visualElement;\n}\nfunction createProjectionNode(visualElement, props, ProjectionNodeConstructor, initialPromotionConfig) {\n    const { layoutId, layout, drag, dragConstraints, layoutScroll, layoutRoot, } = props;\n    visualElement.projection = new ProjectionNodeConstructor(visualElement.latestValues, props[\"data-framer-portal-id\"]\n        ? undefined\n        : getClosestProjectingNode(visualElement.parent));\n    visualElement.projection.setOptions({\n        layoutId,\n        layout,\n        alwaysMeasureLayout: Boolean(drag) || (dragConstraints && isRefObject(dragConstraints)),\n        visualElement,\n        /**\n         * TODO: Update options in an effect. This could be tricky as it'll be too late\n         * to update by the time layout animations run.\n         * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,\n         * ensuring it gets called if there's no potential layout animations.\n         *\n         */\n        animationType: typeof layout === \"string\" ? layout : \"both\",\n        initialPromotionConfig,\n        layoutScroll,\n        layoutRoot,\n    });\n}\nfunction getClosestProjectingNode(visualElement) {\n    if (!visualElement)\n        return undefined;\n    return visualElement.options.allowProjection !== false\n        ? visualElement.projection\n        : getClosestProjectingNode(visualElement.parent);\n}\n\nexport { useVisualElement };\n"],"mappings":"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","ignoreList":[]},"targets":{},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/Users/anshul/Masters/Internship/POC/Meteor_Mobile/mieweb_push_auth","root":"/Users/anshul/Masters/Internship/POC/Meteor_Mobile/mieweb_push_auth","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true},"externalDependencies":[]},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.17.2","helpers":true,"useESModules":false,"corejs":false},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-react-jsx","visitor":{"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXFragment":{"exit":[null]},"JSXElement":{"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false},"externalDependencies":[]},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-nullish-coalescing-operator","visitor":{"LogicalExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-chaining","visitor":{"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-catch-binding","visitor":{"CatchClause":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"proposal-logical-assignment-operators","visitor":{"AssignmentExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]}],"presets":[],"generatorOpts":{"filename":"/Users/anshul/Masters/Internship/POC/Meteor_Mobile/mieweb_push_auth/node_modules/framer-motion/dist/es/motion/utils/use-visual-element.mjs","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"node_modules/framer-motion/dist/es/motion/utils/use-visual-element.mjs","inputSourceMap":{"version":3,"names":["useContext","useRef","useInsertionEffect","useEffect","PresenceContext","MotionContext","useIsomorphicLayoutEffect","LazyContext","MotionConfigContext","optimizedAppearDataAttribute","microtask","isRefObject","SwitchLayoutGroupContext","useVisualElement","Component","visualState","props","createVisualElement","ProjectionNodeConstructor","_s","_a","_b","visualElement","parent","lazyContext","presenceContext","reducedMotionConfig","reducedMotion","visualElementRef","renderer","current","blockInitialAnimation","initial","initialLayoutGroupConfig","projection","type","createProjectionNode","isMounted","update","optimisedAppearId","wantsHandoff","Boolean","window","MotionHandoffIsComplete","call","MotionHasOptimisedAnimation","MotionIsMounted","updateFeatures","render","animationState","animateChanges","queueMicrotask","MotionHandoffMarkAsComplete","initialPromotionConfig","layoutId","layout","drag","dragConstraints","layoutScroll","layoutRoot","latestValues","undefined","getClosestProjectingNode","setOptions","alwaysMeasureLayout","animationType","options","allowProjection"],"sources":["node_modules/framer-motion/dist/es/motion/utils/use-visual-element.mjs"],"sourcesContent":["import { useContext, useRef, useInsertionEffect, useEffect } from 'react';\nimport { PresenceContext } from '../../context/PresenceContext.mjs';\nimport { MotionContext } from '../../context/MotionContext/index.mjs';\nimport { useIsomorphicLayoutEffect } from '../../utils/use-isomorphic-effect.mjs';\nimport { LazyContext } from '../../context/LazyContext.mjs';\nimport { MotionConfigContext } from '../../context/MotionConfigContext.mjs';\nimport { optimizedAppearDataAttribute } from '../../animation/optimized-appear/data-id.mjs';\nimport { microtask } from '../../frameloop/microtask.mjs';\nimport { isRefObject } from '../../utils/is-ref-object.mjs';\nimport { SwitchLayoutGroupContext } from '../../context/SwitchLayoutGroupContext.mjs';\n\nfunction useVisualElement(Component, visualState, props, createVisualElement, ProjectionNodeConstructor) {\n    var _a, _b;\n    const { visualElement: parent } = useContext(MotionContext);\n    const lazyContext = useContext(LazyContext);\n    const presenceContext = useContext(PresenceContext);\n    const reducedMotionConfig = useContext(MotionConfigContext).reducedMotion;\n    const visualElementRef = useRef(null);\n    /**\n     * If we haven't preloaded a renderer, check to see if we have one lazy-loaded\n     */\n    createVisualElement = createVisualElement || lazyContext.renderer;\n    if (!visualElementRef.current && createVisualElement) {\n        visualElementRef.current = createVisualElement(Component, {\n            visualState,\n            parent,\n            props,\n            presenceContext,\n            blockInitialAnimation: presenceContext\n                ? presenceContext.initial === false\n                : false,\n            reducedMotionConfig,\n        });\n    }\n    const visualElement = visualElementRef.current;\n    /**\n     * Load Motion gesture and animation features. These are rendered as renderless\n     * components so each feature can optionally make use of React lifecycle methods.\n     */\n    const initialLayoutGroupConfig = useContext(SwitchLayoutGroupContext);\n    if (visualElement &&\n        !visualElement.projection &&\n        ProjectionNodeConstructor &&\n        (visualElement.type === \"html\" || visualElement.type === \"svg\")) {\n        createProjectionNode(visualElementRef.current, props, ProjectionNodeConstructor, initialLayoutGroupConfig);\n    }\n    const isMounted = useRef(false);\n    useInsertionEffect(() => {\n        /**\n         * Check the component has already mounted before calling\n         * `update` unnecessarily. This ensures we skip the initial update.\n         */\n        if (visualElement && isMounted.current) {\n            visualElement.update(props, presenceContext);\n        }\n    });\n    /**\n     * Cache this value as we want to know whether HandoffAppearAnimations\n     * was present on initial render - it will be deleted after this.\n     */\n    const optimisedAppearId = props[optimizedAppearDataAttribute];\n    const wantsHandoff = useRef(Boolean(optimisedAppearId) &&\n        !((_a = window.MotionHandoffIsComplete) === null || _a === void 0 ? void 0 : _a.call(window, optimisedAppearId)) &&\n        ((_b = window.MotionHasOptimisedAnimation) === null || _b === void 0 ? void 0 : _b.call(window, optimisedAppearId)));\n    useIsomorphicLayoutEffect(() => {\n        if (!visualElement)\n            return;\n        isMounted.current = true;\n        window.MotionIsMounted = true;\n        visualElement.updateFeatures();\n        microtask.render(visualElement.render);\n        /**\n         * Ideally this function would always run in a useEffect.\n         *\n         * However, if we have optimised appear animations to handoff from,\n         * it needs to happen synchronously to ensure there's no flash of\n         * incorrect styles in the event of a hydration error.\n         *\n         * So if we detect a situtation where optimised appear animations\n         * are running, we use useLayoutEffect to trigger animations.\n         */\n        if (wantsHandoff.current && visualElement.animationState) {\n            visualElement.animationState.animateChanges();\n        }\n    });\n    useEffect(() => {\n        if (!visualElement)\n            return;\n        if (!wantsHandoff.current && visualElement.animationState) {\n            visualElement.animationState.animateChanges();\n        }\n        if (wantsHandoff.current) {\n            // This ensures all future calls to animateChanges() in this component will run in useEffect\n            queueMicrotask(() => {\n                var _a;\n                (_a = window.MotionHandoffMarkAsComplete) === null || _a === void 0 ? void 0 : _a.call(window, optimisedAppearId);\n            });\n            wantsHandoff.current = false;\n        }\n    });\n    return visualElement;\n}\nfunction createProjectionNode(visualElement, props, ProjectionNodeConstructor, initialPromotionConfig) {\n    const { layoutId, layout, drag, dragConstraints, layoutScroll, layoutRoot, } = props;\n    visualElement.projection = new ProjectionNodeConstructor(visualElement.latestValues, props[\"data-framer-portal-id\"]\n        ? undefined\n        : getClosestProjectingNode(visualElement.parent));\n    visualElement.projection.setOptions({\n        layoutId,\n        layout,\n        alwaysMeasureLayout: Boolean(drag) || (dragConstraints && isRefObject(dragConstraints)),\n        visualElement,\n        /**\n         * TODO: Update options in an effect. This could be tricky as it'll be too late\n         * to update by the time layout animations run.\n         * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,\n         * ensuring it gets called if there's no potential layout animations.\n         *\n         */\n        animationType: typeof layout === \"string\" ? layout : \"both\",\n        initialPromotionConfig,\n        layoutScroll,\n        layoutRoot,\n    });\n}\nfunction getClosestProjectingNode(visualElement) {\n    if (!visualElement)\n        return undefined;\n    return visualElement.options.allowProjection !== false\n        ? visualElement.projection\n        : getClosestProjectingNode(visualElement.parent);\n}\n\nexport { useVisualElement };\n"],"mappings":"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","ignoreList":[]}}},"code":"!function (module1) {\n  module1.export({\n    useVisualElement: () => useVisualElement\n  });\n  let useContext, useRef, useInsertionEffect, useEffect;\n  module1.link(\"react\", {\n    useContext(v) {\n      useContext = v;\n    },\n    useRef(v) {\n      useRef = v;\n    },\n    useInsertionEffect(v) {\n      useInsertionEffect = v;\n    },\n    useEffect(v) {\n      useEffect = v;\n    }\n  }, 0);\n  let PresenceContext;\n  module1.link(\"../../context/PresenceContext.mjs\", {\n    PresenceContext(v) {\n      PresenceContext = v;\n    }\n  }, 1);\n  let MotionContext;\n  module1.link(\"../../context/MotionContext/index.mjs\", {\n    MotionContext(v) {\n      MotionContext = v;\n    }\n  }, 2);\n  let useIsomorphicLayoutEffect;\n  module1.link(\"../../utils/use-isomorphic-effect.mjs\", {\n    useIsomorphicLayoutEffect(v) {\n      useIsomorphicLayoutEffect = v;\n    }\n  }, 3);\n  let LazyContext;\n  module1.link(\"../../context/LazyContext.mjs\", {\n    LazyContext(v) {\n      LazyContext = v;\n    }\n  }, 4);\n  let MotionConfigContext;\n  module1.link(\"../../context/MotionConfigContext.mjs\", {\n    MotionConfigContext(v) {\n      MotionConfigContext = v;\n    }\n  }, 5);\n  let optimizedAppearDataAttribute;\n  module1.link(\"../../animation/optimized-appear/data-id.mjs\", {\n    optimizedAppearDataAttribute(v) {\n      optimizedAppearDataAttribute = v;\n    }\n  }, 6);\n  let microtask;\n  module1.link(\"../../frameloop/microtask.mjs\", {\n    microtask(v) {\n      microtask = v;\n    }\n  }, 7);\n  let isRefObject;\n  module1.link(\"../../utils/is-ref-object.mjs\", {\n    isRefObject(v) {\n      isRefObject = v;\n    }\n  }, 8);\n  let SwitchLayoutGroupContext;\n  module1.link(\"../../context/SwitchLayoutGroupContext.mjs\", {\n    SwitchLayoutGroupContext(v) {\n      SwitchLayoutGroupContext = v;\n    }\n  }, 9);\n  ___INIT_METEOR_FAST_REFRESH(module);\n  var _s = $RefreshSig$();\n  function useVisualElement(Component, visualState, props, createVisualElement, ProjectionNodeConstructor) {\n    _s();\n    var _a, _b;\n    const {\n      visualElement: parent\n    } = useContext(MotionContext);\n    const lazyContext = useContext(LazyContext);\n    const presenceContext = useContext(PresenceContext);\n    const reducedMotionConfig = useContext(MotionConfigContext).reducedMotion;\n    const visualElementRef = useRef(null);\n    /**\n     * If we haven't preloaded a renderer, check to see if we have one lazy-loaded\n     */\n    createVisualElement = createVisualElement || lazyContext.renderer;\n    if (!visualElementRef.current && createVisualElement) {\n      visualElementRef.current = createVisualElement(Component, {\n        visualState,\n        parent,\n        props,\n        presenceContext,\n        blockInitialAnimation: presenceContext ? presenceContext.initial === false : false,\n        reducedMotionConfig\n      });\n    }\n    const visualElement = visualElementRef.current;\n    /**\n     * Load Motion gesture and animation features. These are rendered as renderless\n     * components so each feature can optionally make use of React lifecycle methods.\n     */\n    const initialLayoutGroupConfig = useContext(SwitchLayoutGroupContext);\n    if (visualElement && !visualElement.projection && ProjectionNodeConstructor && (visualElement.type === \"html\" || visualElement.type === \"svg\")) {\n      createProjectionNode(visualElementRef.current, props, ProjectionNodeConstructor, initialLayoutGroupConfig);\n    }\n    const isMounted = useRef(false);\n    useInsertionEffect(() => {\n      /**\n       * Check the component has already mounted before calling\n       * `update` unnecessarily. This ensures we skip the initial update.\n       */\n      if (visualElement && isMounted.current) {\n        visualElement.update(props, presenceContext);\n      }\n    });\n    /**\n     * Cache this value as we want to know whether HandoffAppearAnimations\n     * was present on initial render - it will be deleted after this.\n     */\n    const optimisedAppearId = props[optimizedAppearDataAttribute];\n    const wantsHandoff = useRef(Boolean(optimisedAppearId) && !((_a = window.MotionHandoffIsComplete) === null || _a === void 0 ? void 0 : _a.call(window, optimisedAppearId)) && ((_b = window.MotionHasOptimisedAnimation) === null || _b === void 0 ? void 0 : _b.call(window, optimisedAppearId)));\n    useIsomorphicLayoutEffect(() => {\n      if (!visualElement) return;\n      isMounted.current = true;\n      window.MotionIsMounted = true;\n      visualElement.updateFeatures();\n      microtask.render(visualElement.render);\n      /**\n       * Ideally this function would always run in a useEffect.\n       *\n       * However, if we have optimised appear animations to handoff from,\n       * it needs to happen synchronously to ensure there's no flash of\n       * incorrect styles in the event of a hydration error.\n       *\n       * So if we detect a situtation where optimised appear animations\n       * are running, we use useLayoutEffect to trigger animations.\n       */\n      if (wantsHandoff.current && visualElement.animationState) {\n        visualElement.animationState.animateChanges();\n      }\n    });\n    useEffect(() => {\n      if (!visualElement) return;\n      if (!wantsHandoff.current && visualElement.animationState) {\n        visualElement.animationState.animateChanges();\n      }\n      if (wantsHandoff.current) {\n        // This ensures all future calls to animateChanges() in this component will run in useEffect\n        queueMicrotask(() => {\n          var _a;\n          (_a = window.MotionHandoffMarkAsComplete) === null || _a === void 0 ? void 0 : _a.call(window, optimisedAppearId);\n        });\n        wantsHandoff.current = false;\n      }\n    });\n    return visualElement;\n  }\n  _s(useVisualElement, \"Q8Mn+xAMstIAeELyjBEYWP7EJ0I=\", false, function () {\n    return [useInsertionEffect, useIsomorphicLayoutEffect];\n  });\n  function createProjectionNode(visualElement, props, ProjectionNodeConstructor, initialPromotionConfig) {\n    const {\n      layoutId,\n      layout,\n      drag,\n      dragConstraints,\n      layoutScroll,\n      layoutRoot\n    } = props;\n    visualElement.projection = new ProjectionNodeConstructor(visualElement.latestValues, props[\"data-framer-portal-id\"] ? undefined : getClosestProjectingNode(visualElement.parent));\n    visualElement.projection.setOptions({\n      layoutId,\n      layout,\n      alwaysMeasureLayout: Boolean(drag) || dragConstraints && isRefObject(dragConstraints),\n      visualElement,\n      /**\n       * TODO: Update options in an effect. This could be tricky as it'll be too late\n       * to update by the time layout animations run.\n       * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,\n       * ensuring it gets called if there's no potential layout animations.\n       *\n       */\n      animationType: typeof layout === \"string\" ? layout : \"both\",\n      initialPromotionConfig,\n      layoutScroll,\n      layoutRoot\n    });\n  }\n  function getClosestProjectingNode(visualElement) {\n    if (!visualElement) return undefined;\n    return visualElement.options.allowProjection !== false ? visualElement.projection : getClosestProjectingNode(visualElement.parent);\n  }\n}.call(this, module);","map":{"version":3,"names":["useVisualElement","Component","visualState","props","createVisualElement","ProjectionNodeConstructor","_s","_a","_b","visualElement","parent","useContext","MotionContext","lazyContext","LazyContext","presenceContext","PresenceContext","reducedMotionConfig","MotionConfigContext","reducedMotion","visualElementRef","useRef","renderer","current","blockInitialAnimation","initial","initialLayoutGroupConfig","SwitchLayoutGroupContext","projection","type","createProjectionNode","isMounted","useInsertionEffect","update","optimisedAppearId","optimizedAppearDataAttribute","wantsHandoff","Boolean","window","MotionHandoffIsComplete","call","MotionHasOptimisedAnimation","useIsomorphicLayoutEffect","MotionIsMounted","updateFeatures","microtask","render","animationState","animateChanges","useEffect","queueMicrotask","MotionHandoffMarkAsComplete","initialPromotionConfig","layoutId","layout","drag","dragConstraints","layoutScroll","layoutRoot","latestValues","undefined","getClosestProjectingNode","setOptions","alwaysMeasureLayout","isRefObject","animationType","options","allowProjection","module"],"sources":["node_modules/framer-motion/dist/es/motion/utils/use-visual-element.mjs"],"sourcesContent":["import { useContext, useRef, useInsertionEffect, useEffect } from 'react';\nimport { PresenceContext } from '../../context/PresenceContext.mjs';\nimport { MotionContext } from '../../context/MotionContext/index.mjs';\nimport { useIsomorphicLayoutEffect } from '../../utils/use-isomorphic-effect.mjs';\nimport { LazyContext } from '../../context/LazyContext.mjs';\nimport { MotionConfigContext } from '../../context/MotionConfigContext.mjs';\nimport { optimizedAppearDataAttribute } from '../../animation/optimized-appear/data-id.mjs';\nimport { microtask } from '../../frameloop/microtask.mjs';\nimport { isRefObject } from '../../utils/is-ref-object.mjs';\nimport { SwitchLayoutGroupContext } from '../../context/SwitchLayoutGroupContext.mjs';\n\nfunction useVisualElement(Component, visualState, props, createVisualElement, ProjectionNodeConstructor) {\n    var _a, _b;\n    const { visualElement: parent } = useContext(MotionContext);\n    const lazyContext = useContext(LazyContext);\n    const presenceContext = useContext(PresenceContext);\n    const reducedMotionConfig = useContext(MotionConfigContext).reducedMotion;\n    const visualElementRef = useRef(null);\n    /**\n     * If we haven't preloaded a renderer, check to see if we have one lazy-loaded\n     */\n    createVisualElement = createVisualElement || lazyContext.renderer;\n    if (!visualElementRef.current && createVisualElement) {\n        visualElementRef.current = createVisualElement(Component, {\n            visualState,\n            parent,\n            props,\n            presenceContext,\n            blockInitialAnimation: presenceContext\n                ? presenceContext.initial === false\n                : false,\n            reducedMotionConfig,\n        });\n    }\n    const visualElement = visualElementRef.current;\n    /**\n     * Load Motion gesture and animation features. These are rendered as renderless\n     * components so each feature can optionally make use of React lifecycle methods.\n     */\n    const initialLayoutGroupConfig = useContext(SwitchLayoutGroupContext);\n    if (visualElement &&\n        !visualElement.projection &&\n        ProjectionNodeConstructor &&\n        (visualElement.type === \"html\" || visualElement.type === \"svg\")) {\n        createProjectionNode(visualElementRef.current, props, ProjectionNodeConstructor, initialLayoutGroupConfig);\n    }\n    const isMounted = useRef(false);\n    useInsertionEffect(() => {\n        /**\n         * Check the component has already mounted before calling\n         * `update` unnecessarily. This ensures we skip the initial update.\n         */\n        if (visualElement && isMounted.current) {\n            visualElement.update(props, presenceContext);\n        }\n    });\n    /**\n     * Cache this value as we want to know whether HandoffAppearAnimations\n     * was present on initial render - it will be deleted after this.\n     */\n    const optimisedAppearId = props[optimizedAppearDataAttribute];\n    const wantsHandoff = useRef(Boolean(optimisedAppearId) &&\n        !((_a = window.MotionHandoffIsComplete) === null || _a === void 0 ? void 0 : _a.call(window, optimisedAppearId)) &&\n        ((_b = window.MotionHasOptimisedAnimation) === null || _b === void 0 ? void 0 : _b.call(window, optimisedAppearId)));\n    useIsomorphicLayoutEffect(() => {\n        if (!visualElement)\n            return;\n        isMounted.current = true;\n        window.MotionIsMounted = true;\n        visualElement.updateFeatures();\n        microtask.render(visualElement.render);\n        /**\n         * Ideally this function would always run in a useEffect.\n         *\n         * However, if we have optimised appear animations to handoff from,\n         * it needs to happen synchronously to ensure there's no flash of\n         * incorrect styles in the event of a hydration error.\n         *\n         * So if we detect a situtation where optimised appear animations\n         * are running, we use useLayoutEffect to trigger animations.\n         */\n        if (wantsHandoff.current && visualElement.animationState) {\n            visualElement.animationState.animateChanges();\n        }\n    });\n    useEffect(() => {\n        if (!visualElement)\n            return;\n        if (!wantsHandoff.current && visualElement.animationState) {\n            visualElement.animationState.animateChanges();\n        }\n        if (wantsHandoff.current) {\n            // This ensures all future calls to animateChanges() in this component will run in useEffect\n            queueMicrotask(() => {\n                var _a;\n                (_a = window.MotionHandoffMarkAsComplete) === null || _a === void 0 ? void 0 : _a.call(window, optimisedAppearId);\n            });\n            wantsHandoff.current = false;\n        }\n    });\n    return visualElement;\n}\nfunction createProjectionNode(visualElement, props, ProjectionNodeConstructor, initialPromotionConfig) {\n    const { layoutId, layout, drag, dragConstraints, layoutScroll, layoutRoot, } = props;\n    visualElement.projection = new ProjectionNodeConstructor(visualElement.latestValues, props[\"data-framer-portal-id\"]\n        ? undefined\n        : getClosestProjectingNode(visualElement.parent));\n    visualElement.projection.setOptions({\n        layoutId,\n        layout,\n        alwaysMeasureLayout: Boolean(drag) || (dragConstraints && isRefObject(dragConstraints)),\n        visualElement,\n        /**\n         * TODO: Update options in an effect. This could be tricky as it'll be too late\n         * to update by the time layout animations run.\n         * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,\n         * ensuring it gets called if there's no potential layout animations.\n         *\n         */\n        animationType: typeof layout === \"string\" ? layout : \"both\",\n        initialPromotionConfig,\n        layoutScroll,\n        layoutRoot,\n    });\n}\nfunction getClosestProjectingNode(visualElement) {\n    if (!visualElement)\n        return undefined;\n    return visualElement.options.allowProjection !== false\n        ? visualElement.projection\n        : getClosestProjectingNode(visualElement.parent);\n}\n\nexport { useVisualElement };\n"],"mappings":"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","ignoreList":[]},"sourceType":"module","externalDependencies":{},"hash":"e2c4a9800ee018f81bdd711a57d5af37576bee83"}
