{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/anshul/Masters/Internship/POC/Meteor_Mobile/mieweb_push_auth/node_modules/framer-motion/dist/es/render/utils/animation-state.mjs","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","topLevelAwait","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"web.browser"},"sourceFileName":"node_modules/framer-motion/dist/es/render/utils/animation-state.mjs","filename":"/Users/anshul/Masters/Internship/POC/Meteor_Mobile/mieweb_push_auth/node_modules/framer-motion/dist/es/render/utils/animation-state.mjs","inputSourceMap":{"version":3,"names":["isAnimationControls","isKeyframesTarget","shallowCompare","isVariantLabel","resolveVariant","variantPriorityOrder","animateVisualElement","getVariantContext","reversePriorityOrder","reverse","numAnimationTypes","length","animateList","visualElement","animations","Promise","all","map","animation","options","createAnimationState","animate","state","createState","isInitialRender","buildResolvedTypeValues","type","acc","definition","_a","resolved","presenceContext","custom","undefined","transition","transitionEnd","target","setAnimateFunction","makeAnimator","animateChanges","changedActiveType","props","context","parent","removedKeys","Set","encounteredKeys","removedVariantIndex","Infinity","i","typeState","prop","propIsVariant","activeDelta","isActive","isInherited","manuallyAnimateOnMount","protectedKeys","prevProp","variantDidChange","checkVariantsDidChange","shouldAnimateType","handledRemovedValues","definitionList","Array","isArray","resolvedValues","reduce","prevResolvedValues","allKeys","markToAnimate","key","has","delete","needsAnimating","motionValue","getValue","liveStyle","next","prev","hasOwnProperty","valueHasChanged","add","blockInitialAnimation","willAnimateViaParent","push","size","fallbackAnimation","forEach","fallbackTarget","getBaseTarget","shouldAnimate","Boolean","initial","resolve","setActive","variantChildren","child","animationState","getState","reset","createTypeState","whileInView","whileHover","whileTap","whileDrag","whileFocus","exit"],"sources":["node_modules/framer-motion/dist/es/render/utils/animation-state.mjs"],"sourcesContent":["import { isAnimationControls } from '../../animation/utils/is-animation-controls.mjs';\nimport { isKeyframesTarget } from '../../animation/utils/is-keyframes-target.mjs';\nimport { shallowCompare } from '../../utils/shallow-compare.mjs';\nimport { isVariantLabel } from './is-variant-label.mjs';\nimport { resolveVariant } from './resolve-dynamic-variants.mjs';\nimport { variantPriorityOrder } from './variant-props.mjs';\nimport { animateVisualElement } from '../../animation/interfaces/visual-element.mjs';\nimport { getVariantContext } from './get-variant-context.mjs';\n\nconst reversePriorityOrder = [...variantPriorityOrder].reverse();\nconst numAnimationTypes = variantPriorityOrder.length;\nfunction animateList(visualElement) {\n    return (animations) => Promise.all(animations.map(({ animation, options }) => animateVisualElement(visualElement, animation, options)));\n}\nfunction createAnimationState(visualElement) {\n    let animate = animateList(visualElement);\n    let state = createState();\n    let isInitialRender = true;\n    /**\n     * This function will be used to reduce the animation definitions for\n     * each active animation type into an object of resolved values for it.\n     */\n    const buildResolvedTypeValues = (type) => (acc, definition) => {\n        var _a;\n        const resolved = resolveVariant(visualElement, definition, type === \"exit\"\n            ? (_a = visualElement.presenceContext) === null || _a === void 0 ? void 0 : _a.custom\n            : undefined);\n        if (resolved) {\n            const { transition, transitionEnd, ...target } = resolved;\n            acc = { ...acc, ...target, ...transitionEnd };\n        }\n        return acc;\n    };\n    /**\n     * This just allows us to inject mocked animation functions\n     * @internal\n     */\n    function setAnimateFunction(makeAnimator) {\n        animate = makeAnimator(visualElement);\n    }\n    /**\n     * When we receive new props, we need to:\n     * 1. Create a list of protected keys for each type. This is a directory of\n     *    value keys that are currently being \"handled\" by types of a higher priority\n     *    so that whenever an animation is played of a given type, these values are\n     *    protected from being animated.\n     * 2. Determine if an animation type needs animating.\n     * 3. Determine if any values have been removed from a type and figure out\n     *    what to animate those to.\n     */\n    function animateChanges(changedActiveType) {\n        const { props } = visualElement;\n        const context = getVariantContext(visualElement.parent) || {};\n        /**\n         * A list of animations that we'll build into as we iterate through the animation\n         * types. This will get executed at the end of the function.\n         */\n        const animations = [];\n        /**\n         * Keep track of which values have been removed. Then, as we hit lower priority\n         * animation types, we can check if they contain removed values and animate to that.\n         */\n        const removedKeys = new Set();\n        /**\n         * A dictionary of all encountered keys. This is an object to let us build into and\n         * copy it without iteration. Each time we hit an animation type we set its protected\n         * keys - the keys its not allowed to animate - to the latest version of this object.\n         */\n        let encounteredKeys = {};\n        /**\n         * If a variant has been removed at a given index, and this component is controlling\n         * variant animations, we want to ensure lower-priority variants are forced to animate.\n         */\n        let removedVariantIndex = Infinity;\n        /**\n         * Iterate through all animation types in reverse priority order. For each, we want to\n         * detect which values it's handling and whether or not they've changed (and therefore\n         * need to be animated). If any values have been removed, we want to detect those in\n         * lower priority props and flag for animation.\n         */\n        for (let i = 0; i < numAnimationTypes; i++) {\n            const type = reversePriorityOrder[i];\n            const typeState = state[type];\n            const prop = props[type] !== undefined\n                ? props[type]\n                : context[type];\n            const propIsVariant = isVariantLabel(prop);\n            /**\n             * If this type has *just* changed isActive status, set activeDelta\n             * to that status. Otherwise set to null.\n             */\n            const activeDelta = type === changedActiveType ? typeState.isActive : null;\n            if (activeDelta === false)\n                removedVariantIndex = i;\n            /**\n             * If this prop is an inherited variant, rather than been set directly on the\n             * component itself, we want to make sure we allow the parent to trigger animations.\n             *\n             * TODO: Can probably change this to a !isControllingVariants check\n             */\n            let isInherited = prop === context[type] &&\n                prop !== props[type] &&\n                propIsVariant;\n            /**\n             *\n             */\n            if (isInherited &&\n                isInitialRender &&\n                visualElement.manuallyAnimateOnMount) {\n                isInherited = false;\n            }\n            /**\n             * Set all encountered keys so far as the protected keys for this type. This will\n             * be any key that has been animated or otherwise handled by active, higher-priortiy types.\n             */\n            typeState.protectedKeys = { ...encounteredKeys };\n            // Check if we can skip analysing this prop early\n            if (\n            // If it isn't active and hasn't *just* been set as inactive\n            (!typeState.isActive && activeDelta === null) ||\n                // If we didn't and don't have any defined prop for this animation type\n                (!prop && !typeState.prevProp) ||\n                // Or if the prop doesn't define an animation\n                isAnimationControls(prop) ||\n                typeof prop === \"boolean\") {\n                continue;\n            }\n            /**\n             * As we go look through the values defined on this type, if we detect\n             * a changed value or a value that was removed in a higher priority, we set\n             * this to true and add this prop to the animation list.\n             */\n            const variantDidChange = checkVariantsDidChange(typeState.prevProp, prop);\n            let shouldAnimateType = variantDidChange ||\n                // If we're making this variant active, we want to always make it active\n                (type === changedActiveType &&\n                    typeState.isActive &&\n                    !isInherited &&\n                    propIsVariant) ||\n                // If we removed a higher-priority variant (i is in reverse order)\n                (i > removedVariantIndex && propIsVariant);\n            let handledRemovedValues = false;\n            /**\n             * As animations can be set as variant lists, variants or target objects, we\n             * coerce everything to an array if it isn't one already\n             */\n            const definitionList = Array.isArray(prop) ? prop : [prop];\n            /**\n             * Build an object of all the resolved values. We'll use this in the subsequent\n             * animateChanges calls to determine whether a value has changed.\n             */\n            let resolvedValues = definitionList.reduce(buildResolvedTypeValues(type), {});\n            if (activeDelta === false)\n                resolvedValues = {};\n            /**\n             * Now we need to loop through all the keys in the prev prop and this prop,\n             * and decide:\n             * 1. If the value has changed, and needs animating\n             * 2. If it has been removed, and needs adding to the removedKeys set\n             * 3. If it has been removed in a higher priority type and needs animating\n             * 4. If it hasn't been removed in a higher priority but hasn't changed, and\n             *    needs adding to the type's protectedKeys list.\n             */\n            const { prevResolvedValues = {} } = typeState;\n            const allKeys = {\n                ...prevResolvedValues,\n                ...resolvedValues,\n            };\n            const markToAnimate = (key) => {\n                shouldAnimateType = true;\n                if (removedKeys.has(key)) {\n                    handledRemovedValues = true;\n                    removedKeys.delete(key);\n                }\n                typeState.needsAnimating[key] = true;\n                const motionValue = visualElement.getValue(key);\n                if (motionValue)\n                    motionValue.liveStyle = false;\n            };\n            for (const key in allKeys) {\n                const next = resolvedValues[key];\n                const prev = prevResolvedValues[key];\n                // If we've already handled this we can just skip ahead\n                if (encounteredKeys.hasOwnProperty(key))\n                    continue;\n                /**\n                 * If the value has changed, we probably want to animate it.\n                 */\n                let valueHasChanged = false;\n                if (isKeyframesTarget(next) && isKeyframesTarget(prev)) {\n                    valueHasChanged = !shallowCompare(next, prev);\n                }\n                else {\n                    valueHasChanged = next !== prev;\n                }\n                if (valueHasChanged) {\n                    if (next !== undefined && next !== null) {\n                        // If next is defined and doesn't equal prev, it needs animating\n                        markToAnimate(key);\n                    }\n                    else {\n                        // If it's undefined, it's been removed.\n                        removedKeys.add(key);\n                    }\n                }\n                else if (next !== undefined && removedKeys.has(key)) {\n                    /**\n                     * If next hasn't changed and it isn't undefined, we want to check if it's\n                     * been removed by a higher priority\n                     */\n                    markToAnimate(key);\n                }\n                else {\n                    /**\n                     * If it hasn't changed, we add it to the list of protected values\n                     * to ensure it doesn't get animated.\n                     */\n                    typeState.protectedKeys[key] = true;\n                }\n            }\n            /**\n             * Update the typeState so next time animateChanges is called we can compare the\n             * latest prop and resolvedValues to these.\n             */\n            typeState.prevProp = prop;\n            typeState.prevResolvedValues = resolvedValues;\n            /**\n             *\n             */\n            if (typeState.isActive) {\n                encounteredKeys = { ...encounteredKeys, ...resolvedValues };\n            }\n            if (isInitialRender && visualElement.blockInitialAnimation) {\n                shouldAnimateType = false;\n            }\n            /**\n             * If this is an inherited prop we want to skip this animation\n             * unless the inherited variants haven't changed on this render.\n             */\n            const willAnimateViaParent = isInherited && variantDidChange;\n            const needsAnimating = !willAnimateViaParent || handledRemovedValues;\n            if (shouldAnimateType && needsAnimating) {\n                animations.push(...definitionList.map((animation) => ({\n                    animation: animation,\n                    options: { type },\n                })));\n            }\n        }\n        /**\n         * If there are some removed value that haven't been dealt with,\n         * we need to create a new animation that falls back either to the value\n         * defined in the style prop, or the last read value.\n         */\n        if (removedKeys.size) {\n            const fallbackAnimation = {};\n            removedKeys.forEach((key) => {\n                const fallbackTarget = visualElement.getBaseTarget(key);\n                const motionValue = visualElement.getValue(key);\n                if (motionValue)\n                    motionValue.liveStyle = true;\n                // @ts-expect-error - @mattgperry to figure if we should do something here\n                fallbackAnimation[key] = fallbackTarget !== null && fallbackTarget !== void 0 ? fallbackTarget : null;\n            });\n            animations.push({ animation: fallbackAnimation });\n        }\n        let shouldAnimate = Boolean(animations.length);\n        if (isInitialRender &&\n            (props.initial === false || props.initial === props.animate) &&\n            !visualElement.manuallyAnimateOnMount) {\n            shouldAnimate = false;\n        }\n        isInitialRender = false;\n        return shouldAnimate ? animate(animations) : Promise.resolve();\n    }\n    /**\n     * Change whether a certain animation type is active.\n     */\n    function setActive(type, isActive) {\n        var _a;\n        // If the active state hasn't changed, we can safely do nothing here\n        if (state[type].isActive === isActive)\n            return Promise.resolve();\n        // Propagate active change to children\n        (_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.forEach((child) => { var _a; return (_a = child.animationState) === null || _a === void 0 ? void 0 : _a.setActive(type, isActive); });\n        state[type].isActive = isActive;\n        const animations = animateChanges(type);\n        for (const key in state) {\n            state[key].protectedKeys = {};\n        }\n        return animations;\n    }\n    return {\n        animateChanges,\n        setActive,\n        setAnimateFunction,\n        getState: () => state,\n        reset: () => {\n            state = createState();\n            isInitialRender = true;\n        },\n    };\n}\nfunction checkVariantsDidChange(prev, next) {\n    if (typeof next === \"string\") {\n        return next !== prev;\n    }\n    else if (Array.isArray(next)) {\n        return !shallowCompare(next, prev);\n    }\n    return false;\n}\nfunction createTypeState(isActive = false) {\n    return {\n        isActive,\n        protectedKeys: {},\n        needsAnimating: {},\n        prevResolvedValues: {},\n    };\n}\nfunction createState() {\n    return {\n        animate: createTypeState(true),\n        whileInView: createTypeState(),\n        whileHover: createTypeState(),\n        whileTap: createTypeState(),\n        whileDrag: createTypeState(),\n        whileFocus: createTypeState(),\n        exit: createTypeState(),\n    };\n}\n\nexport { checkVariantsDidChange, createAnimationState };\n"],"mappings":"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","ignoreList":[]},"targets":{},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/Users/anshul/Masters/Internship/POC/Meteor_Mobile/mieweb_push_auth","root":"/Users/anshul/Masters/Internship/POC/Meteor_Mobile/mieweb_push_auth","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true},"externalDependencies":[]},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.17.2","helpers":true,"useESModules":false,"corejs":false},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-react-jsx","visitor":{"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXFragment":{"exit":[null]},"JSXElement":{"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false},"externalDependencies":[]},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-nullish-coalescing-operator","visitor":{"LogicalExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-chaining","visitor":{"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-catch-binding","visitor":{"CatchClause":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"proposal-logical-assignment-operators","visitor":{"AssignmentExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]}],"presets":[],"generatorOpts":{"filename":"/Users/anshul/Masters/Internship/POC/Meteor_Mobile/mieweb_push_auth/node_modules/framer-motion/dist/es/render/utils/animation-state.mjs","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"node_modules/framer-motion/dist/es/render/utils/animation-state.mjs","inputSourceMap":{"version":3,"names":["isAnimationControls","isKeyframesTarget","shallowCompare","isVariantLabel","resolveVariant","variantPriorityOrder","animateVisualElement","getVariantContext","reversePriorityOrder","reverse","numAnimationTypes","length","animateList","visualElement","animations","Promise","all","map","animation","options","createAnimationState","animate","state","createState","isInitialRender","buildResolvedTypeValues","type","acc","definition","_a","resolved","presenceContext","custom","undefined","transition","transitionEnd","target","setAnimateFunction","makeAnimator","animateChanges","changedActiveType","props","context","parent","removedKeys","Set","encounteredKeys","removedVariantIndex","Infinity","i","typeState","prop","propIsVariant","activeDelta","isActive","isInherited","manuallyAnimateOnMount","protectedKeys","prevProp","variantDidChange","checkVariantsDidChange","shouldAnimateType","handledRemovedValues","definitionList","Array","isArray","resolvedValues","reduce","prevResolvedValues","allKeys","markToAnimate","key","has","delete","needsAnimating","motionValue","getValue","liveStyle","next","prev","hasOwnProperty","valueHasChanged","add","blockInitialAnimation","willAnimateViaParent","push","size","fallbackAnimation","forEach","fallbackTarget","getBaseTarget","shouldAnimate","Boolean","initial","resolve","setActive","variantChildren","child","animationState","getState","reset","createTypeState","whileInView","whileHover","whileTap","whileDrag","whileFocus","exit"],"sources":["node_modules/framer-motion/dist/es/render/utils/animation-state.mjs"],"sourcesContent":["import { isAnimationControls } from '../../animation/utils/is-animation-controls.mjs';\nimport { isKeyframesTarget } from '../../animation/utils/is-keyframes-target.mjs';\nimport { shallowCompare } from '../../utils/shallow-compare.mjs';\nimport { isVariantLabel } from './is-variant-label.mjs';\nimport { resolveVariant } from './resolve-dynamic-variants.mjs';\nimport { variantPriorityOrder } from './variant-props.mjs';\nimport { animateVisualElement } from '../../animation/interfaces/visual-element.mjs';\nimport { getVariantContext } from './get-variant-context.mjs';\n\nconst reversePriorityOrder = [...variantPriorityOrder].reverse();\nconst numAnimationTypes = variantPriorityOrder.length;\nfunction animateList(visualElement) {\n    return (animations) => Promise.all(animations.map(({ animation, options }) => animateVisualElement(visualElement, animation, options)));\n}\nfunction createAnimationState(visualElement) {\n    let animate = animateList(visualElement);\n    let state = createState();\n    let isInitialRender = true;\n    /**\n     * This function will be used to reduce the animation definitions for\n     * each active animation type into an object of resolved values for it.\n     */\n    const buildResolvedTypeValues = (type) => (acc, definition) => {\n        var _a;\n        const resolved = resolveVariant(visualElement, definition, type === \"exit\"\n            ? (_a = visualElement.presenceContext) === null || _a === void 0 ? void 0 : _a.custom\n            : undefined);\n        if (resolved) {\n            const { transition, transitionEnd, ...target } = resolved;\n            acc = { ...acc, ...target, ...transitionEnd };\n        }\n        return acc;\n    };\n    /**\n     * This just allows us to inject mocked animation functions\n     * @internal\n     */\n    function setAnimateFunction(makeAnimator) {\n        animate = makeAnimator(visualElement);\n    }\n    /**\n     * When we receive new props, we need to:\n     * 1. Create a list of protected keys for each type. This is a directory of\n     *    value keys that are currently being \"handled\" by types of a higher priority\n     *    so that whenever an animation is played of a given type, these values are\n     *    protected from being animated.\n     * 2. Determine if an animation type needs animating.\n     * 3. Determine if any values have been removed from a type and figure out\n     *    what to animate those to.\n     */\n    function animateChanges(changedActiveType) {\n        const { props } = visualElement;\n        const context = getVariantContext(visualElement.parent) || {};\n        /**\n         * A list of animations that we'll build into as we iterate through the animation\n         * types. This will get executed at the end of the function.\n         */\n        const animations = [];\n        /**\n         * Keep track of which values have been removed. Then, as we hit lower priority\n         * animation types, we can check if they contain removed values and animate to that.\n         */\n        const removedKeys = new Set();\n        /**\n         * A dictionary of all encountered keys. This is an object to let us build into and\n         * copy it without iteration. Each time we hit an animation type we set its protected\n         * keys - the keys its not allowed to animate - to the latest version of this object.\n         */\n        let encounteredKeys = {};\n        /**\n         * If a variant has been removed at a given index, and this component is controlling\n         * variant animations, we want to ensure lower-priority variants are forced to animate.\n         */\n        let removedVariantIndex = Infinity;\n        /**\n         * Iterate through all animation types in reverse priority order. For each, we want to\n         * detect which values it's handling and whether or not they've changed (and therefore\n         * need to be animated). If any values have been removed, we want to detect those in\n         * lower priority props and flag for animation.\n         */\n        for (let i = 0; i < numAnimationTypes; i++) {\n            const type = reversePriorityOrder[i];\n            const typeState = state[type];\n            const prop = props[type] !== undefined\n                ? props[type]\n                : context[type];\n            const propIsVariant = isVariantLabel(prop);\n            /**\n             * If this type has *just* changed isActive status, set activeDelta\n             * to that status. Otherwise set to null.\n             */\n            const activeDelta = type === changedActiveType ? typeState.isActive : null;\n            if (activeDelta === false)\n                removedVariantIndex = i;\n            /**\n             * If this prop is an inherited variant, rather than been set directly on the\n             * component itself, we want to make sure we allow the parent to trigger animations.\n             *\n             * TODO: Can probably change this to a !isControllingVariants check\n             */\n            let isInherited = prop === context[type] &&\n                prop !== props[type] &&\n                propIsVariant;\n            /**\n             *\n             */\n            if (isInherited &&\n                isInitialRender &&\n                visualElement.manuallyAnimateOnMount) {\n                isInherited = false;\n            }\n            /**\n             * Set all encountered keys so far as the protected keys for this type. This will\n             * be any key that has been animated or otherwise handled by active, higher-priortiy types.\n             */\n            typeState.protectedKeys = { ...encounteredKeys };\n            // Check if we can skip analysing this prop early\n            if (\n            // If it isn't active and hasn't *just* been set as inactive\n            (!typeState.isActive && activeDelta === null) ||\n                // If we didn't and don't have any defined prop for this animation type\n                (!prop && !typeState.prevProp) ||\n                // Or if the prop doesn't define an animation\n                isAnimationControls(prop) ||\n                typeof prop === \"boolean\") {\n                continue;\n            }\n            /**\n             * As we go look through the values defined on this type, if we detect\n             * a changed value or a value that was removed in a higher priority, we set\n             * this to true and add this prop to the animation list.\n             */\n            const variantDidChange = checkVariantsDidChange(typeState.prevProp, prop);\n            let shouldAnimateType = variantDidChange ||\n                // If we're making this variant active, we want to always make it active\n                (type === changedActiveType &&\n                    typeState.isActive &&\n                    !isInherited &&\n                    propIsVariant) ||\n                // If we removed a higher-priority variant (i is in reverse order)\n                (i > removedVariantIndex && propIsVariant);\n            let handledRemovedValues = false;\n            /**\n             * As animations can be set as variant lists, variants or target objects, we\n             * coerce everything to an array if it isn't one already\n             */\n            const definitionList = Array.isArray(prop) ? prop : [prop];\n            /**\n             * Build an object of all the resolved values. We'll use this in the subsequent\n             * animateChanges calls to determine whether a value has changed.\n             */\n            let resolvedValues = definitionList.reduce(buildResolvedTypeValues(type), {});\n            if (activeDelta === false)\n                resolvedValues = {};\n            /**\n             * Now we need to loop through all the keys in the prev prop and this prop,\n             * and decide:\n             * 1. If the value has changed, and needs animating\n             * 2. If it has been removed, and needs adding to the removedKeys set\n             * 3. If it has been removed in a higher priority type and needs animating\n             * 4. If it hasn't been removed in a higher priority but hasn't changed, and\n             *    needs adding to the type's protectedKeys list.\n             */\n            const { prevResolvedValues = {} } = typeState;\n            const allKeys = {\n                ...prevResolvedValues,\n                ...resolvedValues,\n            };\n            const markToAnimate = (key) => {\n                shouldAnimateType = true;\n                if (removedKeys.has(key)) {\n                    handledRemovedValues = true;\n                    removedKeys.delete(key);\n                }\n                typeState.needsAnimating[key] = true;\n                const motionValue = visualElement.getValue(key);\n                if (motionValue)\n                    motionValue.liveStyle = false;\n            };\n            for (const key in allKeys) {\n                const next = resolvedValues[key];\n                const prev = prevResolvedValues[key];\n                // If we've already handled this we can just skip ahead\n                if (encounteredKeys.hasOwnProperty(key))\n                    continue;\n                /**\n                 * If the value has changed, we probably want to animate it.\n                 */\n                let valueHasChanged = false;\n                if (isKeyframesTarget(next) && isKeyframesTarget(prev)) {\n                    valueHasChanged = !shallowCompare(next, prev);\n                }\n                else {\n                    valueHasChanged = next !== prev;\n                }\n                if (valueHasChanged) {\n                    if (next !== undefined && next !== null) {\n                        // If next is defined and doesn't equal prev, it needs animating\n                        markToAnimate(key);\n                    }\n                    else {\n                        // If it's undefined, it's been removed.\n                        removedKeys.add(key);\n                    }\n                }\n                else if (next !== undefined && removedKeys.has(key)) {\n                    /**\n                     * If next hasn't changed and it isn't undefined, we want to check if it's\n                     * been removed by a higher priority\n                     */\n                    markToAnimate(key);\n                }\n                else {\n                    /**\n                     * If it hasn't changed, we add it to the list of protected values\n                     * to ensure it doesn't get animated.\n                     */\n                    typeState.protectedKeys[key] = true;\n                }\n            }\n            /**\n             * Update the typeState so next time animateChanges is called we can compare the\n             * latest prop and resolvedValues to these.\n             */\n            typeState.prevProp = prop;\n            typeState.prevResolvedValues = resolvedValues;\n            /**\n             *\n             */\n            if (typeState.isActive) {\n                encounteredKeys = { ...encounteredKeys, ...resolvedValues };\n            }\n            if (isInitialRender && visualElement.blockInitialAnimation) {\n                shouldAnimateType = false;\n            }\n            /**\n             * If this is an inherited prop we want to skip this animation\n             * unless the inherited variants haven't changed on this render.\n             */\n            const willAnimateViaParent = isInherited && variantDidChange;\n            const needsAnimating = !willAnimateViaParent || handledRemovedValues;\n            if (shouldAnimateType && needsAnimating) {\n                animations.push(...definitionList.map((animation) => ({\n                    animation: animation,\n                    options: { type },\n                })));\n            }\n        }\n        /**\n         * If there are some removed value that haven't been dealt with,\n         * we need to create a new animation that falls back either to the value\n         * defined in the style prop, or the last read value.\n         */\n        if (removedKeys.size) {\n            const fallbackAnimation = {};\n            removedKeys.forEach((key) => {\n                const fallbackTarget = visualElement.getBaseTarget(key);\n                const motionValue = visualElement.getValue(key);\n                if (motionValue)\n                    motionValue.liveStyle = true;\n                // @ts-expect-error - @mattgperry to figure if we should do something here\n                fallbackAnimation[key] = fallbackTarget !== null && fallbackTarget !== void 0 ? fallbackTarget : null;\n            });\n            animations.push({ animation: fallbackAnimation });\n        }\n        let shouldAnimate = Boolean(animations.length);\n        if (isInitialRender &&\n            (props.initial === false || props.initial === props.animate) &&\n            !visualElement.manuallyAnimateOnMount) {\n            shouldAnimate = false;\n        }\n        isInitialRender = false;\n        return shouldAnimate ? animate(animations) : Promise.resolve();\n    }\n    /**\n     * Change whether a certain animation type is active.\n     */\n    function setActive(type, isActive) {\n        var _a;\n        // If the active state hasn't changed, we can safely do nothing here\n        if (state[type].isActive === isActive)\n            return Promise.resolve();\n        // Propagate active change to children\n        (_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.forEach((child) => { var _a; return (_a = child.animationState) === null || _a === void 0 ? void 0 : _a.setActive(type, isActive); });\n        state[type].isActive = isActive;\n        const animations = animateChanges(type);\n        for (const key in state) {\n            state[key].protectedKeys = {};\n        }\n        return animations;\n    }\n    return {\n        animateChanges,\n        setActive,\n        setAnimateFunction,\n        getState: () => state,\n        reset: () => {\n            state = createState();\n            isInitialRender = true;\n        },\n    };\n}\nfunction checkVariantsDidChange(prev, next) {\n    if (typeof next === \"string\") {\n        return next !== prev;\n    }\n    else if (Array.isArray(next)) {\n        return !shallowCompare(next, prev);\n    }\n    return false;\n}\nfunction createTypeState(isActive = false) {\n    return {\n        isActive,\n        protectedKeys: {},\n        needsAnimating: {},\n        prevResolvedValues: {},\n    };\n}\nfunction createState() {\n    return {\n        animate: createTypeState(true),\n        whileInView: createTypeState(),\n        whileHover: createTypeState(),\n        whileTap: createTypeState(),\n        whileDrag: createTypeState(),\n        whileFocus: createTypeState(),\n        exit: createTypeState(),\n    };\n}\n\nexport { checkVariantsDidChange, createAnimationState };\n"],"mappings":"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","ignoreList":[]}}},"code":"!function (module1) {\n  let _objectSpread;\n  module1.link(\"@babel/runtime/helpers/objectSpread2\", {\n    default(v) {\n      _objectSpread = v;\n    }\n  }, 0);\n  let _objectWithoutProperties;\n  module1.link(\"@babel/runtime/helpers/objectWithoutProperties\", {\n    default(v) {\n      _objectWithoutProperties = v;\n    }\n  }, 1);\n  const _excluded = [\"transition\", \"transitionEnd\"];\n  module1.export({\n    checkVariantsDidChange: () => checkVariantsDidChange,\n    createAnimationState: () => createAnimationState\n  });\n  let isAnimationControls;\n  module1.link(\"../../animation/utils/is-animation-controls.mjs\", {\n    isAnimationControls(v) {\n      isAnimationControls = v;\n    }\n  }, 0);\n  let isKeyframesTarget;\n  module1.link(\"../../animation/utils/is-keyframes-target.mjs\", {\n    isKeyframesTarget(v) {\n      isKeyframesTarget = v;\n    }\n  }, 1);\n  let shallowCompare;\n  module1.link(\"../../utils/shallow-compare.mjs\", {\n    shallowCompare(v) {\n      shallowCompare = v;\n    }\n  }, 2);\n  let isVariantLabel;\n  module1.link(\"./is-variant-label.mjs\", {\n    isVariantLabel(v) {\n      isVariantLabel = v;\n    }\n  }, 3);\n  let resolveVariant;\n  module1.link(\"./resolve-dynamic-variants.mjs\", {\n    resolveVariant(v) {\n      resolveVariant = v;\n    }\n  }, 4);\n  let variantPriorityOrder;\n  module1.link(\"./variant-props.mjs\", {\n    variantPriorityOrder(v) {\n      variantPriorityOrder = v;\n    }\n  }, 5);\n  let animateVisualElement;\n  module1.link(\"../../animation/interfaces/visual-element.mjs\", {\n    animateVisualElement(v) {\n      animateVisualElement = v;\n    }\n  }, 6);\n  let getVariantContext;\n  module1.link(\"./get-variant-context.mjs\", {\n    getVariantContext(v) {\n      getVariantContext = v;\n    }\n  }, 7);\n  ___INIT_METEOR_FAST_REFRESH(module);\n  const reversePriorityOrder = [...variantPriorityOrder].reverse();\n  const numAnimationTypes = variantPriorityOrder.length;\n  function animateList(visualElement) {\n    return animations => Promise.all(animations.map(_ref => {\n      let {\n        animation,\n        options\n      } = _ref;\n      return animateVisualElement(visualElement, animation, options);\n    }));\n  }\n  function createAnimationState(visualElement) {\n    let animate = animateList(visualElement);\n    let state = createState();\n    let isInitialRender = true;\n    /**\n     * This function will be used to reduce the animation definitions for\n     * each active animation type into an object of resolved values for it.\n     */\n    const buildResolvedTypeValues = type => (acc, definition) => {\n      var _a;\n      const resolved = resolveVariant(visualElement, definition, type === \"exit\" ? (_a = visualElement.presenceContext) === null || _a === void 0 ? void 0 : _a.custom : undefined);\n      if (resolved) {\n        const {\n            transition,\n            transitionEnd\n          } = resolved,\n          target = _objectWithoutProperties(resolved, _excluded);\n        acc = _objectSpread(_objectSpread(_objectSpread({}, acc), target), transitionEnd);\n      }\n      return acc;\n    };\n    /**\n     * This just allows us to inject mocked animation functions\n     * @internal\n     */\n    function setAnimateFunction(makeAnimator) {\n      animate = makeAnimator(visualElement);\n    }\n    /**\n     * When we receive new props, we need to:\n     * 1. Create a list of protected keys for each type. This is a directory of\n     *    value keys that are currently being \"handled\" by types of a higher priority\n     *    so that whenever an animation is played of a given type, these values are\n     *    protected from being animated.\n     * 2. Determine if an animation type needs animating.\n     * 3. Determine if any values have been removed from a type and figure out\n     *    what to animate those to.\n     */\n    function animateChanges(changedActiveType) {\n      const {\n        props\n      } = visualElement;\n      const context = getVariantContext(visualElement.parent) || {};\n      /**\n       * A list of animations that we'll build into as we iterate through the animation\n       * types. This will get executed at the end of the function.\n       */\n      const animations = [];\n      /**\n       * Keep track of which values have been removed. Then, as we hit lower priority\n       * animation types, we can check if they contain removed values and animate to that.\n       */\n      const removedKeys = new Set();\n      /**\n       * A dictionary of all encountered keys. This is an object to let us build into and\n       * copy it without iteration. Each time we hit an animation type we set its protected\n       * keys - the keys its not allowed to animate - to the latest version of this object.\n       */\n      let encounteredKeys = {};\n      /**\n       * If a variant has been removed at a given index, and this component is controlling\n       * variant animations, we want to ensure lower-priority variants are forced to animate.\n       */\n      let removedVariantIndex = Infinity;\n      /**\n       * Iterate through all animation types in reverse priority order. For each, we want to\n       * detect which values it's handling and whether or not they've changed (and therefore\n       * need to be animated). If any values have been removed, we want to detect those in\n       * lower priority props and flag for animation.\n       */\n      for (let i = 0; i < numAnimationTypes; i++) {\n        const type = reversePriorityOrder[i];\n        const typeState = state[type];\n        const prop = props[type] !== undefined ? props[type] : context[type];\n        const propIsVariant = isVariantLabel(prop);\n        /**\n         * If this type has *just* changed isActive status, set activeDelta\n         * to that status. Otherwise set to null.\n         */\n        const activeDelta = type === changedActiveType ? typeState.isActive : null;\n        if (activeDelta === false) removedVariantIndex = i;\n        /**\n         * If this prop is an inherited variant, rather than been set directly on the\n         * component itself, we want to make sure we allow the parent to trigger animations.\n         *\n         * TODO: Can probably change this to a !isControllingVariants check\n         */\n        let isInherited = prop === context[type] && prop !== props[type] && propIsVariant;\n        /**\n         *\n         */\n        if (isInherited && isInitialRender && visualElement.manuallyAnimateOnMount) {\n          isInherited = false;\n        }\n        /**\n         * Set all encountered keys so far as the protected keys for this type. This will\n         * be any key that has been animated or otherwise handled by active, higher-priortiy types.\n         */\n        typeState.protectedKeys = _objectSpread({}, encounteredKeys);\n        // Check if we can skip analysing this prop early\n        if (\n        // If it isn't active and hasn't *just* been set as inactive\n        !typeState.isActive && activeDelta === null ||\n        // If we didn't and don't have any defined prop for this animation type\n        !prop && !typeState.prevProp ||\n        // Or if the prop doesn't define an animation\n        isAnimationControls(prop) || typeof prop === \"boolean\") {\n          continue;\n        }\n        /**\n         * As we go look through the values defined on this type, if we detect\n         * a changed value or a value that was removed in a higher priority, we set\n         * this to true and add this prop to the animation list.\n         */\n        const variantDidChange = checkVariantsDidChange(typeState.prevProp, prop);\n        let shouldAnimateType = variantDidChange ||\n        // If we're making this variant active, we want to always make it active\n        type === changedActiveType && typeState.isActive && !isInherited && propIsVariant ||\n        // If we removed a higher-priority variant (i is in reverse order)\n        i > removedVariantIndex && propIsVariant;\n        let handledRemovedValues = false;\n        /**\n         * As animations can be set as variant lists, variants or target objects, we\n         * coerce everything to an array if it isn't one already\n         */\n        const definitionList = Array.isArray(prop) ? prop : [prop];\n        /**\n         * Build an object of all the resolved values. We'll use this in the subsequent\n         * animateChanges calls to determine whether a value has changed.\n         */\n        let resolvedValues = definitionList.reduce(buildResolvedTypeValues(type), {});\n        if (activeDelta === false) resolvedValues = {};\n        /**\n         * Now we need to loop through all the keys in the prev prop and this prop,\n         * and decide:\n         * 1. If the value has changed, and needs animating\n         * 2. If it has been removed, and needs adding to the removedKeys set\n         * 3. If it has been removed in a higher priority type and needs animating\n         * 4. If it hasn't been removed in a higher priority but hasn't changed, and\n         *    needs adding to the type's protectedKeys list.\n         */\n        const {\n          prevResolvedValues = {}\n        } = typeState;\n        const allKeys = _objectSpread(_objectSpread({}, prevResolvedValues), resolvedValues);\n        const markToAnimate = key => {\n          shouldAnimateType = true;\n          if (removedKeys.has(key)) {\n            handledRemovedValues = true;\n            removedKeys.delete(key);\n          }\n          typeState.needsAnimating[key] = true;\n          const motionValue = visualElement.getValue(key);\n          if (motionValue) motionValue.liveStyle = false;\n        };\n        for (const key in allKeys) {\n          const next = resolvedValues[key];\n          const prev = prevResolvedValues[key];\n          // If we've already handled this we can just skip ahead\n          if (encounteredKeys.hasOwnProperty(key)) continue;\n          /**\n           * If the value has changed, we probably want to animate it.\n           */\n          let valueHasChanged = false;\n          if (isKeyframesTarget(next) && isKeyframesTarget(prev)) {\n            valueHasChanged = !shallowCompare(next, prev);\n          } else {\n            valueHasChanged = next !== prev;\n          }\n          if (valueHasChanged) {\n            if (next !== undefined && next !== null) {\n              // If next is defined and doesn't equal prev, it needs animating\n              markToAnimate(key);\n            } else {\n              // If it's undefined, it's been removed.\n              removedKeys.add(key);\n            }\n          } else if (next !== undefined && removedKeys.has(key)) {\n            /**\n             * If next hasn't changed and it isn't undefined, we want to check if it's\n             * been removed by a higher priority\n             */\n            markToAnimate(key);\n          } else {\n            /**\n             * If it hasn't changed, we add it to the list of protected values\n             * to ensure it doesn't get animated.\n             */\n            typeState.protectedKeys[key] = true;\n          }\n        }\n        /**\n         * Update the typeState so next time animateChanges is called we can compare the\n         * latest prop and resolvedValues to these.\n         */\n        typeState.prevProp = prop;\n        typeState.prevResolvedValues = resolvedValues;\n        /**\n         *\n         */\n        if (typeState.isActive) {\n          encounteredKeys = _objectSpread(_objectSpread({}, encounteredKeys), resolvedValues);\n        }\n        if (isInitialRender && visualElement.blockInitialAnimation) {\n          shouldAnimateType = false;\n        }\n        /**\n         * If this is an inherited prop we want to skip this animation\n         * unless the inherited variants haven't changed on this render.\n         */\n        const willAnimateViaParent = isInherited && variantDidChange;\n        const needsAnimating = !willAnimateViaParent || handledRemovedValues;\n        if (shouldAnimateType && needsAnimating) {\n          animations.push(...definitionList.map(animation => ({\n            animation: animation,\n            options: {\n              type\n            }\n          })));\n        }\n      }\n      /**\n       * If there are some removed value that haven't been dealt with,\n       * we need to create a new animation that falls back either to the value\n       * defined in the style prop, or the last read value.\n       */\n      if (removedKeys.size) {\n        const fallbackAnimation = {};\n        removedKeys.forEach(key => {\n          const fallbackTarget = visualElement.getBaseTarget(key);\n          const motionValue = visualElement.getValue(key);\n          if (motionValue) motionValue.liveStyle = true;\n          // @ts-expect-error - @mattgperry to figure if we should do something here\n          fallbackAnimation[key] = fallbackTarget !== null && fallbackTarget !== void 0 ? fallbackTarget : null;\n        });\n        animations.push({\n          animation: fallbackAnimation\n        });\n      }\n      let shouldAnimate = Boolean(animations.length);\n      if (isInitialRender && (props.initial === false || props.initial === props.animate) && !visualElement.manuallyAnimateOnMount) {\n        shouldAnimate = false;\n      }\n      isInitialRender = false;\n      return shouldAnimate ? animate(animations) : Promise.resolve();\n    }\n    /**\n     * Change whether a certain animation type is active.\n     */\n    function setActive(type, isActive) {\n      var _a;\n      // If the active state hasn't changed, we can safely do nothing here\n      if (state[type].isActive === isActive) return Promise.resolve();\n      // Propagate active change to children\n      (_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.forEach(child => {\n        var _a;\n        return (_a = child.animationState) === null || _a === void 0 ? void 0 : _a.setActive(type, isActive);\n      });\n      state[type].isActive = isActive;\n      const animations = animateChanges(type);\n      for (const key in state) {\n        state[key].protectedKeys = {};\n      }\n      return animations;\n    }\n    return {\n      animateChanges,\n      setActive,\n      setAnimateFunction,\n      getState: () => state,\n      reset: () => {\n        state = createState();\n        isInitialRender = true;\n      }\n    };\n  }\n  function checkVariantsDidChange(prev, next) {\n    if (typeof next === \"string\") {\n      return next !== prev;\n    } else if (Array.isArray(next)) {\n      return !shallowCompare(next, prev);\n    }\n    return false;\n  }\n  function createTypeState() {\n    let isActive = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    return {\n      isActive,\n      protectedKeys: {},\n      needsAnimating: {},\n      prevResolvedValues: {}\n    };\n  }\n  function createState() {\n    return {\n      animate: createTypeState(true),\n      whileInView: createTypeState(),\n      whileHover: createTypeState(),\n      whileTap: createTypeState(),\n      whileDrag: createTypeState(),\n      whileFocus: createTypeState(),\n      exit: createTypeState()\n    };\n  }\n}.call(this, module);","map":{"version":3,"names":["reversePriorityOrder","variantPriorityOrder","reverse","numAnimationTypes","length","animateList","visualElement","animations","Promise","all","map","_ref","animation","options","animateVisualElement","createAnimationState","animate","state","createState","isInitialRender","buildResolvedTypeValues","type","acc","definition","_a","resolved","resolveVariant","presenceContext","custom","undefined","transition","transitionEnd","target","_objectWithoutProperties","_excluded","_objectSpread","setAnimateFunction","makeAnimator","animateChanges","changedActiveType","props","context","getVariantContext","parent","removedKeys","Set","encounteredKeys","removedVariantIndex","Infinity","i","typeState","prop","propIsVariant","isVariantLabel","activeDelta","isActive","isInherited","manuallyAnimateOnMount","protectedKeys","prevProp","isAnimationControls","variantDidChange","checkVariantsDidChange","shouldAnimateType","handledRemovedValues","definitionList","Array","isArray","resolvedValues","reduce","prevResolvedValues","allKeys","markToAnimate","key","has","delete","needsAnimating","motionValue","getValue","liveStyle","next","prev","hasOwnProperty","valueHasChanged","isKeyframesTarget","shallowCompare","add","blockInitialAnimation","willAnimateViaParent","push","size","fallbackAnimation","forEach","fallbackTarget","getBaseTarget","shouldAnimate","Boolean","initial","resolve","setActive","variantChildren","child","animationState","getState","reset","createTypeState","arguments","whileInView","whileHover","whileTap","whileDrag","whileFocus","exit","call","module"],"sources":["node_modules/framer-motion/dist/es/render/utils/animation-state.mjs"],"sourcesContent":["import { isAnimationControls } from '../../animation/utils/is-animation-controls.mjs';\nimport { isKeyframesTarget } from '../../animation/utils/is-keyframes-target.mjs';\nimport { shallowCompare } from '../../utils/shallow-compare.mjs';\nimport { isVariantLabel } from './is-variant-label.mjs';\nimport { resolveVariant } from './resolve-dynamic-variants.mjs';\nimport { variantPriorityOrder } from './variant-props.mjs';\nimport { animateVisualElement } from '../../animation/interfaces/visual-element.mjs';\nimport { getVariantContext } from './get-variant-context.mjs';\n\nconst reversePriorityOrder = [...variantPriorityOrder].reverse();\nconst numAnimationTypes = variantPriorityOrder.length;\nfunction animateList(visualElement) {\n    return (animations) => Promise.all(animations.map(({ animation, options }) => animateVisualElement(visualElement, animation, options)));\n}\nfunction createAnimationState(visualElement) {\n    let animate = animateList(visualElement);\n    let state = createState();\n    let isInitialRender = true;\n    /**\n     * This function will be used to reduce the animation definitions for\n     * each active animation type into an object of resolved values for it.\n     */\n    const buildResolvedTypeValues = (type) => (acc, definition) => {\n        var _a;\n        const resolved = resolveVariant(visualElement, definition, type === \"exit\"\n            ? (_a = visualElement.presenceContext) === null || _a === void 0 ? void 0 : _a.custom\n            : undefined);\n        if (resolved) {\n            const { transition, transitionEnd, ...target } = resolved;\n            acc = { ...acc, ...target, ...transitionEnd };\n        }\n        return acc;\n    };\n    /**\n     * This just allows us to inject mocked animation functions\n     * @internal\n     */\n    function setAnimateFunction(makeAnimator) {\n        animate = makeAnimator(visualElement);\n    }\n    /**\n     * When we receive new props, we need to:\n     * 1. Create a list of protected keys for each type. This is a directory of\n     *    value keys that are currently being \"handled\" by types of a higher priority\n     *    so that whenever an animation is played of a given type, these values are\n     *    protected from being animated.\n     * 2. Determine if an animation type needs animating.\n     * 3. Determine if any values have been removed from a type and figure out\n     *    what to animate those to.\n     */\n    function animateChanges(changedActiveType) {\n        const { props } = visualElement;\n        const context = getVariantContext(visualElement.parent) || {};\n        /**\n         * A list of animations that we'll build into as we iterate through the animation\n         * types. This will get executed at the end of the function.\n         */\n        const animations = [];\n        /**\n         * Keep track of which values have been removed. Then, as we hit lower priority\n         * animation types, we can check if they contain removed values and animate to that.\n         */\n        const removedKeys = new Set();\n        /**\n         * A dictionary of all encountered keys. This is an object to let us build into and\n         * copy it without iteration. Each time we hit an animation type we set its protected\n         * keys - the keys its not allowed to animate - to the latest version of this object.\n         */\n        let encounteredKeys = {};\n        /**\n         * If a variant has been removed at a given index, and this component is controlling\n         * variant animations, we want to ensure lower-priority variants are forced to animate.\n         */\n        let removedVariantIndex = Infinity;\n        /**\n         * Iterate through all animation types in reverse priority order. For each, we want to\n         * detect which values it's handling and whether or not they've changed (and therefore\n         * need to be animated). If any values have been removed, we want to detect those in\n         * lower priority props and flag for animation.\n         */\n        for (let i = 0; i < numAnimationTypes; i++) {\n            const type = reversePriorityOrder[i];\n            const typeState = state[type];\n            const prop = props[type] !== undefined\n                ? props[type]\n                : context[type];\n            const propIsVariant = isVariantLabel(prop);\n            /**\n             * If this type has *just* changed isActive status, set activeDelta\n             * to that status. Otherwise set to null.\n             */\n            const activeDelta = type === changedActiveType ? typeState.isActive : null;\n            if (activeDelta === false)\n                removedVariantIndex = i;\n            /**\n             * If this prop is an inherited variant, rather than been set directly on the\n             * component itself, we want to make sure we allow the parent to trigger animations.\n             *\n             * TODO: Can probably change this to a !isControllingVariants check\n             */\n            let isInherited = prop === context[type] &&\n                prop !== props[type] &&\n                propIsVariant;\n            /**\n             *\n             */\n            if (isInherited &&\n                isInitialRender &&\n                visualElement.manuallyAnimateOnMount) {\n                isInherited = false;\n            }\n            /**\n             * Set all encountered keys so far as the protected keys for this type. This will\n             * be any key that has been animated or otherwise handled by active, higher-priortiy types.\n             */\n            typeState.protectedKeys = { ...encounteredKeys };\n            // Check if we can skip analysing this prop early\n            if (\n            // If it isn't active and hasn't *just* been set as inactive\n            (!typeState.isActive && activeDelta === null) ||\n                // If we didn't and don't have any defined prop for this animation type\n                (!prop && !typeState.prevProp) ||\n                // Or if the prop doesn't define an animation\n                isAnimationControls(prop) ||\n                typeof prop === \"boolean\") {\n                continue;\n            }\n            /**\n             * As we go look through the values defined on this type, if we detect\n             * a changed value or a value that was removed in a higher priority, we set\n             * this to true and add this prop to the animation list.\n             */\n            const variantDidChange = checkVariantsDidChange(typeState.prevProp, prop);\n            let shouldAnimateType = variantDidChange ||\n                // If we're making this variant active, we want to always make it active\n                (type === changedActiveType &&\n                    typeState.isActive &&\n                    !isInherited &&\n                    propIsVariant) ||\n                // If we removed a higher-priority variant (i is in reverse order)\n                (i > removedVariantIndex && propIsVariant);\n            let handledRemovedValues = false;\n            /**\n             * As animations can be set as variant lists, variants or target objects, we\n             * coerce everything to an array if it isn't one already\n             */\n            const definitionList = Array.isArray(prop) ? prop : [prop];\n            /**\n             * Build an object of all the resolved values. We'll use this in the subsequent\n             * animateChanges calls to determine whether a value has changed.\n             */\n            let resolvedValues = definitionList.reduce(buildResolvedTypeValues(type), {});\n            if (activeDelta === false)\n                resolvedValues = {};\n            /**\n             * Now we need to loop through all the keys in the prev prop and this prop,\n             * and decide:\n             * 1. If the value has changed, and needs animating\n             * 2. If it has been removed, and needs adding to the removedKeys set\n             * 3. If it has been removed in a higher priority type and needs animating\n             * 4. If it hasn't been removed in a higher priority but hasn't changed, and\n             *    needs adding to the type's protectedKeys list.\n             */\n            const { prevResolvedValues = {} } = typeState;\n            const allKeys = {\n                ...prevResolvedValues,\n                ...resolvedValues,\n            };\n            const markToAnimate = (key) => {\n                shouldAnimateType = true;\n                if (removedKeys.has(key)) {\n                    handledRemovedValues = true;\n                    removedKeys.delete(key);\n                }\n                typeState.needsAnimating[key] = true;\n                const motionValue = visualElement.getValue(key);\n                if (motionValue)\n                    motionValue.liveStyle = false;\n            };\n            for (const key in allKeys) {\n                const next = resolvedValues[key];\n                const prev = prevResolvedValues[key];\n                // If we've already handled this we can just skip ahead\n                if (encounteredKeys.hasOwnProperty(key))\n                    continue;\n                /**\n                 * If the value has changed, we probably want to animate it.\n                 */\n                let valueHasChanged = false;\n                if (isKeyframesTarget(next) && isKeyframesTarget(prev)) {\n                    valueHasChanged = !shallowCompare(next, prev);\n                }\n                else {\n                    valueHasChanged = next !== prev;\n                }\n                if (valueHasChanged) {\n                    if (next !== undefined && next !== null) {\n                        // If next is defined and doesn't equal prev, it needs animating\n                        markToAnimate(key);\n                    }\n                    else {\n                        // If it's undefined, it's been removed.\n                        removedKeys.add(key);\n                    }\n                }\n                else if (next !== undefined && removedKeys.has(key)) {\n                    /**\n                     * If next hasn't changed and it isn't undefined, we want to check if it's\n                     * been removed by a higher priority\n                     */\n                    markToAnimate(key);\n                }\n                else {\n                    /**\n                     * If it hasn't changed, we add it to the list of protected values\n                     * to ensure it doesn't get animated.\n                     */\n                    typeState.protectedKeys[key] = true;\n                }\n            }\n            /**\n             * Update the typeState so next time animateChanges is called we can compare the\n             * latest prop and resolvedValues to these.\n             */\n            typeState.prevProp = prop;\n            typeState.prevResolvedValues = resolvedValues;\n            /**\n             *\n             */\n            if (typeState.isActive) {\n                encounteredKeys = { ...encounteredKeys, ...resolvedValues };\n            }\n            if (isInitialRender && visualElement.blockInitialAnimation) {\n                shouldAnimateType = false;\n            }\n            /**\n             * If this is an inherited prop we want to skip this animation\n             * unless the inherited variants haven't changed on this render.\n             */\n            const willAnimateViaParent = isInherited && variantDidChange;\n            const needsAnimating = !willAnimateViaParent || handledRemovedValues;\n            if (shouldAnimateType && needsAnimating) {\n                animations.push(...definitionList.map((animation) => ({\n                    animation: animation,\n                    options: { type },\n                })));\n            }\n        }\n        /**\n         * If there are some removed value that haven't been dealt with,\n         * we need to create a new animation that falls back either to the value\n         * defined in the style prop, or the last read value.\n         */\n        if (removedKeys.size) {\n            const fallbackAnimation = {};\n            removedKeys.forEach((key) => {\n                const fallbackTarget = visualElement.getBaseTarget(key);\n                const motionValue = visualElement.getValue(key);\n                if (motionValue)\n                    motionValue.liveStyle = true;\n                // @ts-expect-error - @mattgperry to figure if we should do something here\n                fallbackAnimation[key] = fallbackTarget !== null && fallbackTarget !== void 0 ? fallbackTarget : null;\n            });\n            animations.push({ animation: fallbackAnimation });\n        }\n        let shouldAnimate = Boolean(animations.length);\n        if (isInitialRender &&\n            (props.initial === false || props.initial === props.animate) &&\n            !visualElement.manuallyAnimateOnMount) {\n            shouldAnimate = false;\n        }\n        isInitialRender = false;\n        return shouldAnimate ? animate(animations) : Promise.resolve();\n    }\n    /**\n     * Change whether a certain animation type is active.\n     */\n    function setActive(type, isActive) {\n        var _a;\n        // If the active state hasn't changed, we can safely do nothing here\n        if (state[type].isActive === isActive)\n            return Promise.resolve();\n        // Propagate active change to children\n        (_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.forEach((child) => { var _a; return (_a = child.animationState) === null || _a === void 0 ? void 0 : _a.setActive(type, isActive); });\n        state[type].isActive = isActive;\n        const animations = animateChanges(type);\n        for (const key in state) {\n            state[key].protectedKeys = {};\n        }\n        return animations;\n    }\n    return {\n        animateChanges,\n        setActive,\n        setAnimateFunction,\n        getState: () => state,\n        reset: () => {\n            state = createState();\n            isInitialRender = true;\n        },\n    };\n}\nfunction checkVariantsDidChange(prev, next) {\n    if (typeof next === \"string\") {\n        return next !== prev;\n    }\n    else if (Array.isArray(next)) {\n        return !shallowCompare(next, prev);\n    }\n    return false;\n}\nfunction createTypeState(isActive = false) {\n    return {\n        isActive,\n        protectedKeys: {},\n        needsAnimating: {},\n        prevResolvedValues: {},\n    };\n}\nfunction createState() {\n    return {\n        animate: createTypeState(true),\n        whileInView: createTypeState(),\n        whileHover: createTypeState(),\n        whileTap: createTypeState(),\n        whileDrag: createTypeState(),\n        whileFocus: createTypeState(),\n        exit: createTypeState(),\n    };\n}\n\nexport { checkVariantsDidChange, createAnimationState };\n"],"mappings":"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","ignoreList":[]},"sourceType":"module","externalDependencies":{},"hash":"e8c49a374e7570f1f5c3a1813c75836fb1cee7f9"}
