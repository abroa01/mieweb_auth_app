{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/anshul/Masters/Internship/POC/Meteor_Mobile/mieweb_push_auth/node_modules/framer-motion/dist/es/motion/features/viewport/index.mjs","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","topLevelAwait","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"web.browser"},"sourceFileName":"node_modules/framer-motion/dist/es/motion/features/viewport/index.mjs","filename":"/Users/anshul/Masters/Internship/POC/Meteor_Mobile/mieweb_push_auth/node_modules/framer-motion/dist/es/motion/features/viewport/index.mjs","inputSourceMap":{"version":3,"names":["Feature","observeIntersection","thresholdNames","some","all","InViewFeature","constructor","arguments","hasEnteredView","isInView","startObserver","unmount","viewport","node","getProps","root","margin","rootMargin","amount","once","options","current","undefined","threshold","onIntersectionUpdate","entry","isIntersecting","animationState","setActive","onViewportEnter","onViewportLeave","callback","mount","update","IntersectionObserver","props","prevProps","hasOptionsChanged","hasViewportOptionChanged","prevViewport","name"],"sources":["node_modules/framer-motion/dist/es/motion/features/viewport/index.mjs"],"sourcesContent":["import { Feature } from '../Feature.mjs';\nimport { observeIntersection } from './observers.mjs';\n\nconst thresholdNames = {\n    some: 0,\n    all: 1,\n};\nclass InViewFeature extends Feature {\n    constructor() {\n        super(...arguments);\n        this.hasEnteredView = false;\n        this.isInView = false;\n    }\n    startObserver() {\n        this.unmount();\n        const { viewport = {} } = this.node.getProps();\n        const { root, margin: rootMargin, amount = \"some\", once } = viewport;\n        const options = {\n            root: root ? root.current : undefined,\n            rootMargin,\n            threshold: typeof amount === \"number\" ? amount : thresholdNames[amount],\n        };\n        const onIntersectionUpdate = (entry) => {\n            const { isIntersecting } = entry;\n            /**\n             * If there's been no change in the viewport state, early return.\n             */\n            if (this.isInView === isIntersecting)\n                return;\n            this.isInView = isIntersecting;\n            /**\n             * Handle hasEnteredView. If this is only meant to run once, and\n             * element isn't visible, early return. Otherwise set hasEnteredView to true.\n             */\n            if (once && !isIntersecting && this.hasEnteredView) {\n                return;\n            }\n            else if (isIntersecting) {\n                this.hasEnteredView = true;\n            }\n            if (this.node.animationState) {\n                this.node.animationState.setActive(\"whileInView\", isIntersecting);\n            }\n            /**\n             * Use the latest committed props rather than the ones in scope\n             * when this observer is created\n             */\n            const { onViewportEnter, onViewportLeave } = this.node.getProps();\n            const callback = isIntersecting ? onViewportEnter : onViewportLeave;\n            callback && callback(entry);\n        };\n        return observeIntersection(this.node.current, options, onIntersectionUpdate);\n    }\n    mount() {\n        this.startObserver();\n    }\n    update() {\n        if (typeof IntersectionObserver === \"undefined\")\n            return;\n        const { props, prevProps } = this.node;\n        const hasOptionsChanged = [\"amount\", \"margin\", \"root\"].some(hasViewportOptionChanged(props, prevProps));\n        if (hasOptionsChanged) {\n            this.startObserver();\n        }\n    }\n    unmount() { }\n}\nfunction hasViewportOptionChanged({ viewport = {} }, { viewport: prevViewport = {} } = {}) {\n    return (name) => viewport[name] !== prevViewport[name];\n}\n\nexport { InViewFeature };\n"],"mappings":"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","ignoreList":[]},"targets":{},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/Users/anshul/Masters/Internship/POC/Meteor_Mobile/mieweb_push_auth","root":"/Users/anshul/Masters/Internship/POC/Meteor_Mobile/mieweb_push_auth","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true},"externalDependencies":[]},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.17.2","helpers":true,"useESModules":false,"corejs":false},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-react-jsx","visitor":{"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXFragment":{"exit":[null]},"JSXElement":{"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false},"externalDependencies":[]},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-nullish-coalescing-operator","visitor":{"LogicalExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-chaining","visitor":{"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-catch-binding","visitor":{"CatchClause":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"proposal-logical-assignment-operators","visitor":{"AssignmentExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]}],"presets":[],"generatorOpts":{"filename":"/Users/anshul/Masters/Internship/POC/Meteor_Mobile/mieweb_push_auth/node_modules/framer-motion/dist/es/motion/features/viewport/index.mjs","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"node_modules/framer-motion/dist/es/motion/features/viewport/index.mjs","inputSourceMap":{"version":3,"names":["Feature","observeIntersection","thresholdNames","some","all","InViewFeature","constructor","arguments","hasEnteredView","isInView","startObserver","unmount","viewport","node","getProps","root","margin","rootMargin","amount","once","options","current","undefined","threshold","onIntersectionUpdate","entry","isIntersecting","animationState","setActive","onViewportEnter","onViewportLeave","callback","mount","update","IntersectionObserver","props","prevProps","hasOptionsChanged","hasViewportOptionChanged","prevViewport","name"],"sources":["node_modules/framer-motion/dist/es/motion/features/viewport/index.mjs"],"sourcesContent":["import { Feature } from '../Feature.mjs';\nimport { observeIntersection } from './observers.mjs';\n\nconst thresholdNames = {\n    some: 0,\n    all: 1,\n};\nclass InViewFeature extends Feature {\n    constructor() {\n        super(...arguments);\n        this.hasEnteredView = false;\n        this.isInView = false;\n    }\n    startObserver() {\n        this.unmount();\n        const { viewport = {} } = this.node.getProps();\n        const { root, margin: rootMargin, amount = \"some\", once } = viewport;\n        const options = {\n            root: root ? root.current : undefined,\n            rootMargin,\n            threshold: typeof amount === \"number\" ? amount : thresholdNames[amount],\n        };\n        const onIntersectionUpdate = (entry) => {\n            const { isIntersecting } = entry;\n            /**\n             * If there's been no change in the viewport state, early return.\n             */\n            if (this.isInView === isIntersecting)\n                return;\n            this.isInView = isIntersecting;\n            /**\n             * Handle hasEnteredView. If this is only meant to run once, and\n             * element isn't visible, early return. Otherwise set hasEnteredView to true.\n             */\n            if (once && !isIntersecting && this.hasEnteredView) {\n                return;\n            }\n            else if (isIntersecting) {\n                this.hasEnteredView = true;\n            }\n            if (this.node.animationState) {\n                this.node.animationState.setActive(\"whileInView\", isIntersecting);\n            }\n            /**\n             * Use the latest committed props rather than the ones in scope\n             * when this observer is created\n             */\n            const { onViewportEnter, onViewportLeave } = this.node.getProps();\n            const callback = isIntersecting ? onViewportEnter : onViewportLeave;\n            callback && callback(entry);\n        };\n        return observeIntersection(this.node.current, options, onIntersectionUpdate);\n    }\n    mount() {\n        this.startObserver();\n    }\n    update() {\n        if (typeof IntersectionObserver === \"undefined\")\n            return;\n        const { props, prevProps } = this.node;\n        const hasOptionsChanged = [\"amount\", \"margin\", \"root\"].some(hasViewportOptionChanged(props, prevProps));\n        if (hasOptionsChanged) {\n            this.startObserver();\n        }\n    }\n    unmount() { }\n}\nfunction hasViewportOptionChanged({ viewport = {} }, { viewport: prevViewport = {} } = {}) {\n    return (name) => viewport[name] !== prevViewport[name];\n}\n\nexport { InViewFeature };\n"],"mappings":"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","ignoreList":[]}}},"code":"!function (module1) {\n  module1.export({\n    InViewFeature: () => InViewFeature\n  });\n  let Feature;\n  module1.link(\"../Feature.mjs\", {\n    Feature(v) {\n      Feature = v;\n    }\n  }, 0);\n  let observeIntersection;\n  module1.link(\"./observers.mjs\", {\n    observeIntersection(v) {\n      observeIntersection = v;\n    }\n  }, 1);\n  ___INIT_METEOR_FAST_REFRESH(module);\n  const thresholdNames = {\n    some: 0,\n    all: 1\n  };\n  class InViewFeature extends Feature {\n    constructor() {\n      super(...arguments);\n      this.hasEnteredView = false;\n      this.isInView = false;\n    }\n    startObserver() {\n      this.unmount();\n      const {\n        viewport = {}\n      } = this.node.getProps();\n      const {\n        root,\n        margin: rootMargin,\n        amount = \"some\",\n        once\n      } = viewport;\n      const options = {\n        root: root ? root.current : undefined,\n        rootMargin,\n        threshold: typeof amount === \"number\" ? amount : thresholdNames[amount]\n      };\n      const onIntersectionUpdate = entry => {\n        const {\n          isIntersecting\n        } = entry;\n        /**\n         * If there's been no change in the viewport state, early return.\n         */\n        if (this.isInView === isIntersecting) return;\n        this.isInView = isIntersecting;\n        /**\n         * Handle hasEnteredView. If this is only meant to run once, and\n         * element isn't visible, early return. Otherwise set hasEnteredView to true.\n         */\n        if (once && !isIntersecting && this.hasEnteredView) {\n          return;\n        } else if (isIntersecting) {\n          this.hasEnteredView = true;\n        }\n        if (this.node.animationState) {\n          this.node.animationState.setActive(\"whileInView\", isIntersecting);\n        }\n        /**\n         * Use the latest committed props rather than the ones in scope\n         * when this observer is created\n         */\n        const {\n          onViewportEnter,\n          onViewportLeave\n        } = this.node.getProps();\n        const callback = isIntersecting ? onViewportEnter : onViewportLeave;\n        callback && callback(entry);\n      };\n      return observeIntersection(this.node.current, options, onIntersectionUpdate);\n    }\n    mount() {\n      this.startObserver();\n    }\n    update() {\n      if (typeof IntersectionObserver === \"undefined\") return;\n      const {\n        props,\n        prevProps\n      } = this.node;\n      const hasOptionsChanged = [\"amount\", \"margin\", \"root\"].some(hasViewportOptionChanged(props, prevProps));\n      if (hasOptionsChanged) {\n        this.startObserver();\n      }\n    }\n    unmount() {}\n  }\n  function hasViewportOptionChanged(_ref) {\n    let {\n      viewport = {}\n    } = _ref;\n    let {\n      viewport: prevViewport = {}\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return name => viewport[name] !== prevViewport[name];\n  }\n}.call(this, module);","map":{"version":3,"names":["thresholdNames","some","all","InViewFeature","Feature","constructor","arguments","hasEnteredView","isInView","startObserver","unmount","viewport","node","getProps","root","margin","rootMargin","amount","once","options","current","undefined","threshold","onIntersectionUpdate","entry","isIntersecting","animationState","setActive","onViewportEnter","onViewportLeave","callback","observeIntersection","mount","update","IntersectionObserver","props","prevProps","hasOptionsChanged","hasViewportOptionChanged","_ref","prevViewport","length","name","call","module"],"sources":["node_modules/framer-motion/dist/es/motion/features/viewport/index.mjs"],"sourcesContent":["import { Feature } from '../Feature.mjs';\nimport { observeIntersection } from './observers.mjs';\n\nconst thresholdNames = {\n    some: 0,\n    all: 1,\n};\nclass InViewFeature extends Feature {\n    constructor() {\n        super(...arguments);\n        this.hasEnteredView = false;\n        this.isInView = false;\n    }\n    startObserver() {\n        this.unmount();\n        const { viewport = {} } = this.node.getProps();\n        const { root, margin: rootMargin, amount = \"some\", once } = viewport;\n        const options = {\n            root: root ? root.current : undefined,\n            rootMargin,\n            threshold: typeof amount === \"number\" ? amount : thresholdNames[amount],\n        };\n        const onIntersectionUpdate = (entry) => {\n            const { isIntersecting } = entry;\n            /**\n             * If there's been no change in the viewport state, early return.\n             */\n            if (this.isInView === isIntersecting)\n                return;\n            this.isInView = isIntersecting;\n            /**\n             * Handle hasEnteredView. If this is only meant to run once, and\n             * element isn't visible, early return. Otherwise set hasEnteredView to true.\n             */\n            if (once && !isIntersecting && this.hasEnteredView) {\n                return;\n            }\n            else if (isIntersecting) {\n                this.hasEnteredView = true;\n            }\n            if (this.node.animationState) {\n                this.node.animationState.setActive(\"whileInView\", isIntersecting);\n            }\n            /**\n             * Use the latest committed props rather than the ones in scope\n             * when this observer is created\n             */\n            const { onViewportEnter, onViewportLeave } = this.node.getProps();\n            const callback = isIntersecting ? onViewportEnter : onViewportLeave;\n            callback && callback(entry);\n        };\n        return observeIntersection(this.node.current, options, onIntersectionUpdate);\n    }\n    mount() {\n        this.startObserver();\n    }\n    update() {\n        if (typeof IntersectionObserver === \"undefined\")\n            return;\n        const { props, prevProps } = this.node;\n        const hasOptionsChanged = [\"amount\", \"margin\", \"root\"].some(hasViewportOptionChanged(props, prevProps));\n        if (hasOptionsChanged) {\n            this.startObserver();\n        }\n    }\n    unmount() { }\n}\nfunction hasViewportOptionChanged({ viewport = {} }, { viewport: prevViewport = {} } = {}) {\n    return (name) => viewport[name] !== prevViewport[name];\n}\n\nexport { InViewFeature };\n"],"mappings":"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","ignoreList":[]},"sourceType":"module","externalDependencies":{},"hash":"a1b450140d23af41d578114cc613687408950007"}
