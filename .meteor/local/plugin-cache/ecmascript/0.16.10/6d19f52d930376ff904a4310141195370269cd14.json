{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/anshul/Masters/Internship/POC/Meteor_Mobile/mieweb_push_auth/node_modules/framer-motion/dist/es/projection/geometry/delta-apply.mjs","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","topLevelAwait","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"web.browser"},"sourceFileName":"node_modules/framer-motion/dist/es/projection/geometry/delta-apply.mjs","filename":"/Users/anshul/Masters/Internship/POC/Meteor_Mobile/mieweb_push_auth/node_modules/framer-motion/dist/es/projection/geometry/delta-apply.mjs","inputSourceMap":{"version":3,"names":["mixNumber","hasTransform","scalePoint","point","scale","originPoint","distanceFromOrigin","scaled","applyPointDelta","translate","boxScale","undefined","applyAxisDelta","axis","min","max","applyBoxDelta","box","x","y","TREE_SCALE_SNAP_MIN","TREE_SCALE_SNAP_MAX","applyTreeDeltas","treeScale","treePath","isSharedTransition","treeLength","length","node","delta","i","projectionDelta","visualElement","options","props","style","display","layoutScroll","scroll","root","transformBox","offset","latestValues","translateAxis","distance","transformAxis","axisTranslate","axisScale","axisOrigin","transform","scaleX","originX","scaleY","originY"],"sources":["node_modules/framer-motion/dist/es/projection/geometry/delta-apply.mjs"],"sourcesContent":["import { mixNumber } from '../../utils/mix/number.mjs';\nimport { hasTransform } from '../utils/has-transform.mjs';\n\n/**\n * Scales a point based on a factor and an originPoint\n */\nfunction scalePoint(point, scale, originPoint) {\n    const distanceFromOrigin = point - originPoint;\n    const scaled = scale * distanceFromOrigin;\n    return originPoint + scaled;\n}\n/**\n * Applies a translate/scale delta to a point\n */\nfunction applyPointDelta(point, translate, scale, originPoint, boxScale) {\n    if (boxScale !== undefined) {\n        point = scalePoint(point, boxScale, originPoint);\n    }\n    return scalePoint(point, scale, originPoint) + translate;\n}\n/**\n * Applies a translate/scale delta to an axis\n */\nfunction applyAxisDelta(axis, translate = 0, scale = 1, originPoint, boxScale) {\n    axis.min = applyPointDelta(axis.min, translate, scale, originPoint, boxScale);\n    axis.max = applyPointDelta(axis.max, translate, scale, originPoint, boxScale);\n}\n/**\n * Applies a translate/scale delta to a box\n */\nfunction applyBoxDelta(box, { x, y }) {\n    applyAxisDelta(box.x, x.translate, x.scale, x.originPoint);\n    applyAxisDelta(box.y, y.translate, y.scale, y.originPoint);\n}\nconst TREE_SCALE_SNAP_MIN = 0.999999999999;\nconst TREE_SCALE_SNAP_MAX = 1.0000000000001;\n/**\n * Apply a tree of deltas to a box. We do this to calculate the effect of all the transforms\n * in a tree upon our box before then calculating how to project it into our desired viewport-relative box\n *\n * This is the final nested loop within updateLayoutDelta for future refactoring\n */\nfunction applyTreeDeltas(box, treeScale, treePath, isSharedTransition = false) {\n    const treeLength = treePath.length;\n    if (!treeLength)\n        return;\n    // Reset the treeScale\n    treeScale.x = treeScale.y = 1;\n    let node;\n    let delta;\n    for (let i = 0; i < treeLength; i++) {\n        node = treePath[i];\n        delta = node.projectionDelta;\n        /**\n         * TODO: Prefer to remove this, but currently we have motion components with\n         * display: contents in Framer.\n         */\n        const { visualElement } = node.options;\n        if (visualElement &&\n            visualElement.props.style &&\n            visualElement.props.style.display === \"contents\") {\n            continue;\n        }\n        if (isSharedTransition &&\n            node.options.layoutScroll &&\n            node.scroll &&\n            node !== node.root) {\n            transformBox(box, {\n                x: -node.scroll.offset.x,\n                y: -node.scroll.offset.y,\n            });\n        }\n        if (delta) {\n            // Incoporate each ancestor's scale into a culmulative treeScale for this component\n            treeScale.x *= delta.x.scale;\n            treeScale.y *= delta.y.scale;\n            // Apply each ancestor's calculated delta into this component's recorded layout box\n            applyBoxDelta(box, delta);\n        }\n        if (isSharedTransition && hasTransform(node.latestValues)) {\n            transformBox(box, node.latestValues);\n        }\n    }\n    /**\n     * Snap tree scale back to 1 if it's within a non-perceivable threshold.\n     * This will help reduce useless scales getting rendered.\n     */\n    if (treeScale.x < TREE_SCALE_SNAP_MAX &&\n        treeScale.x > TREE_SCALE_SNAP_MIN) {\n        treeScale.x = 1.0;\n    }\n    if (treeScale.y < TREE_SCALE_SNAP_MAX &&\n        treeScale.y > TREE_SCALE_SNAP_MIN) {\n        treeScale.y = 1.0;\n    }\n}\nfunction translateAxis(axis, distance) {\n    axis.min = axis.min + distance;\n    axis.max = axis.max + distance;\n}\n/**\n * Apply a transform to an axis from the latest resolved motion values.\n * This function basically acts as a bridge between a flat motion value map\n * and applyAxisDelta\n */\nfunction transformAxis(axis, axisTranslate, axisScale, boxScale, axisOrigin = 0.5) {\n    const originPoint = mixNumber(axis.min, axis.max, axisOrigin);\n    // Apply the axis delta to the final axis\n    applyAxisDelta(axis, axisTranslate, axisScale, originPoint, boxScale);\n}\n/**\n * Apply a transform to a box from the latest resolved motion values.\n */\nfunction transformBox(box, transform) {\n    transformAxis(box.x, transform.x, transform.scaleX, transform.scale, transform.originX);\n    transformAxis(box.y, transform.y, transform.scaleY, transform.scale, transform.originY);\n}\n\nexport { applyAxisDelta, applyBoxDelta, applyPointDelta, applyTreeDeltas, scalePoint, transformAxis, transformBox, translateAxis };\n"],"mappings":"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","ignoreList":[]},"targets":{},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/Users/anshul/Masters/Internship/POC/Meteor_Mobile/mieweb_push_auth","root":"/Users/anshul/Masters/Internship/POC/Meteor_Mobile/mieweb_push_auth","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true},"externalDependencies":[]},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.17.2","helpers":true,"useESModules":false,"corejs":false},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-react-jsx","visitor":{"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXFragment":{"exit":[null]},"JSXElement":{"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false},"externalDependencies":[]},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-nullish-coalescing-operator","visitor":{"LogicalExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-chaining","visitor":{"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-catch-binding","visitor":{"CatchClause":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"proposal-logical-assignment-operators","visitor":{"AssignmentExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]}],"presets":[],"generatorOpts":{"filename":"/Users/anshul/Masters/Internship/POC/Meteor_Mobile/mieweb_push_auth/node_modules/framer-motion/dist/es/projection/geometry/delta-apply.mjs","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"node_modules/framer-motion/dist/es/projection/geometry/delta-apply.mjs","inputSourceMap":{"version":3,"names":["mixNumber","hasTransform","scalePoint","point","scale","originPoint","distanceFromOrigin","scaled","applyPointDelta","translate","boxScale","undefined","applyAxisDelta","axis","min","max","applyBoxDelta","box","x","y","TREE_SCALE_SNAP_MIN","TREE_SCALE_SNAP_MAX","applyTreeDeltas","treeScale","treePath","isSharedTransition","treeLength","length","node","delta","i","projectionDelta","visualElement","options","props","style","display","layoutScroll","scroll","root","transformBox","offset","latestValues","translateAxis","distance","transformAxis","axisTranslate","axisScale","axisOrigin","transform","scaleX","originX","scaleY","originY"],"sources":["node_modules/framer-motion/dist/es/projection/geometry/delta-apply.mjs"],"sourcesContent":["import { mixNumber } from '../../utils/mix/number.mjs';\nimport { hasTransform } from '../utils/has-transform.mjs';\n\n/**\n * Scales a point based on a factor and an originPoint\n */\nfunction scalePoint(point, scale, originPoint) {\n    const distanceFromOrigin = point - originPoint;\n    const scaled = scale * distanceFromOrigin;\n    return originPoint + scaled;\n}\n/**\n * Applies a translate/scale delta to a point\n */\nfunction applyPointDelta(point, translate, scale, originPoint, boxScale) {\n    if (boxScale !== undefined) {\n        point = scalePoint(point, boxScale, originPoint);\n    }\n    return scalePoint(point, scale, originPoint) + translate;\n}\n/**\n * Applies a translate/scale delta to an axis\n */\nfunction applyAxisDelta(axis, translate = 0, scale = 1, originPoint, boxScale) {\n    axis.min = applyPointDelta(axis.min, translate, scale, originPoint, boxScale);\n    axis.max = applyPointDelta(axis.max, translate, scale, originPoint, boxScale);\n}\n/**\n * Applies a translate/scale delta to a box\n */\nfunction applyBoxDelta(box, { x, y }) {\n    applyAxisDelta(box.x, x.translate, x.scale, x.originPoint);\n    applyAxisDelta(box.y, y.translate, y.scale, y.originPoint);\n}\nconst TREE_SCALE_SNAP_MIN = 0.999999999999;\nconst TREE_SCALE_SNAP_MAX = 1.0000000000001;\n/**\n * Apply a tree of deltas to a box. We do this to calculate the effect of all the transforms\n * in a tree upon our box before then calculating how to project it into our desired viewport-relative box\n *\n * This is the final nested loop within updateLayoutDelta for future refactoring\n */\nfunction applyTreeDeltas(box, treeScale, treePath, isSharedTransition = false) {\n    const treeLength = treePath.length;\n    if (!treeLength)\n        return;\n    // Reset the treeScale\n    treeScale.x = treeScale.y = 1;\n    let node;\n    let delta;\n    for (let i = 0; i < treeLength; i++) {\n        node = treePath[i];\n        delta = node.projectionDelta;\n        /**\n         * TODO: Prefer to remove this, but currently we have motion components with\n         * display: contents in Framer.\n         */\n        const { visualElement } = node.options;\n        if (visualElement &&\n            visualElement.props.style &&\n            visualElement.props.style.display === \"contents\") {\n            continue;\n        }\n        if (isSharedTransition &&\n            node.options.layoutScroll &&\n            node.scroll &&\n            node !== node.root) {\n            transformBox(box, {\n                x: -node.scroll.offset.x,\n                y: -node.scroll.offset.y,\n            });\n        }\n        if (delta) {\n            // Incoporate each ancestor's scale into a culmulative treeScale for this component\n            treeScale.x *= delta.x.scale;\n            treeScale.y *= delta.y.scale;\n            // Apply each ancestor's calculated delta into this component's recorded layout box\n            applyBoxDelta(box, delta);\n        }\n        if (isSharedTransition && hasTransform(node.latestValues)) {\n            transformBox(box, node.latestValues);\n        }\n    }\n    /**\n     * Snap tree scale back to 1 if it's within a non-perceivable threshold.\n     * This will help reduce useless scales getting rendered.\n     */\n    if (treeScale.x < TREE_SCALE_SNAP_MAX &&\n        treeScale.x > TREE_SCALE_SNAP_MIN) {\n        treeScale.x = 1.0;\n    }\n    if (treeScale.y < TREE_SCALE_SNAP_MAX &&\n        treeScale.y > TREE_SCALE_SNAP_MIN) {\n        treeScale.y = 1.0;\n    }\n}\nfunction translateAxis(axis, distance) {\n    axis.min = axis.min + distance;\n    axis.max = axis.max + distance;\n}\n/**\n * Apply a transform to an axis from the latest resolved motion values.\n * This function basically acts as a bridge between a flat motion value map\n * and applyAxisDelta\n */\nfunction transformAxis(axis, axisTranslate, axisScale, boxScale, axisOrigin = 0.5) {\n    const originPoint = mixNumber(axis.min, axis.max, axisOrigin);\n    // Apply the axis delta to the final axis\n    applyAxisDelta(axis, axisTranslate, axisScale, originPoint, boxScale);\n}\n/**\n * Apply a transform to a box from the latest resolved motion values.\n */\nfunction transformBox(box, transform) {\n    transformAxis(box.x, transform.x, transform.scaleX, transform.scale, transform.originX);\n    transformAxis(box.y, transform.y, transform.scaleY, transform.scale, transform.originY);\n}\n\nexport { applyAxisDelta, applyBoxDelta, applyPointDelta, applyTreeDeltas, scalePoint, transformAxis, transformBox, translateAxis };\n"],"mappings":"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","ignoreList":[]}}},"code":"!function (module1) {\n  module1.export({\n    applyAxisDelta: () => applyAxisDelta,\n    applyBoxDelta: () => applyBoxDelta,\n    applyPointDelta: () => applyPointDelta,\n    applyTreeDeltas: () => applyTreeDeltas,\n    scalePoint: () => scalePoint,\n    transformAxis: () => transformAxis,\n    transformBox: () => transformBox,\n    translateAxis: () => translateAxis\n  });\n  let mixNumber;\n  module1.link(\"../../utils/mix/number.mjs\", {\n    mixNumber(v) {\n      mixNumber = v;\n    }\n  }, 0);\n  let hasTransform;\n  module1.link(\"../utils/has-transform.mjs\", {\n    hasTransform(v) {\n      hasTransform = v;\n    }\n  }, 1);\n  ___INIT_METEOR_FAST_REFRESH(module);\n  /**\n   * Scales a point based on a factor and an originPoint\n   */\n  function scalePoint(point, scale, originPoint) {\n    const distanceFromOrigin = point - originPoint;\n    const scaled = scale * distanceFromOrigin;\n    return originPoint + scaled;\n  }\n  /**\n   * Applies a translate/scale delta to a point\n   */\n  function applyPointDelta(point, translate, scale, originPoint, boxScale) {\n    if (boxScale !== undefined) {\n      point = scalePoint(point, boxScale, originPoint);\n    }\n    return scalePoint(point, scale, originPoint) + translate;\n  }\n  /**\n   * Applies a translate/scale delta to an axis\n   */\n  function applyAxisDelta(axis) {\n    let translate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let scale = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n    let originPoint = arguments.length > 3 ? arguments[3] : undefined;\n    let boxScale = arguments.length > 4 ? arguments[4] : undefined;\n    axis.min = applyPointDelta(axis.min, translate, scale, originPoint, boxScale);\n    axis.max = applyPointDelta(axis.max, translate, scale, originPoint, boxScale);\n  }\n  /**\n   * Applies a translate/scale delta to a box\n   */\n  function applyBoxDelta(box, _ref) {\n    let {\n      x,\n      y\n    } = _ref;\n    applyAxisDelta(box.x, x.translate, x.scale, x.originPoint);\n    applyAxisDelta(box.y, y.translate, y.scale, y.originPoint);\n  }\n  const TREE_SCALE_SNAP_MIN = 0.999999999999;\n  const TREE_SCALE_SNAP_MAX = 1.0000000000001;\n  /**\n   * Apply a tree of deltas to a box. We do this to calculate the effect of all the transforms\n   * in a tree upon our box before then calculating how to project it into our desired viewport-relative box\n   *\n   * This is the final nested loop within updateLayoutDelta for future refactoring\n   */\n  function applyTreeDeltas(box, treeScale, treePath) {\n    let isSharedTransition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    const treeLength = treePath.length;\n    if (!treeLength) return;\n    // Reset the treeScale\n    treeScale.x = treeScale.y = 1;\n    let node;\n    let delta;\n    for (let i = 0; i < treeLength; i++) {\n      node = treePath[i];\n      delta = node.projectionDelta;\n      /**\n       * TODO: Prefer to remove this, but currently we have motion components with\n       * display: contents in Framer.\n       */\n      const {\n        visualElement\n      } = node.options;\n      if (visualElement && visualElement.props.style && visualElement.props.style.display === \"contents\") {\n        continue;\n      }\n      if (isSharedTransition && node.options.layoutScroll && node.scroll && node !== node.root) {\n        transformBox(box, {\n          x: -node.scroll.offset.x,\n          y: -node.scroll.offset.y\n        });\n      }\n      if (delta) {\n        // Incoporate each ancestor's scale into a culmulative treeScale for this component\n        treeScale.x *= delta.x.scale;\n        treeScale.y *= delta.y.scale;\n        // Apply each ancestor's calculated delta into this component's recorded layout box\n        applyBoxDelta(box, delta);\n      }\n      if (isSharedTransition && hasTransform(node.latestValues)) {\n        transformBox(box, node.latestValues);\n      }\n    }\n    /**\n     * Snap tree scale back to 1 if it's within a non-perceivable threshold.\n     * This will help reduce useless scales getting rendered.\n     */\n    if (treeScale.x < TREE_SCALE_SNAP_MAX && treeScale.x > TREE_SCALE_SNAP_MIN) {\n      treeScale.x = 1.0;\n    }\n    if (treeScale.y < TREE_SCALE_SNAP_MAX && treeScale.y > TREE_SCALE_SNAP_MIN) {\n      treeScale.y = 1.0;\n    }\n  }\n  function translateAxis(axis, distance) {\n    axis.min = axis.min + distance;\n    axis.max = axis.max + distance;\n  }\n  /**\n   * Apply a transform to an axis from the latest resolved motion values.\n   * This function basically acts as a bridge between a flat motion value map\n   * and applyAxisDelta\n   */\n  function transformAxis(axis, axisTranslate, axisScale, boxScale) {\n    let axisOrigin = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0.5;\n    const originPoint = mixNumber(axis.min, axis.max, axisOrigin);\n    // Apply the axis delta to the final axis\n    applyAxisDelta(axis, axisTranslate, axisScale, originPoint, boxScale);\n  }\n  /**\n   * Apply a transform to a box from the latest resolved motion values.\n   */\n  function transformBox(box, transform) {\n    transformAxis(box.x, transform.x, transform.scaleX, transform.scale, transform.originX);\n    transformAxis(box.y, transform.y, transform.scaleY, transform.scale, transform.originY);\n  }\n}.call(this, module);","map":{"version":3,"names":["scalePoint","point","scale","originPoint","distanceFromOrigin","scaled","applyPointDelta","translate","boxScale","undefined","applyAxisDelta","axis","arguments","length","min","max","applyBoxDelta","box","_ref","x","y","TREE_SCALE_SNAP_MIN","TREE_SCALE_SNAP_MAX","applyTreeDeltas","treeScale","treePath","isSharedTransition","treeLength","node","delta","i","projectionDelta","visualElement","options","props","style","display","layoutScroll","scroll","root","transformBox","offset","hasTransform","latestValues","translateAxis","distance","transformAxis","axisTranslate","axisScale","axisOrigin","mixNumber","transform","scaleX","originX","scaleY","originY","call","module"],"sources":["node_modules/framer-motion/dist/es/projection/geometry/delta-apply.mjs"],"sourcesContent":["import { mixNumber } from '../../utils/mix/number.mjs';\nimport { hasTransform } from '../utils/has-transform.mjs';\n\n/**\n * Scales a point based on a factor and an originPoint\n */\nfunction scalePoint(point, scale, originPoint) {\n    const distanceFromOrigin = point - originPoint;\n    const scaled = scale * distanceFromOrigin;\n    return originPoint + scaled;\n}\n/**\n * Applies a translate/scale delta to a point\n */\nfunction applyPointDelta(point, translate, scale, originPoint, boxScale) {\n    if (boxScale !== undefined) {\n        point = scalePoint(point, boxScale, originPoint);\n    }\n    return scalePoint(point, scale, originPoint) + translate;\n}\n/**\n * Applies a translate/scale delta to an axis\n */\nfunction applyAxisDelta(axis, translate = 0, scale = 1, originPoint, boxScale) {\n    axis.min = applyPointDelta(axis.min, translate, scale, originPoint, boxScale);\n    axis.max = applyPointDelta(axis.max, translate, scale, originPoint, boxScale);\n}\n/**\n * Applies a translate/scale delta to a box\n */\nfunction applyBoxDelta(box, { x, y }) {\n    applyAxisDelta(box.x, x.translate, x.scale, x.originPoint);\n    applyAxisDelta(box.y, y.translate, y.scale, y.originPoint);\n}\nconst TREE_SCALE_SNAP_MIN = 0.999999999999;\nconst TREE_SCALE_SNAP_MAX = 1.0000000000001;\n/**\n * Apply a tree of deltas to a box. We do this to calculate the effect of all the transforms\n * in a tree upon our box before then calculating how to project it into our desired viewport-relative box\n *\n * This is the final nested loop within updateLayoutDelta for future refactoring\n */\nfunction applyTreeDeltas(box, treeScale, treePath, isSharedTransition = false) {\n    const treeLength = treePath.length;\n    if (!treeLength)\n        return;\n    // Reset the treeScale\n    treeScale.x = treeScale.y = 1;\n    let node;\n    let delta;\n    for (let i = 0; i < treeLength; i++) {\n        node = treePath[i];\n        delta = node.projectionDelta;\n        /**\n         * TODO: Prefer to remove this, but currently we have motion components with\n         * display: contents in Framer.\n         */\n        const { visualElement } = node.options;\n        if (visualElement &&\n            visualElement.props.style &&\n            visualElement.props.style.display === \"contents\") {\n            continue;\n        }\n        if (isSharedTransition &&\n            node.options.layoutScroll &&\n            node.scroll &&\n            node !== node.root) {\n            transformBox(box, {\n                x: -node.scroll.offset.x,\n                y: -node.scroll.offset.y,\n            });\n        }\n        if (delta) {\n            // Incoporate each ancestor's scale into a culmulative treeScale for this component\n            treeScale.x *= delta.x.scale;\n            treeScale.y *= delta.y.scale;\n            // Apply each ancestor's calculated delta into this component's recorded layout box\n            applyBoxDelta(box, delta);\n        }\n        if (isSharedTransition && hasTransform(node.latestValues)) {\n            transformBox(box, node.latestValues);\n        }\n    }\n    /**\n     * Snap tree scale back to 1 if it's within a non-perceivable threshold.\n     * This will help reduce useless scales getting rendered.\n     */\n    if (treeScale.x < TREE_SCALE_SNAP_MAX &&\n        treeScale.x > TREE_SCALE_SNAP_MIN) {\n        treeScale.x = 1.0;\n    }\n    if (treeScale.y < TREE_SCALE_SNAP_MAX &&\n        treeScale.y > TREE_SCALE_SNAP_MIN) {\n        treeScale.y = 1.0;\n    }\n}\nfunction translateAxis(axis, distance) {\n    axis.min = axis.min + distance;\n    axis.max = axis.max + distance;\n}\n/**\n * Apply a transform to an axis from the latest resolved motion values.\n * This function basically acts as a bridge between a flat motion value map\n * and applyAxisDelta\n */\nfunction transformAxis(axis, axisTranslate, axisScale, boxScale, axisOrigin = 0.5) {\n    const originPoint = mixNumber(axis.min, axis.max, axisOrigin);\n    // Apply the axis delta to the final axis\n    applyAxisDelta(axis, axisTranslate, axisScale, originPoint, boxScale);\n}\n/**\n * Apply a transform to a box from the latest resolved motion values.\n */\nfunction transformBox(box, transform) {\n    transformAxis(box.x, transform.x, transform.scaleX, transform.scale, transform.originX);\n    transformAxis(box.y, transform.y, transform.scaleY, transform.scale, transform.originY);\n}\n\nexport { applyAxisDelta, applyBoxDelta, applyPointDelta, applyTreeDeltas, scalePoint, transformAxis, transformBox, translateAxis };\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;EAGA;AACA;AACA;EACA,SAASA,UAAUA,CAACC,KAAK,EAAEC,KAAK,EAAEC,WAAW,EAAE;IAC3C,MAAMC,kBAAkB,GAAGH,KAAK,GAAGE,WAAW;IAC9C,MAAME,MAAM,GAAGH,KAAK,GAAGE,kBAAkB;IACzC,OAAOD,WAAW,GAAGE,MAAM;EAC/B;EACA;AACA;AACA;EACA,SAASC,eAAeA,CAACL,KAAK,EAAEM,SAAS,EAAEL,KAAK,EAAEC,WAAW,EAAEK,QAAQ,EAAE;IACrE,IAAIA,QAAQ,KAAKC,SAAS,EAAE;MACxBR,KAAK,GAAGD,UAAU,CAACC,KAAK,EAAEO,QAAQ,EAAEL,WAAW,CAAC;IACpD;IACA,OAAOH,UAAU,CAACC,KAAK,EAAEC,KAAK,EAAEC,WAAW,CAAC,GAAGI,SAAS;EAC5D;EACA;AACA;AACA;EACA,SAASG,cAAcA,CAACC,IAAI,EAAmD;IAAA,IAAjDJ,SAAS,GAAAK,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAH,SAAA,GAAAG,SAAA,MAAG,CAAC;IAAA,IAAEV,KAAK,GAAAU,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAH,SAAA,GAAAG,SAAA,MAAG,CAAC;IAAA,IAAET,WAAW,GAAAS,SAAA,CAAAC,MAAA,OAAAD,SAAA,MAAAH,SAAA;IAAA,IAAED,QAAQ,GAAAI,SAAA,CAAAC,MAAA,OAAAD,SAAA,MAAAH,SAAA;IACzEE,IAAI,CAACG,GAAG,GAAGR,eAAe,CAACK,IAAI,CAACG,GAAG,EAAEP,SAAS,EAAEL,KAAK,EAAEC,WAAW,EAAEK,QAAQ,CAAC;IAC7EG,IAAI,CAACI,GAAG,GAAGT,eAAe,CAACK,IAAI,CAACI,GAAG,EAAER,SAAS,EAAEL,KAAK,EAAEC,WAAW,EAAEK,QAAQ,CAAC;EACjF;EACA;AACA;AACA;EACA,SAASQ,aAAaA,CAACC,GAAG,EAAAC,IAAA,EAAY;IAAA,IAAV;MAAEC,CAAC;MAAEC;IAAE,CAAC,GAAAF,IAAA;IAChCR,cAAc,CAACO,GAAG,CAACE,CAAC,EAAEA,CAAC,CAACZ,SAAS,EAAEY,CAAC,CAACjB,KAAK,EAAEiB,CAAC,CAAChB,WAAW,CAAC;IAC1DO,cAAc,CAACO,GAAG,CAACG,CAAC,EAAEA,CAAC,CAACb,SAAS,EAAEa,CAAC,CAAClB,KAAK,EAAEkB,CAAC,CAACjB,WAAW,CAAC;EAC9D;EACA,MAAMkB,mBAAmB,GAAG,cAAc;EAC1C,MAAMC,mBAAmB,GAAG,eAAe;EAC3C;AACA;AACA;AACA;AACA;AACA;EACA,SAASC,eAAeA,CAACN,GAAG,EAAEO,SAAS,EAAEC,QAAQ,EAA8B;IAAA,IAA5BC,kBAAkB,GAAAd,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAH,SAAA,GAAAG,SAAA,MAAG,KAAK;IACzE,MAAMe,UAAU,GAAGF,QAAQ,CAACZ,MAAM;IAClC,IAAI,CAACc,UAAU,EACX;IACJ;IACAH,SAAS,CAACL,CAAC,GAAGK,SAAS,CAACJ,CAAC,GAAG,CAAC;IAC7B,IAAIQ,IAAI;IACR,IAAIC,KAAK;IACT,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,UAAU,EAAEG,CAAC,EAAE,EAAE;MACjCF,IAAI,GAAGH,QAAQ,CAACK,CAAC,CAAC;MAClBD,KAAK,GAAGD,IAAI,CAACG,eAAe;MAC5B;AACR;AACA;AACA;MACQ,MAAM;QAAEC;MAAc,CAAC,GAAGJ,IAAI,CAACK,OAAO;MACtC,IAAID,aAAa,IACbA,aAAa,CAACE,KAAK,CAACC,KAAK,IACzBH,aAAa,CAACE,KAAK,CAACC,KAAK,CAACC,OAAO,KAAK,UAAU,EAAE;QAClD;MACJ;MACA,IAAIV,kBAAkB,IAClBE,IAAI,CAACK,OAAO,CAACI,YAAY,IACzBT,IAAI,CAACU,MAAM,IACXV,IAAI,KAAKA,IAAI,CAACW,IAAI,EAAE;QACpBC,YAAY,CAACvB,GAAG,EAAE;UACdE,CAAC,EAAE,CAACS,IAAI,CAACU,MAAM,CAACG,MAAM,CAACtB,CAAC;UACxBC,CAAC,EAAE,CAACQ,IAAI,CAACU,MAAM,CAACG,MAAM,CAACrB;QAC3B,CAAC,CAAC;MACN;MACA,IAAIS,KAAK,EAAE;QACP;QACAL,SAAS,CAACL,CAAC,IAAIU,KAAK,CAACV,CAAC,CAACjB,KAAK;QAC5BsB,SAAS,CAACJ,CAAC,IAAIS,KAAK,CAACT,CAAC,CAAClB,KAAK;QAC5B;QACAc,aAAa,CAACC,GAAG,EAAEY,KAAK,CAAC;MAC7B;MACA,IAAIH,kBAAkB,IAAIgB,YAAY,CAACd,IAAI,CAACe,YAAY,CAAC,EAAE;QACvDH,YAAY,CAACvB,GAAG,EAAEW,IAAI,CAACe,YAAY,CAAC;MACxC;IACJ;IACA;AACJ;AACA;AACA;IACI,IAAInB,SAAS,CAACL,CAAC,GAAGG,mBAAmB,IACjCE,SAAS,CAACL,CAAC,GAAGE,mBAAmB,EAAE;MACnCG,SAAS,CAACL,CAAC,GAAG,GAAG;IACrB;IACA,IAAIK,SAAS,CAACJ,CAAC,GAAGE,mBAAmB,IACjCE,SAAS,CAACJ,CAAC,GAAGC,mBAAmB,EAAE;MACnCG,SAAS,CAACJ,CAAC,GAAG,GAAG;IACrB;EACJ;EACA,SAASwB,aAAaA,CAACjC,IAAI,EAAEkC,QAAQ,EAAE;IACnClC,IAAI,CAACG,GAAG,GAAGH,IAAI,CAACG,GAAG,GAAG+B,QAAQ;IAC9BlC,IAAI,CAACI,GAAG,GAAGJ,IAAI,CAACI,GAAG,GAAG8B,QAAQ;EAClC;EACA;AACA;AACA;AACA;AACA;EACA,SAASC,aAAaA,CAACnC,IAAI,EAAEoC,aAAa,EAAEC,SAAS,EAAExC,QAAQ,EAAoB;IAAA,IAAlByC,UAAU,GAAArC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAH,SAAA,GAAAG,SAAA,MAAG,GAAG;IAC7E,MAAMT,WAAW,GAAG+C,SAAS,CAACvC,IAAI,CAACG,GAAG,EAAEH,IAAI,CAACI,GAAG,EAAEkC,UAAU,CAAC;IAC7D;IACAvC,cAAc,CAACC,IAAI,EAAEoC,aAAa,EAAEC,SAAS,EAAE7C,WAAW,EAAEK,QAAQ,CAAC;EACzE;EACA;AACA;AACA;EACA,SAASgC,YAAYA,CAACvB,GAAG,EAAEkC,SAAS,EAAE;IAClCL,aAAa,CAAC7B,GAAG,CAACE,CAAC,EAAEgC,SAAS,CAAChC,CAAC,EAAEgC,SAAS,CAACC,MAAM,EAAED,SAAS,CAACjD,KAAK,EAAEiD,SAAS,CAACE,OAAO,CAAC;IACvFP,aAAa,CAAC7B,GAAG,CAACG,CAAC,EAAE+B,SAAS,CAAC/B,CAAC,EAAE+B,SAAS,CAACG,MAAM,EAAEH,SAAS,CAACjD,KAAK,EAAEiD,SAAS,CAACI,OAAO,CAAC;EAC3F;AAAA,EAAAC,IAAA,OAAAC,MAAA","ignoreList":[]},"sourceType":"module","externalDependencies":{},"hash":"6d19f52d930376ff904a4310141195370269cd14"}
