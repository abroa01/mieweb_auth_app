{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/anshul/Masters/Internship/POC/Meteor_Mobile/mieweb_push_auth/node_modules/framer-motion/dist/es/animation/animators/BaseAnimation.mjs","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","topLevelAwait","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"web.browser"},"sourceFileName":"node_modules/framer-motion/dist/es/animation/animators/BaseAnimation.mjs","filename":"/Users/anshul/Masters/Internship/POC/Meteor_Mobile/mieweb_push_auth/node_modules/framer-motion/dist/es/animation/animators/BaseAnimation.mjs","inputSourceMap":{"version":3,"names":["time","flushKeyframeResolvers","instantAnimationState","canAnimate","getFinalKeyframe","MAX_RESOLVE_DELAY","BaseAnimation","constructor","autoplay","delay","type","repeat","repeatDelay","repeatType","options","isStopped","hasAttemptedResolve","createdAt","now","updateFinishedPromise","calcStartTime","resolvedAt","resolved","_resolved","onKeyframesResolved","keyframes","finalKeyframe","name","velocity","onComplete","onUpdate","isGenerator","current","resolveFinishedPromise","duration","resolvedAnimation","initPlayback","onPostResolved","then","resolve","reject","currentFinishedPromise","flatten","ease","Promise"],"sources":["node_modules/framer-motion/dist/es/animation/animators/BaseAnimation.mjs"],"sourcesContent":["import { time } from '../../frameloop/sync-time.mjs';\nimport { flushKeyframeResolvers } from '../../render/utils/KeyframesResolver.mjs';\nimport { instantAnimationState } from '../../utils/use-instant-transition-state.mjs';\nimport { canAnimate } from './utils/can-animate.mjs';\nimport { getFinalKeyframe } from './waapi/utils/get-final-keyframe.mjs';\n\n/**\n * Maximum time allowed between an animation being created and it being\n * resolved for us to use the latter as the start time.\n *\n * This is to ensure that while we prefer to \"start\" an animation as soon\n * as it's triggered, we also want to avoid a visual jump if there's a big delay\n * between these two moments.\n */\nconst MAX_RESOLVE_DELAY = 40;\nclass BaseAnimation {\n    constructor({ autoplay = true, delay = 0, type = \"keyframes\", repeat = 0, repeatDelay = 0, repeatType = \"loop\", ...options }) {\n        // Track whether the animation has been stopped. Stopped animations won't restart.\n        this.isStopped = false;\n        this.hasAttemptedResolve = false;\n        this.createdAt = time.now();\n        this.options = {\n            autoplay,\n            delay,\n            type,\n            repeat,\n            repeatDelay,\n            repeatType,\n            ...options,\n        };\n        this.updateFinishedPromise();\n    }\n    /**\n     * This method uses the createdAt and resolvedAt to calculate the\n     * animation startTime. *Ideally*, we would use the createdAt time as t=0\n     * as the following frame would then be the first frame of the animation in\n     * progress, which would feel snappier.\n     *\n     * However, if there's a delay (main thread work) between the creation of\n     * the animation and the first commited frame, we prefer to use resolvedAt\n     * to avoid a sudden jump into the animation.\n     */\n    calcStartTime() {\n        if (!this.resolvedAt)\n            return this.createdAt;\n        return this.resolvedAt - this.createdAt > MAX_RESOLVE_DELAY\n            ? this.resolvedAt\n            : this.createdAt;\n    }\n    /**\n     * A getter for resolved data. If keyframes are not yet resolved, accessing\n     * this.resolved will synchronously flush all pending keyframe resolvers.\n     * This is a deoptimisation, but at its worst still batches read/writes.\n     */\n    get resolved() {\n        if (!this._resolved && !this.hasAttemptedResolve) {\n            flushKeyframeResolvers();\n        }\n        return this._resolved;\n    }\n    /**\n     * A method to be called when the keyframes resolver completes. This method\n     * will check if its possible to run the animation and, if not, skip it.\n     * Otherwise, it will call initPlayback on the implementing class.\n     */\n    onKeyframesResolved(keyframes, finalKeyframe) {\n        this.resolvedAt = time.now();\n        this.hasAttemptedResolve = true;\n        const { name, type, velocity, delay, onComplete, onUpdate, isGenerator, } = this.options;\n        /**\n         * If we can't animate this value with the resolved keyframes\n         * then we should complete it immediately.\n         */\n        if (!isGenerator && !canAnimate(keyframes, name, type, velocity)) {\n            // Finish immediately\n            if (instantAnimationState.current || !delay) {\n                onUpdate === null || onUpdate === void 0 ? void 0 : onUpdate(getFinalKeyframe(keyframes, this.options, finalKeyframe));\n                onComplete === null || onComplete === void 0 ? void 0 : onComplete();\n                this.resolveFinishedPromise();\n                return;\n            }\n            // Finish after a delay\n            else {\n                this.options.duration = 0;\n            }\n        }\n        const resolvedAnimation = this.initPlayback(keyframes, finalKeyframe);\n        if (resolvedAnimation === false)\n            return;\n        this._resolved = {\n            keyframes,\n            finalKeyframe,\n            ...resolvedAnimation,\n        };\n        this.onPostResolved();\n    }\n    onPostResolved() { }\n    /**\n     * Allows the returned animation to be awaited or promise-chained. Currently\n     * resolves when the animation finishes at all but in a future update could/should\n     * reject if its cancels.\n     */\n    then(resolve, reject) {\n        return this.currentFinishedPromise.then(resolve, reject);\n    }\n    flatten() {\n        this.options.type = \"keyframes\";\n        this.options.ease = \"linear\";\n    }\n    updateFinishedPromise() {\n        this.currentFinishedPromise = new Promise((resolve) => {\n            this.resolveFinishedPromise = resolve;\n        });\n    }\n}\n\nexport { BaseAnimation };\n"],"mappings":"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","ignoreList":[]},"targets":{},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/Users/anshul/Masters/Internship/POC/Meteor_Mobile/mieweb_push_auth","root":"/Users/anshul/Masters/Internship/POC/Meteor_Mobile/mieweb_push_auth","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true},"externalDependencies":[]},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.17.2","helpers":true,"useESModules":false,"corejs":false},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-react-jsx","visitor":{"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXFragment":{"exit":[null]},"JSXElement":{"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false},"externalDependencies":[]},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-nullish-coalescing-operator","visitor":{"LogicalExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-chaining","visitor":{"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-catch-binding","visitor":{"CatchClause":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"proposal-logical-assignment-operators","visitor":{"AssignmentExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]}],"presets":[],"generatorOpts":{"filename":"/Users/anshul/Masters/Internship/POC/Meteor_Mobile/mieweb_push_auth/node_modules/framer-motion/dist/es/animation/animators/BaseAnimation.mjs","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"node_modules/framer-motion/dist/es/animation/animators/BaseAnimation.mjs","inputSourceMap":{"version":3,"names":["time","flushKeyframeResolvers","instantAnimationState","canAnimate","getFinalKeyframe","MAX_RESOLVE_DELAY","BaseAnimation","constructor","autoplay","delay","type","repeat","repeatDelay","repeatType","options","isStopped","hasAttemptedResolve","createdAt","now","updateFinishedPromise","calcStartTime","resolvedAt","resolved","_resolved","onKeyframesResolved","keyframes","finalKeyframe","name","velocity","onComplete","onUpdate","isGenerator","current","resolveFinishedPromise","duration","resolvedAnimation","initPlayback","onPostResolved","then","resolve","reject","currentFinishedPromise","flatten","ease","Promise"],"sources":["node_modules/framer-motion/dist/es/animation/animators/BaseAnimation.mjs"],"sourcesContent":["import { time } from '../../frameloop/sync-time.mjs';\nimport { flushKeyframeResolvers } from '../../render/utils/KeyframesResolver.mjs';\nimport { instantAnimationState } from '../../utils/use-instant-transition-state.mjs';\nimport { canAnimate } from './utils/can-animate.mjs';\nimport { getFinalKeyframe } from './waapi/utils/get-final-keyframe.mjs';\n\n/**\n * Maximum time allowed between an animation being created and it being\n * resolved for us to use the latter as the start time.\n *\n * This is to ensure that while we prefer to \"start\" an animation as soon\n * as it's triggered, we also want to avoid a visual jump if there's a big delay\n * between these two moments.\n */\nconst MAX_RESOLVE_DELAY = 40;\nclass BaseAnimation {\n    constructor({ autoplay = true, delay = 0, type = \"keyframes\", repeat = 0, repeatDelay = 0, repeatType = \"loop\", ...options }) {\n        // Track whether the animation has been stopped. Stopped animations won't restart.\n        this.isStopped = false;\n        this.hasAttemptedResolve = false;\n        this.createdAt = time.now();\n        this.options = {\n            autoplay,\n            delay,\n            type,\n            repeat,\n            repeatDelay,\n            repeatType,\n            ...options,\n        };\n        this.updateFinishedPromise();\n    }\n    /**\n     * This method uses the createdAt and resolvedAt to calculate the\n     * animation startTime. *Ideally*, we would use the createdAt time as t=0\n     * as the following frame would then be the first frame of the animation in\n     * progress, which would feel snappier.\n     *\n     * However, if there's a delay (main thread work) between the creation of\n     * the animation and the first commited frame, we prefer to use resolvedAt\n     * to avoid a sudden jump into the animation.\n     */\n    calcStartTime() {\n        if (!this.resolvedAt)\n            return this.createdAt;\n        return this.resolvedAt - this.createdAt > MAX_RESOLVE_DELAY\n            ? this.resolvedAt\n            : this.createdAt;\n    }\n    /**\n     * A getter for resolved data. If keyframes are not yet resolved, accessing\n     * this.resolved will synchronously flush all pending keyframe resolvers.\n     * This is a deoptimisation, but at its worst still batches read/writes.\n     */\n    get resolved() {\n        if (!this._resolved && !this.hasAttemptedResolve) {\n            flushKeyframeResolvers();\n        }\n        return this._resolved;\n    }\n    /**\n     * A method to be called when the keyframes resolver completes. This method\n     * will check if its possible to run the animation and, if not, skip it.\n     * Otherwise, it will call initPlayback on the implementing class.\n     */\n    onKeyframesResolved(keyframes, finalKeyframe) {\n        this.resolvedAt = time.now();\n        this.hasAttemptedResolve = true;\n        const { name, type, velocity, delay, onComplete, onUpdate, isGenerator, } = this.options;\n        /**\n         * If we can't animate this value with the resolved keyframes\n         * then we should complete it immediately.\n         */\n        if (!isGenerator && !canAnimate(keyframes, name, type, velocity)) {\n            // Finish immediately\n            if (instantAnimationState.current || !delay) {\n                onUpdate === null || onUpdate === void 0 ? void 0 : onUpdate(getFinalKeyframe(keyframes, this.options, finalKeyframe));\n                onComplete === null || onComplete === void 0 ? void 0 : onComplete();\n                this.resolveFinishedPromise();\n                return;\n            }\n            // Finish after a delay\n            else {\n                this.options.duration = 0;\n            }\n        }\n        const resolvedAnimation = this.initPlayback(keyframes, finalKeyframe);\n        if (resolvedAnimation === false)\n            return;\n        this._resolved = {\n            keyframes,\n            finalKeyframe,\n            ...resolvedAnimation,\n        };\n        this.onPostResolved();\n    }\n    onPostResolved() { }\n    /**\n     * Allows the returned animation to be awaited or promise-chained. Currently\n     * resolves when the animation finishes at all but in a future update could/should\n     * reject if its cancels.\n     */\n    then(resolve, reject) {\n        return this.currentFinishedPromise.then(resolve, reject);\n    }\n    flatten() {\n        this.options.type = \"keyframes\";\n        this.options.ease = \"linear\";\n    }\n    updateFinishedPromise() {\n        this.currentFinishedPromise = new Promise((resolve) => {\n            this.resolveFinishedPromise = resolve;\n        });\n    }\n}\n\nexport { BaseAnimation };\n"],"mappings":"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","ignoreList":[]}}},"code":"!function (module1) {\n  let _objectSpread;\n  module1.link(\"@babel/runtime/helpers/objectSpread2\", {\n    default(v) {\n      _objectSpread = v;\n    }\n  }, 0);\n  let _objectWithoutProperties;\n  module1.link(\"@babel/runtime/helpers/objectWithoutProperties\", {\n    default(v) {\n      _objectWithoutProperties = v;\n    }\n  }, 1);\n  const _excluded = [\"autoplay\", \"delay\", \"type\", \"repeat\", \"repeatDelay\", \"repeatType\"];\n  module1.export({\n    BaseAnimation: () => BaseAnimation\n  });\n  let time;\n  module1.link(\"../../frameloop/sync-time.mjs\", {\n    time(v) {\n      time = v;\n    }\n  }, 0);\n  let flushKeyframeResolvers;\n  module1.link(\"../../render/utils/KeyframesResolver.mjs\", {\n    flushKeyframeResolvers(v) {\n      flushKeyframeResolvers = v;\n    }\n  }, 1);\n  let instantAnimationState;\n  module1.link(\"../../utils/use-instant-transition-state.mjs\", {\n    instantAnimationState(v) {\n      instantAnimationState = v;\n    }\n  }, 2);\n  let canAnimate;\n  module1.link(\"./utils/can-animate.mjs\", {\n    canAnimate(v) {\n      canAnimate = v;\n    }\n  }, 3);\n  let getFinalKeyframe;\n  module1.link(\"./waapi/utils/get-final-keyframe.mjs\", {\n    getFinalKeyframe(v) {\n      getFinalKeyframe = v;\n    }\n  }, 4);\n  ___INIT_METEOR_FAST_REFRESH(module);\n  /**\n   * Maximum time allowed between an animation being created and it being\n   * resolved for us to use the latter as the start time.\n   *\n   * This is to ensure that while we prefer to \"start\" an animation as soon\n   * as it's triggered, we also want to avoid a visual jump if there's a big delay\n   * between these two moments.\n   */\n  const MAX_RESOLVE_DELAY = 40;\n  class BaseAnimation {\n    constructor(_ref) {\n      let {\n          autoplay = true,\n          delay = 0,\n          type = \"keyframes\",\n          repeat = 0,\n          repeatDelay = 0,\n          repeatType = \"loop\"\n        } = _ref,\n        options = _objectWithoutProperties(_ref, _excluded);\n      // Track whether the animation has been stopped. Stopped animations won't restart.\n      this.isStopped = false;\n      this.hasAttemptedResolve = false;\n      this.createdAt = time.now();\n      this.options = _objectSpread({\n        autoplay,\n        delay,\n        type,\n        repeat,\n        repeatDelay,\n        repeatType\n      }, options);\n      this.updateFinishedPromise();\n    }\n    /**\n     * This method uses the createdAt and resolvedAt to calculate the\n     * animation startTime. *Ideally*, we would use the createdAt time as t=0\n     * as the following frame would then be the first frame of the animation in\n     * progress, which would feel snappier.\n     *\n     * However, if there's a delay (main thread work) between the creation of\n     * the animation and the first commited frame, we prefer to use resolvedAt\n     * to avoid a sudden jump into the animation.\n     */\n    calcStartTime() {\n      if (!this.resolvedAt) return this.createdAt;\n      return this.resolvedAt - this.createdAt > MAX_RESOLVE_DELAY ? this.resolvedAt : this.createdAt;\n    }\n    /**\n     * A getter for resolved data. If keyframes are not yet resolved, accessing\n     * this.resolved will synchronously flush all pending keyframe resolvers.\n     * This is a deoptimisation, but at its worst still batches read/writes.\n     */\n    get resolved() {\n      if (!this._resolved && !this.hasAttemptedResolve) {\n        flushKeyframeResolvers();\n      }\n      return this._resolved;\n    }\n    /**\n     * A method to be called when the keyframes resolver completes. This method\n     * will check if its possible to run the animation and, if not, skip it.\n     * Otherwise, it will call initPlayback on the implementing class.\n     */\n    onKeyframesResolved(keyframes, finalKeyframe) {\n      this.resolvedAt = time.now();\n      this.hasAttemptedResolve = true;\n      const {\n        name,\n        type,\n        velocity,\n        delay,\n        onComplete,\n        onUpdate,\n        isGenerator\n      } = this.options;\n      /**\n       * If we can't animate this value with the resolved keyframes\n       * then we should complete it immediately.\n       */\n      if (!isGenerator && !canAnimate(keyframes, name, type, velocity)) {\n        // Finish immediately\n        if (instantAnimationState.current || !delay) {\n          onUpdate === null || onUpdate === void 0 ? void 0 : onUpdate(getFinalKeyframe(keyframes, this.options, finalKeyframe));\n          onComplete === null || onComplete === void 0 ? void 0 : onComplete();\n          this.resolveFinishedPromise();\n          return;\n        }\n        // Finish after a delay\n        else {\n          this.options.duration = 0;\n        }\n      }\n      const resolvedAnimation = this.initPlayback(keyframes, finalKeyframe);\n      if (resolvedAnimation === false) return;\n      this._resolved = _objectSpread({\n        keyframes,\n        finalKeyframe\n      }, resolvedAnimation);\n      this.onPostResolved();\n    }\n    onPostResolved() {}\n    /**\n     * Allows the returned animation to be awaited or promise-chained. Currently\n     * resolves when the animation finishes at all but in a future update could/should\n     * reject if its cancels.\n     */\n    then(resolve, reject) {\n      return this.currentFinishedPromise.then(resolve, reject);\n    }\n    flatten() {\n      this.options.type = \"keyframes\";\n      this.options.ease = \"linear\";\n    }\n    updateFinishedPromise() {\n      this.currentFinishedPromise = new Promise(resolve => {\n        this.resolveFinishedPromise = resolve;\n      });\n    }\n  }\n}.call(this, module);","map":{"version":3,"names":["MAX_RESOLVE_DELAY","BaseAnimation","constructor","_ref","autoplay","delay","type","repeat","repeatDelay","repeatType","options","_objectWithoutProperties","_excluded","isStopped","hasAttemptedResolve","createdAt","time","now","_objectSpread","updateFinishedPromise","calcStartTime","resolvedAt","resolved","_resolved","flushKeyframeResolvers","onKeyframesResolved","keyframes","finalKeyframe","name","velocity","onComplete","onUpdate","isGenerator","canAnimate","instantAnimationState","current","getFinalKeyframe","resolveFinishedPromise","duration","resolvedAnimation","initPlayback","onPostResolved","then","resolve","reject","currentFinishedPromise","flatten","ease","Promise","call","module"],"sources":["node_modules/framer-motion/dist/es/animation/animators/BaseAnimation.mjs"],"sourcesContent":["import { time } from '../../frameloop/sync-time.mjs';\nimport { flushKeyframeResolvers } from '../../render/utils/KeyframesResolver.mjs';\nimport { instantAnimationState } from '../../utils/use-instant-transition-state.mjs';\nimport { canAnimate } from './utils/can-animate.mjs';\nimport { getFinalKeyframe } from './waapi/utils/get-final-keyframe.mjs';\n\n/**\n * Maximum time allowed between an animation being created and it being\n * resolved for us to use the latter as the start time.\n *\n * This is to ensure that while we prefer to \"start\" an animation as soon\n * as it's triggered, we also want to avoid a visual jump if there's a big delay\n * between these two moments.\n */\nconst MAX_RESOLVE_DELAY = 40;\nclass BaseAnimation {\n    constructor({ autoplay = true, delay = 0, type = \"keyframes\", repeat = 0, repeatDelay = 0, repeatType = \"loop\", ...options }) {\n        // Track whether the animation has been stopped. Stopped animations won't restart.\n        this.isStopped = false;\n        this.hasAttemptedResolve = false;\n        this.createdAt = time.now();\n        this.options = {\n            autoplay,\n            delay,\n            type,\n            repeat,\n            repeatDelay,\n            repeatType,\n            ...options,\n        };\n        this.updateFinishedPromise();\n    }\n    /**\n     * This method uses the createdAt and resolvedAt to calculate the\n     * animation startTime. *Ideally*, we would use the createdAt time as t=0\n     * as the following frame would then be the first frame of the animation in\n     * progress, which would feel snappier.\n     *\n     * However, if there's a delay (main thread work) between the creation of\n     * the animation and the first commited frame, we prefer to use resolvedAt\n     * to avoid a sudden jump into the animation.\n     */\n    calcStartTime() {\n        if (!this.resolvedAt)\n            return this.createdAt;\n        return this.resolvedAt - this.createdAt > MAX_RESOLVE_DELAY\n            ? this.resolvedAt\n            : this.createdAt;\n    }\n    /**\n     * A getter for resolved data. If keyframes are not yet resolved, accessing\n     * this.resolved will synchronously flush all pending keyframe resolvers.\n     * This is a deoptimisation, but at its worst still batches read/writes.\n     */\n    get resolved() {\n        if (!this._resolved && !this.hasAttemptedResolve) {\n            flushKeyframeResolvers();\n        }\n        return this._resolved;\n    }\n    /**\n     * A method to be called when the keyframes resolver completes. This method\n     * will check if its possible to run the animation and, if not, skip it.\n     * Otherwise, it will call initPlayback on the implementing class.\n     */\n    onKeyframesResolved(keyframes, finalKeyframe) {\n        this.resolvedAt = time.now();\n        this.hasAttemptedResolve = true;\n        const { name, type, velocity, delay, onComplete, onUpdate, isGenerator, } = this.options;\n        /**\n         * If we can't animate this value with the resolved keyframes\n         * then we should complete it immediately.\n         */\n        if (!isGenerator && !canAnimate(keyframes, name, type, velocity)) {\n            // Finish immediately\n            if (instantAnimationState.current || !delay) {\n                onUpdate === null || onUpdate === void 0 ? void 0 : onUpdate(getFinalKeyframe(keyframes, this.options, finalKeyframe));\n                onComplete === null || onComplete === void 0 ? void 0 : onComplete();\n                this.resolveFinishedPromise();\n                return;\n            }\n            // Finish after a delay\n            else {\n                this.options.duration = 0;\n            }\n        }\n        const resolvedAnimation = this.initPlayback(keyframes, finalKeyframe);\n        if (resolvedAnimation === false)\n            return;\n        this._resolved = {\n            keyframes,\n            finalKeyframe,\n            ...resolvedAnimation,\n        };\n        this.onPostResolved();\n    }\n    onPostResolved() { }\n    /**\n     * Allows the returned animation to be awaited or promise-chained. Currently\n     * resolves when the animation finishes at all but in a future update could/should\n     * reject if its cancels.\n     */\n    then(resolve, reject) {\n        return this.currentFinishedPromise.then(resolve, reject);\n    }\n    flatten() {\n        this.options.type = \"keyframes\";\n        this.options.ease = \"linear\";\n    }\n    updateFinishedPromise() {\n        this.currentFinishedPromise = new Promise((resolve) => {\n            this.resolveFinishedPromise = resolve;\n        });\n    }\n}\n\nexport { BaseAnimation };\n"],"mappings":"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","ignoreList":[]},"sourceType":"module","externalDependencies":{},"hash":"7c9e0979c055efeed251d8a1e585f854a016e662"}
