{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/anshul/Masters/Internship/POC/Meteor_Mobile/mieweb_push_auth/node_modules/framer-motion/dist/es/animation/optimized-appear/start.mjs","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","topLevelAwait","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"web.browser"},"sourceFileName":"node_modules/framer-motion/dist/es/animation/optimized-appear/start.mjs","filename":"/Users/anshul/Masters/Internship/POC/Meteor_Mobile/mieweb_push_auth/node_modules/framer-motion/dist/es/animation/optimized-appear/start.mjs","inputSourceMap":{"version":3,"names":["appearStoreId","startWaapiAnimation","optimizedAppearDataId","handoffOptimizedAppearAnimation","appearAnimationStore","appearComplete","noop","getOptimisedAppearId","startFrameTime","readyAnimation","suspendedAnimations","Set","resumeSuspendedAnimations","forEach","data","animation","play","startTime","clear","startOptimizedAppearAnimation","element","name","keyframes","options","onReady","window","MotionIsMounted","id","dataset","MotionHandoffAnimation","storeId","duration","ease","set","MotionHasOptimisedAnimation","elementId","valueName","has","animationId","Boolean","get","MotionHandoffMarkAsComplete","MotionHandoffIsComplete","MotionCancelOptimisedAnimation","frame","canResume","undefined","postRender","cancel","add","render","delete","size","MotionCheckAppearSync","visualElement","value","_a","_b","appearId","valueIsOptimised","call","externalAnimationValue","props","values","removeSyncCheck","on","latestValue","startAnimation","appearAnimation","performance","now","ready","then","catch"],"sources":["node_modules/framer-motion/dist/es/animation/optimized-appear/start.mjs"],"sourcesContent":["import { appearStoreId } from './store-id.mjs';\nimport { startWaapiAnimation } from '../animators/waapi/index.mjs';\nimport { optimizedAppearDataId } from './data-id.mjs';\nimport { handoffOptimizedAppearAnimation } from './handoff.mjs';\nimport { appearAnimationStore, appearComplete } from './store.mjs';\nimport { noop } from 'motion-utils';\nimport { getOptimisedAppearId } from './get-appear-id.mjs';\n\n/**\n * A single time to use across all animations to manually set startTime\n * and ensure they're all in sync.\n */\nlet startFrameTime;\n/**\n * A dummy animation to detect when Chrome is ready to start\n * painting the page and hold off from triggering the real animation\n * until then. We only need one animation to detect paint ready.\n *\n * https://bugs.chromium.org/p/chromium/issues/detail?id=1406850\n */\nlet readyAnimation;\n/**\n * Keep track of animations that were suspended vs cancelled so we\n * can easily resume them when we're done measuring layout.\n */\nconst suspendedAnimations = new Set();\nfunction resumeSuspendedAnimations() {\n    suspendedAnimations.forEach((data) => {\n        data.animation.play();\n        data.animation.startTime = data.startTime;\n    });\n    suspendedAnimations.clear();\n}\nfunction startOptimizedAppearAnimation(element, name, keyframes, options, onReady) {\n    // Prevent optimised appear animations if Motion has already started animating.\n    if (window.MotionIsMounted) {\n        return;\n    }\n    const id = element.dataset[optimizedAppearDataId];\n    if (!id)\n        return;\n    window.MotionHandoffAnimation = handoffOptimizedAppearAnimation;\n    const storeId = appearStoreId(id, name);\n    if (!readyAnimation) {\n        readyAnimation = startWaapiAnimation(element, name, [keyframes[0], keyframes[0]], \n        /**\n         * 10 secs is basically just a super-safe duration to give Chrome\n         * long enough to get the animation ready.\n         */\n        { duration: 10000, ease: \"linear\" });\n        appearAnimationStore.set(storeId, {\n            animation: readyAnimation,\n            startTime: null,\n        });\n        /**\n         * If there's no readyAnimation then there's been no instantiation\n         * of handoff animations.\n         */\n        window.MotionHandoffAnimation = handoffOptimizedAppearAnimation;\n        window.MotionHasOptimisedAnimation = (elementId, valueName) => {\n            if (!elementId)\n                return false;\n            /**\n             * Keep a map of elementIds that have started animating. We check\n             * via ID instead of Element because of hydration errors and\n             * pre-hydration checks. We also actively record IDs as they start\n             * animating rather than simply checking for data-appear-id as\n             * this attrbute might be present but not lead to an animation, for\n             * instance if the element's appear animation is on a different\n             * breakpoint.\n             */\n            if (!valueName) {\n                return appearComplete.has(elementId);\n            }\n            const animationId = appearStoreId(elementId, valueName);\n            return Boolean(appearAnimationStore.get(animationId));\n        };\n        window.MotionHandoffMarkAsComplete = (elementId) => {\n            if (appearComplete.has(elementId)) {\n                appearComplete.set(elementId, true);\n            }\n        };\n        window.MotionHandoffIsComplete = (elementId) => {\n            return appearComplete.get(elementId) === true;\n        };\n        /**\n         * We only need to cancel transform animations as\n         * they're the ones that will interfere with the\n         * layout animation measurements.\n         */\n        window.MotionCancelOptimisedAnimation = (elementId, valueName, frame, canResume) => {\n            const animationId = appearStoreId(elementId, valueName);\n            const data = appearAnimationStore.get(animationId);\n            if (!data)\n                return;\n            if (frame && canResume === undefined) {\n                /**\n                 * Wait until the end of the subsequent frame to cancel the animation\n                 * to ensure we don't remove the animation before the main thread has\n                 * had a chance to resolve keyframes and render.\n                 */\n                frame.postRender(() => {\n                    frame.postRender(() => {\n                        data.animation.cancel();\n                    });\n                });\n            }\n            else {\n                data.animation.cancel();\n            }\n            if (frame && canResume) {\n                suspendedAnimations.add(data);\n                frame.render(resumeSuspendedAnimations);\n            }\n            else {\n                appearAnimationStore.delete(animationId);\n                /**\n                 * If there are no more animations left, we can remove the cancel function.\n                 * This will let us know when we can stop checking for conflicting layout animations.\n                 */\n                if (!appearAnimationStore.size) {\n                    window.MotionCancelOptimisedAnimation = undefined;\n                }\n            }\n        };\n        window.MotionCheckAppearSync = (visualElement, valueName, value) => {\n            var _a, _b;\n            const appearId = getOptimisedAppearId(visualElement);\n            if (!appearId)\n                return;\n            const valueIsOptimised = (_a = window.MotionHasOptimisedAnimation) === null || _a === void 0 ? void 0 : _a.call(window, appearId, valueName);\n            const externalAnimationValue = (_b = visualElement.props.values) === null || _b === void 0 ? void 0 : _b[valueName];\n            if (!valueIsOptimised || !externalAnimationValue)\n                return;\n            const removeSyncCheck = value.on(\"change\", (latestValue) => {\n                var _a;\n                if (externalAnimationValue.get() !== latestValue) {\n                    (_a = window.MotionCancelOptimisedAnimation) === null || _a === void 0 ? void 0 : _a.call(window, appearId, valueName);\n                    removeSyncCheck();\n                }\n            });\n            return removeSyncCheck;\n        };\n    }\n    const startAnimation = () => {\n        readyAnimation.cancel();\n        const appearAnimation = startWaapiAnimation(element, name, keyframes, options);\n        /**\n         * Record the time of the first started animation. We call performance.now() once\n         * here and once in handoff to ensure we're getting\n         * close to a frame-locked time. This keeps all animations in sync.\n         */\n        if (startFrameTime === undefined) {\n            startFrameTime = performance.now();\n        }\n        appearAnimation.startTime = startFrameTime;\n        appearAnimationStore.set(storeId, {\n            animation: appearAnimation,\n            startTime: startFrameTime,\n        });\n        if (onReady)\n            onReady(appearAnimation);\n    };\n    appearComplete.set(id, false);\n    if (readyAnimation.ready) {\n        readyAnimation.ready.then(startAnimation).catch(noop);\n    }\n    else {\n        startAnimation();\n    }\n}\n\nexport { startOptimizedAppearAnimation };\n"],"mappings":"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","ignoreList":[]},"targets":{},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/Users/anshul/Masters/Internship/POC/Meteor_Mobile/mieweb_push_auth","root":"/Users/anshul/Masters/Internship/POC/Meteor_Mobile/mieweb_push_auth","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true},"externalDependencies":[]},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.17.2","helpers":true,"useESModules":false,"corejs":false},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-react-jsx","visitor":{"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXFragment":{"exit":[null]},"JSXElement":{"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false},"externalDependencies":[]},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-nullish-coalescing-operator","visitor":{"LogicalExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-chaining","visitor":{"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-catch-binding","visitor":{"CatchClause":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"proposal-logical-assignment-operators","visitor":{"AssignmentExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]}],"presets":[],"generatorOpts":{"filename":"/Users/anshul/Masters/Internship/POC/Meteor_Mobile/mieweb_push_auth/node_modules/framer-motion/dist/es/animation/optimized-appear/start.mjs","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"node_modules/framer-motion/dist/es/animation/optimized-appear/start.mjs","inputSourceMap":{"version":3,"names":["appearStoreId","startWaapiAnimation","optimizedAppearDataId","handoffOptimizedAppearAnimation","appearAnimationStore","appearComplete","noop","getOptimisedAppearId","startFrameTime","readyAnimation","suspendedAnimations","Set","resumeSuspendedAnimations","forEach","data","animation","play","startTime","clear","startOptimizedAppearAnimation","element","name","keyframes","options","onReady","window","MotionIsMounted","id","dataset","MotionHandoffAnimation","storeId","duration","ease","set","MotionHasOptimisedAnimation","elementId","valueName","has","animationId","Boolean","get","MotionHandoffMarkAsComplete","MotionHandoffIsComplete","MotionCancelOptimisedAnimation","frame","canResume","undefined","postRender","cancel","add","render","delete","size","MotionCheckAppearSync","visualElement","value","_a","_b","appearId","valueIsOptimised","call","externalAnimationValue","props","values","removeSyncCheck","on","latestValue","startAnimation","appearAnimation","performance","now","ready","then","catch"],"sources":["node_modules/framer-motion/dist/es/animation/optimized-appear/start.mjs"],"sourcesContent":["import { appearStoreId } from './store-id.mjs';\nimport { startWaapiAnimation } from '../animators/waapi/index.mjs';\nimport { optimizedAppearDataId } from './data-id.mjs';\nimport { handoffOptimizedAppearAnimation } from './handoff.mjs';\nimport { appearAnimationStore, appearComplete } from './store.mjs';\nimport { noop } from 'motion-utils';\nimport { getOptimisedAppearId } from './get-appear-id.mjs';\n\n/**\n * A single time to use across all animations to manually set startTime\n * and ensure they're all in sync.\n */\nlet startFrameTime;\n/**\n * A dummy animation to detect when Chrome is ready to start\n * painting the page and hold off from triggering the real animation\n * until then. We only need one animation to detect paint ready.\n *\n * https://bugs.chromium.org/p/chromium/issues/detail?id=1406850\n */\nlet readyAnimation;\n/**\n * Keep track of animations that were suspended vs cancelled so we\n * can easily resume them when we're done measuring layout.\n */\nconst suspendedAnimations = new Set();\nfunction resumeSuspendedAnimations() {\n    suspendedAnimations.forEach((data) => {\n        data.animation.play();\n        data.animation.startTime = data.startTime;\n    });\n    suspendedAnimations.clear();\n}\nfunction startOptimizedAppearAnimation(element, name, keyframes, options, onReady) {\n    // Prevent optimised appear animations if Motion has already started animating.\n    if (window.MotionIsMounted) {\n        return;\n    }\n    const id = element.dataset[optimizedAppearDataId];\n    if (!id)\n        return;\n    window.MotionHandoffAnimation = handoffOptimizedAppearAnimation;\n    const storeId = appearStoreId(id, name);\n    if (!readyAnimation) {\n        readyAnimation = startWaapiAnimation(element, name, [keyframes[0], keyframes[0]], \n        /**\n         * 10 secs is basically just a super-safe duration to give Chrome\n         * long enough to get the animation ready.\n         */\n        { duration: 10000, ease: \"linear\" });\n        appearAnimationStore.set(storeId, {\n            animation: readyAnimation,\n            startTime: null,\n        });\n        /**\n         * If there's no readyAnimation then there's been no instantiation\n         * of handoff animations.\n         */\n        window.MotionHandoffAnimation = handoffOptimizedAppearAnimation;\n        window.MotionHasOptimisedAnimation = (elementId, valueName) => {\n            if (!elementId)\n                return false;\n            /**\n             * Keep a map of elementIds that have started animating. We check\n             * via ID instead of Element because of hydration errors and\n             * pre-hydration checks. We also actively record IDs as they start\n             * animating rather than simply checking for data-appear-id as\n             * this attrbute might be present but not lead to an animation, for\n             * instance if the element's appear animation is on a different\n             * breakpoint.\n             */\n            if (!valueName) {\n                return appearComplete.has(elementId);\n            }\n            const animationId = appearStoreId(elementId, valueName);\n            return Boolean(appearAnimationStore.get(animationId));\n        };\n        window.MotionHandoffMarkAsComplete = (elementId) => {\n            if (appearComplete.has(elementId)) {\n                appearComplete.set(elementId, true);\n            }\n        };\n        window.MotionHandoffIsComplete = (elementId) => {\n            return appearComplete.get(elementId) === true;\n        };\n        /**\n         * We only need to cancel transform animations as\n         * they're the ones that will interfere with the\n         * layout animation measurements.\n         */\n        window.MotionCancelOptimisedAnimation = (elementId, valueName, frame, canResume) => {\n            const animationId = appearStoreId(elementId, valueName);\n            const data = appearAnimationStore.get(animationId);\n            if (!data)\n                return;\n            if (frame && canResume === undefined) {\n                /**\n                 * Wait until the end of the subsequent frame to cancel the animation\n                 * to ensure we don't remove the animation before the main thread has\n                 * had a chance to resolve keyframes and render.\n                 */\n                frame.postRender(() => {\n                    frame.postRender(() => {\n                        data.animation.cancel();\n                    });\n                });\n            }\n            else {\n                data.animation.cancel();\n            }\n            if (frame && canResume) {\n                suspendedAnimations.add(data);\n                frame.render(resumeSuspendedAnimations);\n            }\n            else {\n                appearAnimationStore.delete(animationId);\n                /**\n                 * If there are no more animations left, we can remove the cancel function.\n                 * This will let us know when we can stop checking for conflicting layout animations.\n                 */\n                if (!appearAnimationStore.size) {\n                    window.MotionCancelOptimisedAnimation = undefined;\n                }\n            }\n        };\n        window.MotionCheckAppearSync = (visualElement, valueName, value) => {\n            var _a, _b;\n            const appearId = getOptimisedAppearId(visualElement);\n            if (!appearId)\n                return;\n            const valueIsOptimised = (_a = window.MotionHasOptimisedAnimation) === null || _a === void 0 ? void 0 : _a.call(window, appearId, valueName);\n            const externalAnimationValue = (_b = visualElement.props.values) === null || _b === void 0 ? void 0 : _b[valueName];\n            if (!valueIsOptimised || !externalAnimationValue)\n                return;\n            const removeSyncCheck = value.on(\"change\", (latestValue) => {\n                var _a;\n                if (externalAnimationValue.get() !== latestValue) {\n                    (_a = window.MotionCancelOptimisedAnimation) === null || _a === void 0 ? void 0 : _a.call(window, appearId, valueName);\n                    removeSyncCheck();\n                }\n            });\n            return removeSyncCheck;\n        };\n    }\n    const startAnimation = () => {\n        readyAnimation.cancel();\n        const appearAnimation = startWaapiAnimation(element, name, keyframes, options);\n        /**\n         * Record the time of the first started animation. We call performance.now() once\n         * here and once in handoff to ensure we're getting\n         * close to a frame-locked time. This keeps all animations in sync.\n         */\n        if (startFrameTime === undefined) {\n            startFrameTime = performance.now();\n        }\n        appearAnimation.startTime = startFrameTime;\n        appearAnimationStore.set(storeId, {\n            animation: appearAnimation,\n            startTime: startFrameTime,\n        });\n        if (onReady)\n            onReady(appearAnimation);\n    };\n    appearComplete.set(id, false);\n    if (readyAnimation.ready) {\n        readyAnimation.ready.then(startAnimation).catch(noop);\n    }\n    else {\n        startAnimation();\n    }\n}\n\nexport { startOptimizedAppearAnimation };\n"],"mappings":"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","ignoreList":[]}}},"code":"!function (module1) {\n  module1.export({\n    startOptimizedAppearAnimation: () => startOptimizedAppearAnimation\n  });\n  let appearStoreId;\n  module1.link(\"./store-id.mjs\", {\n    appearStoreId(v) {\n      appearStoreId = v;\n    }\n  }, 0);\n  let startWaapiAnimation;\n  module1.link(\"../animators/waapi/index.mjs\", {\n    startWaapiAnimation(v) {\n      startWaapiAnimation = v;\n    }\n  }, 1);\n  let optimizedAppearDataId;\n  module1.link(\"./data-id.mjs\", {\n    optimizedAppearDataId(v) {\n      optimizedAppearDataId = v;\n    }\n  }, 2);\n  let handoffOptimizedAppearAnimation;\n  module1.link(\"./handoff.mjs\", {\n    handoffOptimizedAppearAnimation(v) {\n      handoffOptimizedAppearAnimation = v;\n    }\n  }, 3);\n  let appearAnimationStore, appearComplete;\n  module1.link(\"./store.mjs\", {\n    appearAnimationStore(v) {\n      appearAnimationStore = v;\n    },\n    appearComplete(v) {\n      appearComplete = v;\n    }\n  }, 4);\n  let noop;\n  module1.link(\"motion-utils\", {\n    noop(v) {\n      noop = v;\n    }\n  }, 5);\n  let getOptimisedAppearId;\n  module1.link(\"./get-appear-id.mjs\", {\n    getOptimisedAppearId(v) {\n      getOptimisedAppearId = v;\n    }\n  }, 6);\n  ___INIT_METEOR_FAST_REFRESH(module);\n  /**\n   * A single time to use across all animations to manually set startTime\n   * and ensure they're all in sync.\n   */\n  let startFrameTime;\n  /**\n   * A dummy animation to detect when Chrome is ready to start\n   * painting the page and hold off from triggering the real animation\n   * until then. We only need one animation to detect paint ready.\n   *\n   * https://bugs.chromium.org/p/chromium/issues/detail?id=1406850\n   */\n  let readyAnimation;\n  /**\n   * Keep track of animations that were suspended vs cancelled so we\n   * can easily resume them when we're done measuring layout.\n   */\n  const suspendedAnimations = new Set();\n  function resumeSuspendedAnimations() {\n    suspendedAnimations.forEach(data => {\n      data.animation.play();\n      data.animation.startTime = data.startTime;\n    });\n    suspendedAnimations.clear();\n  }\n  function startOptimizedAppearAnimation(element, name, keyframes, options, onReady) {\n    // Prevent optimised appear animations if Motion has already started animating.\n    if (window.MotionIsMounted) {\n      return;\n    }\n    const id = element.dataset[optimizedAppearDataId];\n    if (!id) return;\n    window.MotionHandoffAnimation = handoffOptimizedAppearAnimation;\n    const storeId = appearStoreId(id, name);\n    if (!readyAnimation) {\n      readyAnimation = startWaapiAnimation(element, name, [keyframes[0], keyframes[0]],\n      /**\n       * 10 secs is basically just a super-safe duration to give Chrome\n       * long enough to get the animation ready.\n       */\n      {\n        duration: 10000,\n        ease: \"linear\"\n      });\n      appearAnimationStore.set(storeId, {\n        animation: readyAnimation,\n        startTime: null\n      });\n      /**\n       * If there's no readyAnimation then there's been no instantiation\n       * of handoff animations.\n       */\n      window.MotionHandoffAnimation = handoffOptimizedAppearAnimation;\n      window.MotionHasOptimisedAnimation = (elementId, valueName) => {\n        if (!elementId) return false;\n        /**\n         * Keep a map of elementIds that have started animating. We check\n         * via ID instead of Element because of hydration errors and\n         * pre-hydration checks. We also actively record IDs as they start\n         * animating rather than simply checking for data-appear-id as\n         * this attrbute might be present but not lead to an animation, for\n         * instance if the element's appear animation is on a different\n         * breakpoint.\n         */\n        if (!valueName) {\n          return appearComplete.has(elementId);\n        }\n        const animationId = appearStoreId(elementId, valueName);\n        return Boolean(appearAnimationStore.get(animationId));\n      };\n      window.MotionHandoffMarkAsComplete = elementId => {\n        if (appearComplete.has(elementId)) {\n          appearComplete.set(elementId, true);\n        }\n      };\n      window.MotionHandoffIsComplete = elementId => {\n        return appearComplete.get(elementId) === true;\n      };\n      /**\n       * We only need to cancel transform animations as\n       * they're the ones that will interfere with the\n       * layout animation measurements.\n       */\n      window.MotionCancelOptimisedAnimation = (elementId, valueName, frame, canResume) => {\n        const animationId = appearStoreId(elementId, valueName);\n        const data = appearAnimationStore.get(animationId);\n        if (!data) return;\n        if (frame && canResume === undefined) {\n          /**\n           * Wait until the end of the subsequent frame to cancel the animation\n           * to ensure we don't remove the animation before the main thread has\n           * had a chance to resolve keyframes and render.\n           */\n          frame.postRender(() => {\n            frame.postRender(() => {\n              data.animation.cancel();\n            });\n          });\n        } else {\n          data.animation.cancel();\n        }\n        if (frame && canResume) {\n          suspendedAnimations.add(data);\n          frame.render(resumeSuspendedAnimations);\n        } else {\n          appearAnimationStore.delete(animationId);\n          /**\n           * If there are no more animations left, we can remove the cancel function.\n           * This will let us know when we can stop checking for conflicting layout animations.\n           */\n          if (!appearAnimationStore.size) {\n            window.MotionCancelOptimisedAnimation = undefined;\n          }\n        }\n      };\n      window.MotionCheckAppearSync = (visualElement, valueName, value) => {\n        var _a, _b;\n        const appearId = getOptimisedAppearId(visualElement);\n        if (!appearId) return;\n        const valueIsOptimised = (_a = window.MotionHasOptimisedAnimation) === null || _a === void 0 ? void 0 : _a.call(window, appearId, valueName);\n        const externalAnimationValue = (_b = visualElement.props.values) === null || _b === void 0 ? void 0 : _b[valueName];\n        if (!valueIsOptimised || !externalAnimationValue) return;\n        const removeSyncCheck = value.on(\"change\", latestValue => {\n          var _a;\n          if (externalAnimationValue.get() !== latestValue) {\n            (_a = window.MotionCancelOptimisedAnimation) === null || _a === void 0 ? void 0 : _a.call(window, appearId, valueName);\n            removeSyncCheck();\n          }\n        });\n        return removeSyncCheck;\n      };\n    }\n    const startAnimation = () => {\n      readyAnimation.cancel();\n      const appearAnimation = startWaapiAnimation(element, name, keyframes, options);\n      /**\n       * Record the time of the first started animation. We call performance.now() once\n       * here and once in handoff to ensure we're getting\n       * close to a frame-locked time. This keeps all animations in sync.\n       */\n      if (startFrameTime === undefined) {\n        startFrameTime = performance.now();\n      }\n      appearAnimation.startTime = startFrameTime;\n      appearAnimationStore.set(storeId, {\n        animation: appearAnimation,\n        startTime: startFrameTime\n      });\n      if (onReady) onReady(appearAnimation);\n    };\n    appearComplete.set(id, false);\n    if (readyAnimation.ready) {\n      readyAnimation.ready.then(startAnimation).catch(noop);\n    } else {\n      startAnimation();\n    }\n  }\n}.call(this, module);","map":{"version":3,"names":["startFrameTime","readyAnimation","suspendedAnimations","Set","resumeSuspendedAnimations","forEach","data","animation","play","startTime","clear","startOptimizedAppearAnimation","element","name","keyframes","options","onReady","window","MotionIsMounted","id","dataset","optimizedAppearDataId","MotionHandoffAnimation","handoffOptimizedAppearAnimation","storeId","appearStoreId","startWaapiAnimation","duration","ease","appearAnimationStore","set","MotionHasOptimisedAnimation","elementId","valueName","appearComplete","has","animationId","Boolean","get","MotionHandoffMarkAsComplete","MotionHandoffIsComplete","MotionCancelOptimisedAnimation","frame","canResume","undefined","postRender","cancel","add","render","delete","size","MotionCheckAppearSync","visualElement","value","_a","_b","appearId","getOptimisedAppearId","valueIsOptimised","call","externalAnimationValue","props","values","removeSyncCheck","on","latestValue","startAnimation","appearAnimation","performance","now","ready","then","catch","noop","module"],"sources":["node_modules/framer-motion/dist/es/animation/optimized-appear/start.mjs"],"sourcesContent":["import { appearStoreId } from './store-id.mjs';\nimport { startWaapiAnimation } from '../animators/waapi/index.mjs';\nimport { optimizedAppearDataId } from './data-id.mjs';\nimport { handoffOptimizedAppearAnimation } from './handoff.mjs';\nimport { appearAnimationStore, appearComplete } from './store.mjs';\nimport { noop } from 'motion-utils';\nimport { getOptimisedAppearId } from './get-appear-id.mjs';\n\n/**\n * A single time to use across all animations to manually set startTime\n * and ensure they're all in sync.\n */\nlet startFrameTime;\n/**\n * A dummy animation to detect when Chrome is ready to start\n * painting the page and hold off from triggering the real animation\n * until then. We only need one animation to detect paint ready.\n *\n * https://bugs.chromium.org/p/chromium/issues/detail?id=1406850\n */\nlet readyAnimation;\n/**\n * Keep track of animations that were suspended vs cancelled so we\n * can easily resume them when we're done measuring layout.\n */\nconst suspendedAnimations = new Set();\nfunction resumeSuspendedAnimations() {\n    suspendedAnimations.forEach((data) => {\n        data.animation.play();\n        data.animation.startTime = data.startTime;\n    });\n    suspendedAnimations.clear();\n}\nfunction startOptimizedAppearAnimation(element, name, keyframes, options, onReady) {\n    // Prevent optimised appear animations if Motion has already started animating.\n    if (window.MotionIsMounted) {\n        return;\n    }\n    const id = element.dataset[optimizedAppearDataId];\n    if (!id)\n        return;\n    window.MotionHandoffAnimation = handoffOptimizedAppearAnimation;\n    const storeId = appearStoreId(id, name);\n    if (!readyAnimation) {\n        readyAnimation = startWaapiAnimation(element, name, [keyframes[0], keyframes[0]], \n        /**\n         * 10 secs is basically just a super-safe duration to give Chrome\n         * long enough to get the animation ready.\n         */\n        { duration: 10000, ease: \"linear\" });\n        appearAnimationStore.set(storeId, {\n            animation: readyAnimation,\n            startTime: null,\n        });\n        /**\n         * If there's no readyAnimation then there's been no instantiation\n         * of handoff animations.\n         */\n        window.MotionHandoffAnimation = handoffOptimizedAppearAnimation;\n        window.MotionHasOptimisedAnimation = (elementId, valueName) => {\n            if (!elementId)\n                return false;\n            /**\n             * Keep a map of elementIds that have started animating. We check\n             * via ID instead of Element because of hydration errors and\n             * pre-hydration checks. We also actively record IDs as they start\n             * animating rather than simply checking for data-appear-id as\n             * this attrbute might be present but not lead to an animation, for\n             * instance if the element's appear animation is on a different\n             * breakpoint.\n             */\n            if (!valueName) {\n                return appearComplete.has(elementId);\n            }\n            const animationId = appearStoreId(elementId, valueName);\n            return Boolean(appearAnimationStore.get(animationId));\n        };\n        window.MotionHandoffMarkAsComplete = (elementId) => {\n            if (appearComplete.has(elementId)) {\n                appearComplete.set(elementId, true);\n            }\n        };\n        window.MotionHandoffIsComplete = (elementId) => {\n            return appearComplete.get(elementId) === true;\n        };\n        /**\n         * We only need to cancel transform animations as\n         * they're the ones that will interfere with the\n         * layout animation measurements.\n         */\n        window.MotionCancelOptimisedAnimation = (elementId, valueName, frame, canResume) => {\n            const animationId = appearStoreId(elementId, valueName);\n            const data = appearAnimationStore.get(animationId);\n            if (!data)\n                return;\n            if (frame && canResume === undefined) {\n                /**\n                 * Wait until the end of the subsequent frame to cancel the animation\n                 * to ensure we don't remove the animation before the main thread has\n                 * had a chance to resolve keyframes and render.\n                 */\n                frame.postRender(() => {\n                    frame.postRender(() => {\n                        data.animation.cancel();\n                    });\n                });\n            }\n            else {\n                data.animation.cancel();\n            }\n            if (frame && canResume) {\n                suspendedAnimations.add(data);\n                frame.render(resumeSuspendedAnimations);\n            }\n            else {\n                appearAnimationStore.delete(animationId);\n                /**\n                 * If there are no more animations left, we can remove the cancel function.\n                 * This will let us know when we can stop checking for conflicting layout animations.\n                 */\n                if (!appearAnimationStore.size) {\n                    window.MotionCancelOptimisedAnimation = undefined;\n                }\n            }\n        };\n        window.MotionCheckAppearSync = (visualElement, valueName, value) => {\n            var _a, _b;\n            const appearId = getOptimisedAppearId(visualElement);\n            if (!appearId)\n                return;\n            const valueIsOptimised = (_a = window.MotionHasOptimisedAnimation) === null || _a === void 0 ? void 0 : _a.call(window, appearId, valueName);\n            const externalAnimationValue = (_b = visualElement.props.values) === null || _b === void 0 ? void 0 : _b[valueName];\n            if (!valueIsOptimised || !externalAnimationValue)\n                return;\n            const removeSyncCheck = value.on(\"change\", (latestValue) => {\n                var _a;\n                if (externalAnimationValue.get() !== latestValue) {\n                    (_a = window.MotionCancelOptimisedAnimation) === null || _a === void 0 ? void 0 : _a.call(window, appearId, valueName);\n                    removeSyncCheck();\n                }\n            });\n            return removeSyncCheck;\n        };\n    }\n    const startAnimation = () => {\n        readyAnimation.cancel();\n        const appearAnimation = startWaapiAnimation(element, name, keyframes, options);\n        /**\n         * Record the time of the first started animation. We call performance.now() once\n         * here and once in handoff to ensure we're getting\n         * close to a frame-locked time. This keeps all animations in sync.\n         */\n        if (startFrameTime === undefined) {\n            startFrameTime = performance.now();\n        }\n        appearAnimation.startTime = startFrameTime;\n        appearAnimationStore.set(storeId, {\n            animation: appearAnimation,\n            startTime: startFrameTime,\n        });\n        if (onReady)\n            onReady(appearAnimation);\n    };\n    appearComplete.set(id, false);\n    if (readyAnimation.ready) {\n        readyAnimation.ready.then(startAnimation).catch(noop);\n    }\n    else {\n        startAnimation();\n    }\n}\n\nexport { startOptimizedAppearAnimation };\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAQA;AACA;AACA;AACA;EACA,IAAIA,cAAc;EAClB;AACA;AACA;AACA;AACA;AACA;AACA;EACA,IAAIC,cAAc;EAClB;AACA;AACA;AACA;EACA,MAAMC,mBAAmB,GAAG,IAAIC,GAAG,CAAC,CAAC;EACrC,SAASC,yBAAyBA,CAAA,EAAG;IACjCF,mBAAmB,CAACG,OAAO,CAAEC,IAAI,IAAK;MAClCA,IAAI,CAACC,SAAS,CAACC,IAAI,CAAC,CAAC;MACrBF,IAAI,CAACC,SAAS,CAACE,SAAS,GAAGH,IAAI,CAACG,SAAS;IAC7C,CAAC,CAAC;IACFP,mBAAmB,CAACQ,KAAK,CAAC,CAAC;EAC/B;EACA,SAASC,6BAA6BA,CAACC,OAAO,EAAEC,IAAI,EAAEC,SAAS,EAAEC,OAAO,EAAEC,OAAO,EAAE;IAC/E;IACA,IAAIC,MAAM,CAACC,eAAe,EAAE;MACxB;IACJ;IACA,MAAMC,EAAE,GAAGP,OAAO,CAACQ,OAAO,CAACC,qBAAqB,CAAC;IACjD,IAAI,CAACF,EAAE,EACH;IACJF,MAAM,CAACK,sBAAsB,GAAGC,+BAA+B;IAC/D,MAAMC,OAAO,GAAGC,aAAa,CAACN,EAAE,EAAEN,IAAI,CAAC;IACvC,IAAI,CAACZ,cAAc,EAAE;MACjBA,cAAc,GAAGyB,mBAAmB,CAACd,OAAO,EAAEC,IAAI,EAAE,CAACC,SAAS,CAAC,CAAC,CAAC,EAAEA,SAAS,CAAC,CAAC,CAAC,CAAC;MAChF;AACR;AACA;AACA;MACQ;QAAEa,QAAQ,EAAE,KAAK;QAAEC,IAAI,EAAE;MAAS,CAAC,CAAC;MACpCC,oBAAoB,CAACC,GAAG,CAACN,OAAO,EAAE;QAC9BjB,SAAS,EAAEN,cAAc;QACzBQ,SAAS,EAAE;MACf,CAAC,CAAC;MACF;AACR;AACA;AACA;MACQQ,MAAM,CAACK,sBAAsB,GAAGC,+BAA+B;MAC/DN,MAAM,CAACc,2BAA2B,GAAG,CAACC,SAAS,EAAEC,SAAS,KAAK;QAC3D,IAAI,CAACD,SAAS,EACV,OAAO,KAAK;QAChB;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;QACY,IAAI,CAACC,SAAS,EAAE;UACZ,OAAOC,cAAc,CAACC,GAAG,CAACH,SAAS,CAAC;QACxC;QACA,MAAMI,WAAW,GAAGX,aAAa,CAACO,SAAS,EAAEC,SAAS,CAAC;QACvD,OAAOI,OAAO,CAACR,oBAAoB,CAACS,GAAG,CAACF,WAAW,CAAC,CAAC;MACzD,CAAC;MACDnB,MAAM,CAACsB,2BAA2B,GAAIP,SAAS,IAAK;QAChD,IAAIE,cAAc,CAACC,GAAG,CAACH,SAAS,CAAC,EAAE;UAC/BE,cAAc,CAACJ,GAAG,CAACE,SAAS,EAAE,IAAI,CAAC;QACvC;MACJ,CAAC;MACDf,MAAM,CAACuB,uBAAuB,GAAIR,SAAS,IAAK;QAC5C,OAAOE,cAAc,CAACI,GAAG,CAACN,SAAS,CAAC,KAAK,IAAI;MACjD,CAAC;MACD;AACR;AACA;AACA;AACA;MACQf,MAAM,CAACwB,8BAA8B,GAAG,CAACT,SAAS,EAAEC,SAAS,EAAES,KAAK,EAAEC,SAAS,KAAK;QAChF,MAAMP,WAAW,GAAGX,aAAa,CAACO,SAAS,EAAEC,SAAS,CAAC;QACvD,MAAM3B,IAAI,GAAGuB,oBAAoB,CAACS,GAAG,CAACF,WAAW,CAAC;QAClD,IAAI,CAAC9B,IAAI,EACL;QACJ,IAAIoC,KAAK,IAAIC,SAAS,KAAKC,SAAS,EAAE;UAClC;AAChB;AACA;AACA;AACA;UACgBF,KAAK,CAACG,UAAU,CAAC,MAAM;YACnBH,KAAK,CAACG,UAAU,CAAC,MAAM;cACnBvC,IAAI,CAACC,SAAS,CAACuC,MAAM,CAAC,CAAC;YAC3B,CAAC,CAAC;UACN,CAAC,CAAC;QACN,CAAC,MACI;UACDxC,IAAI,CAACC,SAAS,CAACuC,MAAM,CAAC,CAAC;QAC3B;QACA,IAAIJ,KAAK,IAAIC,SAAS,EAAE;UACpBzC,mBAAmB,CAAC6C,GAAG,CAACzC,IAAI,CAAC;UAC7BoC,KAAK,CAACM,MAAM,CAAC5C,yBAAyB,CAAC;QAC3C,CAAC,MACI;UACDyB,oBAAoB,CAACoB,MAAM,CAACb,WAAW,CAAC;UACxC;AAChB;AACA;AACA;UACgB,IAAI,CAACP,oBAAoB,CAACqB,IAAI,EAAE;YAC5BjC,MAAM,CAACwB,8BAA8B,GAAGG,SAAS;UACrD;QACJ;MACJ,CAAC;MACD3B,MAAM,CAACkC,qBAAqB,GAAG,CAACC,aAAa,EAAEnB,SAAS,EAAEoB,KAAK,KAAK;QAChE,IAAIC,EAAE,EAAEC,EAAE;QACV,MAAMC,QAAQ,GAAGC,oBAAoB,CAACL,aAAa,CAAC;QACpD,IAAI,CAACI,QAAQ,EACT;QACJ,MAAME,gBAAgB,GAAG,CAACJ,EAAE,GAAGrC,MAAM,CAACc,2BAA2B,MAAM,IAAI,IAAIuB,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACK,IAAI,CAAC1C,MAAM,EAAEuC,QAAQ,EAAEvB,SAAS,CAAC;QAC5I,MAAM2B,sBAAsB,GAAG,CAACL,EAAE,GAAGH,aAAa,CAACS,KAAK,CAACC,MAAM,MAAM,IAAI,IAAIP,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACtB,SAAS,CAAC;QACnH,IAAI,CAACyB,gBAAgB,IAAI,CAACE,sBAAsB,EAC5C;QACJ,MAAMG,eAAe,GAAGV,KAAK,CAACW,EAAE,CAAC,QAAQ,EAAGC,WAAW,IAAK;UACxD,IAAIX,EAAE;UACN,IAAIM,sBAAsB,CAACtB,GAAG,CAAC,CAAC,KAAK2B,WAAW,EAAE;YAC9C,CAACX,EAAE,GAAGrC,MAAM,CAACwB,8BAA8B,MAAM,IAAI,IAAIa,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACK,IAAI,CAAC1C,MAAM,EAAEuC,QAAQ,EAAEvB,SAAS,CAAC;YACtH8B,eAAe,CAAC,CAAC;UACrB;QACJ,CAAC,CAAC;QACF,OAAOA,eAAe;MAC1B,CAAC;IACL;IACA,MAAMG,cAAc,GAAGA,CAAA,KAAM;MACzBjE,cAAc,CAAC6C,MAAM,CAAC,CAAC;MACvB,MAAMqB,eAAe,GAAGzC,mBAAmB,CAACd,OAAO,EAAEC,IAAI,EAAEC,SAAS,EAAEC,OAAO,CAAC;MAC9E;AACR;AACA;AACA;AACA;MACQ,IAAIf,cAAc,KAAK4C,SAAS,EAAE;QAC9B5C,cAAc,GAAGoE,WAAW,CAACC,GAAG,CAAC,CAAC;MACtC;MACAF,eAAe,CAAC1D,SAAS,GAAGT,cAAc;MAC1C6B,oBAAoB,CAACC,GAAG,CAACN,OAAO,EAAE;QAC9BjB,SAAS,EAAE4D,eAAe;QAC1B1D,SAAS,EAAET;MACf,CAAC,CAAC;MACF,IAAIgB,OAAO,EACPA,OAAO,CAACmD,eAAe,CAAC;IAChC,CAAC;IACDjC,cAAc,CAACJ,GAAG,CAACX,EAAE,EAAE,KAAK,CAAC;IAC7B,IAAIlB,cAAc,CAACqE,KAAK,EAAE;MACtBrE,cAAc,CAACqE,KAAK,CAACC,IAAI,CAACL,cAAc,CAAC,CAACM,KAAK,CAACC,IAAI,CAAC;IACzD,CAAC,MACI;MACDP,cAAc,CAAC,CAAC;IACpB;EACJ;AAAA,EAAAP,IAAA,OAAAe,MAAA","ignoreList":[]},"sourceType":"module","externalDependencies":{},"hash":"721fc190953164cc160e6f4766dd0489755186fb"}
