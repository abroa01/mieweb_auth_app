{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/anshul/Masters/Internship/POC/Meteor_Mobile/mieweb_push_auth/node_modules/framer-motion/dist/es/render/dom/scroll/offsets/index.mjs","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","topLevelAwait","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"web.browser"},"sourceFileName":"node_modules/framer-motion/dist/es/render/dom/scroll/offsets/index.mjs","filename":"/Users/anshul/Masters/Internship/POC/Meteor_Mobile/mieweb_push_auth/node_modules/framer-motion/dist/es/render/dom/scroll/offsets/index.mjs","inputSourceMap":{"version":3,"names":["calcInset","ScrollOffset","resolveOffset","interpolate","defaultOffset","point","x","y","getTargetSize","target","tagName","getBBox","width","clientWidth","height","clientHeight","resolveOffsets","container","info","options","offset","offsetDefinition","All","axis","lengthLabel","inset","targetSize","scrollWidth","scrollHeight","containerSize","length","hasChanged","numOffsets","i","interpolatorOffsets","progress","current"],"sources":["node_modules/framer-motion/dist/es/render/dom/scroll/offsets/index.mjs"],"sourcesContent":["import { calcInset } from './inset.mjs';\nimport { ScrollOffset } from './presets.mjs';\nimport { resolveOffset } from './offset.mjs';\nimport { interpolate } from '../../../../utils/interpolate.mjs';\nimport { defaultOffset } from '../../../../utils/offsets/default.mjs';\n\nconst point = { x: 0, y: 0 };\nfunction getTargetSize(target) {\n    return \"getBBox\" in target && target.tagName !== \"svg\"\n        ? target.getBBox()\n        : { width: target.clientWidth, height: target.clientHeight };\n}\nfunction resolveOffsets(container, info, options) {\n    const { offset: offsetDefinition = ScrollOffset.All } = options;\n    const { target = container, axis = \"y\" } = options;\n    const lengthLabel = axis === \"y\" ? \"height\" : \"width\";\n    const inset = target !== container ? calcInset(target, container) : point;\n    /**\n     * Measure the target and container. If they're the same thing then we\n     * use the container's scrollWidth/Height as the target, from there\n     * all other calculations can remain the same.\n     */\n    const targetSize = target === container\n        ? { width: container.scrollWidth, height: container.scrollHeight }\n        : getTargetSize(target);\n    const containerSize = {\n        width: container.clientWidth,\n        height: container.clientHeight,\n    };\n    /**\n     * Reset the length of the resolved offset array rather than creating a new one.\n     * TODO: More reusable data structures for targetSize/containerSize would also be good.\n     */\n    info[axis].offset.length = 0;\n    /**\n     * Populate the offset array by resolving the user's offset definition into\n     * a list of pixel scroll offets.\n     */\n    let hasChanged = !info[axis].interpolate;\n    const numOffsets = offsetDefinition.length;\n    for (let i = 0; i < numOffsets; i++) {\n        const offset = resolveOffset(offsetDefinition[i], containerSize[lengthLabel], targetSize[lengthLabel], inset[axis]);\n        if (!hasChanged && offset !== info[axis].interpolatorOffsets[i]) {\n            hasChanged = true;\n        }\n        info[axis].offset[i] = offset;\n    }\n    /**\n     * If the pixel scroll offsets have changed, create a new interpolator function\n     * to map scroll value into a progress.\n     */\n    if (hasChanged) {\n        info[axis].interpolate = interpolate(info[axis].offset, defaultOffset(offsetDefinition));\n        info[axis].interpolatorOffsets = [...info[axis].offset];\n    }\n    info[axis].progress = info[axis].interpolate(info[axis].current);\n}\n\nexport { resolveOffsets };\n"],"mappings":"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","ignoreList":[]},"targets":{},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/Users/anshul/Masters/Internship/POC/Meteor_Mobile/mieweb_push_auth","root":"/Users/anshul/Masters/Internship/POC/Meteor_Mobile/mieweb_push_auth","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true},"externalDependencies":[]},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.17.2","helpers":true,"useESModules":false,"corejs":false},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-react-jsx","visitor":{"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXFragment":{"exit":[null]},"JSXElement":{"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false},"externalDependencies":[]},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-nullish-coalescing-operator","visitor":{"LogicalExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-chaining","visitor":{"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-catch-binding","visitor":{"CatchClause":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"proposal-logical-assignment-operators","visitor":{"AssignmentExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]}],"presets":[],"generatorOpts":{"filename":"/Users/anshul/Masters/Internship/POC/Meteor_Mobile/mieweb_push_auth/node_modules/framer-motion/dist/es/render/dom/scroll/offsets/index.mjs","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"node_modules/framer-motion/dist/es/render/dom/scroll/offsets/index.mjs","inputSourceMap":{"version":3,"names":["calcInset","ScrollOffset","resolveOffset","interpolate","defaultOffset","point","x","y","getTargetSize","target","tagName","getBBox","width","clientWidth","height","clientHeight","resolveOffsets","container","info","options","offset","offsetDefinition","All","axis","lengthLabel","inset","targetSize","scrollWidth","scrollHeight","containerSize","length","hasChanged","numOffsets","i","interpolatorOffsets","progress","current"],"sources":["node_modules/framer-motion/dist/es/render/dom/scroll/offsets/index.mjs"],"sourcesContent":["import { calcInset } from './inset.mjs';\nimport { ScrollOffset } from './presets.mjs';\nimport { resolveOffset } from './offset.mjs';\nimport { interpolate } from '../../../../utils/interpolate.mjs';\nimport { defaultOffset } from '../../../../utils/offsets/default.mjs';\n\nconst point = { x: 0, y: 0 };\nfunction getTargetSize(target) {\n    return \"getBBox\" in target && target.tagName !== \"svg\"\n        ? target.getBBox()\n        : { width: target.clientWidth, height: target.clientHeight };\n}\nfunction resolveOffsets(container, info, options) {\n    const { offset: offsetDefinition = ScrollOffset.All } = options;\n    const { target = container, axis = \"y\" } = options;\n    const lengthLabel = axis === \"y\" ? \"height\" : \"width\";\n    const inset = target !== container ? calcInset(target, container) : point;\n    /**\n     * Measure the target and container. If they're the same thing then we\n     * use the container's scrollWidth/Height as the target, from there\n     * all other calculations can remain the same.\n     */\n    const targetSize = target === container\n        ? { width: container.scrollWidth, height: container.scrollHeight }\n        : getTargetSize(target);\n    const containerSize = {\n        width: container.clientWidth,\n        height: container.clientHeight,\n    };\n    /**\n     * Reset the length of the resolved offset array rather than creating a new one.\n     * TODO: More reusable data structures for targetSize/containerSize would also be good.\n     */\n    info[axis].offset.length = 0;\n    /**\n     * Populate the offset array by resolving the user's offset definition into\n     * a list of pixel scroll offets.\n     */\n    let hasChanged = !info[axis].interpolate;\n    const numOffsets = offsetDefinition.length;\n    for (let i = 0; i < numOffsets; i++) {\n        const offset = resolveOffset(offsetDefinition[i], containerSize[lengthLabel], targetSize[lengthLabel], inset[axis]);\n        if (!hasChanged && offset !== info[axis].interpolatorOffsets[i]) {\n            hasChanged = true;\n        }\n        info[axis].offset[i] = offset;\n    }\n    /**\n     * If the pixel scroll offsets have changed, create a new interpolator function\n     * to map scroll value into a progress.\n     */\n    if (hasChanged) {\n        info[axis].interpolate = interpolate(info[axis].offset, defaultOffset(offsetDefinition));\n        info[axis].interpolatorOffsets = [...info[axis].offset];\n    }\n    info[axis].progress = info[axis].interpolate(info[axis].current);\n}\n\nexport { resolveOffsets };\n"],"mappings":"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","ignoreList":[]}}},"code":"!function (module1) {\n  module1.export({\n    resolveOffsets: () => resolveOffsets\n  });\n  let calcInset;\n  module1.link(\"./inset.mjs\", {\n    calcInset(v) {\n      calcInset = v;\n    }\n  }, 0);\n  let ScrollOffset;\n  module1.link(\"./presets.mjs\", {\n    ScrollOffset(v) {\n      ScrollOffset = v;\n    }\n  }, 1);\n  let resolveOffset;\n  module1.link(\"./offset.mjs\", {\n    resolveOffset(v) {\n      resolveOffset = v;\n    }\n  }, 2);\n  let interpolate;\n  module1.link(\"../../../../utils/interpolate.mjs\", {\n    interpolate(v) {\n      interpolate = v;\n    }\n  }, 3);\n  let defaultOffset;\n  module1.link(\"../../../../utils/offsets/default.mjs\", {\n    defaultOffset(v) {\n      defaultOffset = v;\n    }\n  }, 4);\n  ___INIT_METEOR_FAST_REFRESH(module);\n  const point = {\n    x: 0,\n    y: 0\n  };\n  function getTargetSize(target) {\n    return \"getBBox\" in target && target.tagName !== \"svg\" ? target.getBBox() : {\n      width: target.clientWidth,\n      height: target.clientHeight\n    };\n  }\n  function resolveOffsets(container, info, options) {\n    const {\n      offset: offsetDefinition = ScrollOffset.All\n    } = options;\n    const {\n      target = container,\n      axis = \"y\"\n    } = options;\n    const lengthLabel = axis === \"y\" ? \"height\" : \"width\";\n    const inset = target !== container ? calcInset(target, container) : point;\n    /**\n     * Measure the target and container. If they're the same thing then we\n     * use the container's scrollWidth/Height as the target, from there\n     * all other calculations can remain the same.\n     */\n    const targetSize = target === container ? {\n      width: container.scrollWidth,\n      height: container.scrollHeight\n    } : getTargetSize(target);\n    const containerSize = {\n      width: container.clientWidth,\n      height: container.clientHeight\n    };\n    /**\n     * Reset the length of the resolved offset array rather than creating a new one.\n     * TODO: More reusable data structures for targetSize/containerSize would also be good.\n     */\n    info[axis].offset.length = 0;\n    /**\n     * Populate the offset array by resolving the user's offset definition into\n     * a list of pixel scroll offets.\n     */\n    let hasChanged = !info[axis].interpolate;\n    const numOffsets = offsetDefinition.length;\n    for (let i = 0; i < numOffsets; i++) {\n      const offset = resolveOffset(offsetDefinition[i], containerSize[lengthLabel], targetSize[lengthLabel], inset[axis]);\n      if (!hasChanged && offset !== info[axis].interpolatorOffsets[i]) {\n        hasChanged = true;\n      }\n      info[axis].offset[i] = offset;\n    }\n    /**\n     * If the pixel scroll offsets have changed, create a new interpolator function\n     * to map scroll value into a progress.\n     */\n    if (hasChanged) {\n      info[axis].interpolate = interpolate(info[axis].offset, defaultOffset(offsetDefinition));\n      info[axis].interpolatorOffsets = [...info[axis].offset];\n    }\n    info[axis].progress = info[axis].interpolate(info[axis].current);\n  }\n}.call(this, module);","map":{"version":3,"names":["point","x","y","getTargetSize","target","tagName","getBBox","width","clientWidth","height","clientHeight","resolveOffsets","container","info","options","offset","offsetDefinition","ScrollOffset","All","axis","lengthLabel","inset","calcInset","targetSize","scrollWidth","scrollHeight","containerSize","length","hasChanged","interpolate","numOffsets","i","resolveOffset","interpolatorOffsets","defaultOffset","progress","current","call","module"],"sources":["node_modules/framer-motion/dist/es/render/dom/scroll/offsets/index.mjs"],"sourcesContent":["import { calcInset } from './inset.mjs';\nimport { ScrollOffset } from './presets.mjs';\nimport { resolveOffset } from './offset.mjs';\nimport { interpolate } from '../../../../utils/interpolate.mjs';\nimport { defaultOffset } from '../../../../utils/offsets/default.mjs';\n\nconst point = { x: 0, y: 0 };\nfunction getTargetSize(target) {\n    return \"getBBox\" in target && target.tagName !== \"svg\"\n        ? target.getBBox()\n        : { width: target.clientWidth, height: target.clientHeight };\n}\nfunction resolveOffsets(container, info, options) {\n    const { offset: offsetDefinition = ScrollOffset.All } = options;\n    const { target = container, axis = \"y\" } = options;\n    const lengthLabel = axis === \"y\" ? \"height\" : \"width\";\n    const inset = target !== container ? calcInset(target, container) : point;\n    /**\n     * Measure the target and container. If they're the same thing then we\n     * use the container's scrollWidth/Height as the target, from there\n     * all other calculations can remain the same.\n     */\n    const targetSize = target === container\n        ? { width: container.scrollWidth, height: container.scrollHeight }\n        : getTargetSize(target);\n    const containerSize = {\n        width: container.clientWidth,\n        height: container.clientHeight,\n    };\n    /**\n     * Reset the length of the resolved offset array rather than creating a new one.\n     * TODO: More reusable data structures for targetSize/containerSize would also be good.\n     */\n    info[axis].offset.length = 0;\n    /**\n     * Populate the offset array by resolving the user's offset definition into\n     * a list of pixel scroll offets.\n     */\n    let hasChanged = !info[axis].interpolate;\n    const numOffsets = offsetDefinition.length;\n    for (let i = 0; i < numOffsets; i++) {\n        const offset = resolveOffset(offsetDefinition[i], containerSize[lengthLabel], targetSize[lengthLabel], inset[axis]);\n        if (!hasChanged && offset !== info[axis].interpolatorOffsets[i]) {\n            hasChanged = true;\n        }\n        info[axis].offset[i] = offset;\n    }\n    /**\n     * If the pixel scroll offsets have changed, create a new interpolator function\n     * to map scroll value into a progress.\n     */\n    if (hasChanged) {\n        info[axis].interpolate = interpolate(info[axis].offset, defaultOffset(offsetDefinition));\n        info[axis].interpolatorOffsets = [...info[axis].offset];\n    }\n    info[axis].progress = info[axis].interpolate(info[axis].current);\n}\n\nexport { resolveOffsets };\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAMA,MAAMA,KAAK,GAAG;IAAEC,CAAC,EAAE,CAAC;IAAEC,CAAC,EAAE;EAAE,CAAC;EAC5B,SAASC,aAAaA,CAACC,MAAM,EAAE;IAC3B,OAAO,SAAS,IAAIA,MAAM,IAAIA,MAAM,CAACC,OAAO,KAAK,KAAK,GAChDD,MAAM,CAACE,OAAO,CAAC,CAAC,GAChB;MAAEC,KAAK,EAAEH,MAAM,CAACI,WAAW;MAAEC,MAAM,EAAEL,MAAM,CAACM;IAAa,CAAC;EACpE;EACA,SAASC,cAAcA,CAACC,SAAS,EAAEC,IAAI,EAAEC,OAAO,EAAE;IAC9C,MAAM;MAAEC,MAAM,EAAEC,gBAAgB,GAAGC,YAAY,CAACC;IAAI,CAAC,GAAGJ,OAAO;IAC/D,MAAM;MAAEV,MAAM,GAAGQ,SAAS;MAAEO,IAAI,GAAG;IAAI,CAAC,GAAGL,OAAO;IAClD,MAAMM,WAAW,GAAGD,IAAI,KAAK,GAAG,GAAG,QAAQ,GAAG,OAAO;IACrD,MAAME,KAAK,GAAGjB,MAAM,KAAKQ,SAAS,GAAGU,SAAS,CAAClB,MAAM,EAAEQ,SAAS,CAAC,GAAGZ,KAAK;IACzE;AACJ;AACA;AACA;AACA;IACI,MAAMuB,UAAU,GAAGnB,MAAM,KAAKQ,SAAS,GACjC;MAAEL,KAAK,EAAEK,SAAS,CAACY,WAAW;MAAEf,MAAM,EAAEG,SAAS,CAACa;IAAa,CAAC,GAChEtB,aAAa,CAACC,MAAM,CAAC;IAC3B,MAAMsB,aAAa,GAAG;MAClBnB,KAAK,EAAEK,SAAS,CAACJ,WAAW;MAC5BC,MAAM,EAAEG,SAAS,CAACF;IACtB,CAAC;IACD;AACJ;AACA;AACA;IACIG,IAAI,CAACM,IAAI,CAAC,CAACJ,MAAM,CAACY,MAAM,GAAG,CAAC;IAC5B;AACJ;AACA;AACA;IACI,IAAIC,UAAU,GAAG,CAACf,IAAI,CAACM,IAAI,CAAC,CAACU,WAAW;IACxC,MAAMC,UAAU,GAAGd,gBAAgB,CAACW,MAAM;IAC1C,KAAK,IAAII,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,UAAU,EAAEC,CAAC,EAAE,EAAE;MACjC,MAAMhB,MAAM,GAAGiB,aAAa,CAAChB,gBAAgB,CAACe,CAAC,CAAC,EAAEL,aAAa,CAACN,WAAW,CAAC,EAAEG,UAAU,CAACH,WAAW,CAAC,EAAEC,KAAK,CAACF,IAAI,CAAC,CAAC;MACnH,IAAI,CAACS,UAAU,IAAIb,MAAM,KAAKF,IAAI,CAACM,IAAI,CAAC,CAACc,mBAAmB,CAACF,CAAC,CAAC,EAAE;QAC7DH,UAAU,GAAG,IAAI;MACrB;MACAf,IAAI,CAACM,IAAI,CAAC,CAACJ,MAAM,CAACgB,CAAC,CAAC,GAAGhB,MAAM;IACjC;IACA;AACJ;AACA;AACA;IACI,IAAIa,UAAU,EAAE;MACZf,IAAI,CAACM,IAAI,CAAC,CAACU,WAAW,GAAGA,WAAW,CAAChB,IAAI,CAACM,IAAI,CAAC,CAACJ,MAAM,EAAEmB,aAAa,CAAClB,gBAAgB,CAAC,CAAC;MACxFH,IAAI,CAACM,IAAI,CAAC,CAACc,mBAAmB,GAAG,CAAC,GAAGpB,IAAI,CAACM,IAAI,CAAC,CAACJ,MAAM,CAAC;IAC3D;IACAF,IAAI,CAACM,IAAI,CAAC,CAACgB,QAAQ,GAAGtB,IAAI,CAACM,IAAI,CAAC,CAACU,WAAW,CAAChB,IAAI,CAACM,IAAI,CAAC,CAACiB,OAAO,CAAC;EACpE;AAAA,EAAAC,IAAA,OAAAC,MAAA","ignoreList":[]},"sourceType":"module","externalDependencies":{},"hash":"022e9d9b40fb5f16f9a37cab23c540ecdf2be3aa"}
