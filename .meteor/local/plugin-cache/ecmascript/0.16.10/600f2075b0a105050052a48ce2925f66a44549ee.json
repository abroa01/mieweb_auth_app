{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/anshul/Masters/Internship/POC/Meteor_Mobile/mieweb_push_auth/node_modules/framer-motion/dist/es/animation/sequence/create.mjs","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","topLevelAwait","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"web.browser"},"sourceFileName":"node_modules/framer-motion/dist/es/animation/sequence/create.mjs","filename":"/Users/anshul/Masters/Internship/POC/Meteor_Mobile/mieweb_push_auth/node_modules/framer-motion/dist/es/animation/sequence/create.mjs","inputSourceMap":{"version":3,"names":["createGeneratorEasing","defaultOffset","fillOffset","progress","secondsToMilliseconds","isMotionValue","resolveSubjects","isGenerator","calcNextTime","addKeyframes","compareByTime","invariant","normalizeTimes","calculateRepeatDuration","getEasingForSegment","defaultSegmentEasing","MAX_REPEAT","createAnimationsFromSequence","sequence","defaultTransition","sequenceTransition","scope","generators","defaultDuration","duration","animationDefinitions","Map","sequences","elementCache","timeLabels","prevTime","currentTime","totalDuration","i","length","segment","set","Array","isArray","name","at","subject","keyframes","transition","undefined","maxDuration","resolveValueSequence","valueKeyframes","valueTransition","valueSequence","elementIndex","numSubjects","valueKeyframesAsList","keyframesAsList","delay","times","type","repeat","repeatType","repeatDelay","remainingTransition","ease","calculatedDelay","numKeyframes","createGenerator","absoluteDelta","isNumberKeyframesArray","delta","Math","abs","springTransition","springEasing","startTime","remainder","unshift","originalKeyframes","originalTimes","originalEase","repeatIndex","push","keyframeIndex","targetTime","max","subjectSequence","getSubjectSequence","getValueSequence","subjects","subjectIndex","thisSubject","key","getValueTransition","forEach","valueSequences","element","sort","valueOffset","valueEasing","value","easing","has","definition","get","isNumber","keyframe","every"],"sources":["node_modules/framer-motion/dist/es/animation/sequence/create.mjs"],"sourcesContent":["import { createGeneratorEasing } from '../../easing/utils/create-generator-easing.mjs';\nimport { defaultOffset } from '../../utils/offsets/default.mjs';\nimport { fillOffset } from '../../utils/offsets/fill.mjs';\nimport { progress } from '../../utils/progress.mjs';\nimport { secondsToMilliseconds } from '../../utils/time-conversion.mjs';\nimport { isMotionValue } from '../../value/utils/is-motion-value.mjs';\nimport { resolveSubjects } from '../animate/resolve-subjects.mjs';\nimport { isGenerator } from '../generators/utils/is-generator.mjs';\nimport { calcNextTime } from './utils/calc-time.mjs';\nimport { addKeyframes } from './utils/edit.mjs';\nimport { compareByTime } from './utils/sort.mjs';\nimport { invariant } from 'motion-utils';\nimport { normalizeTimes } from './utils/normalize-times.mjs';\nimport { calculateRepeatDuration } from './utils/calc-repeat-duration.mjs';\nimport { getEasingForSegment } from '../../easing/utils/get-easing-for-segment.mjs';\n\nconst defaultSegmentEasing = \"easeInOut\";\nconst MAX_REPEAT = 20;\nfunction createAnimationsFromSequence(sequence, { defaultTransition = {}, ...sequenceTransition } = {}, scope, generators) {\n    const defaultDuration = defaultTransition.duration || 0.3;\n    const animationDefinitions = new Map();\n    const sequences = new Map();\n    const elementCache = {};\n    const timeLabels = new Map();\n    let prevTime = 0;\n    let currentTime = 0;\n    let totalDuration = 0;\n    /**\n     * Build the timeline by mapping over the sequence array and converting\n     * the definitions into keyframes and offsets with absolute time values.\n     * These will later get converted into relative offsets in a second pass.\n     */\n    for (let i = 0; i < sequence.length; i++) {\n        const segment = sequence[i];\n        /**\n         * If this is a timeline label, mark it and skip the rest of this iteration.\n         */\n        if (typeof segment === \"string\") {\n            timeLabels.set(segment, currentTime);\n            continue;\n        }\n        else if (!Array.isArray(segment)) {\n            timeLabels.set(segment.name, calcNextTime(currentTime, segment.at, prevTime, timeLabels));\n            continue;\n        }\n        let [subject, keyframes, transition = {}] = segment;\n        /**\n         * If a relative or absolute time value has been specified we need to resolve\n         * it in relation to the currentTime.\n         */\n        if (transition.at !== undefined) {\n            currentTime = calcNextTime(currentTime, transition.at, prevTime, timeLabels);\n        }\n        /**\n         * Keep track of the maximum duration in this definition. This will be\n         * applied to currentTime once the definition has been parsed.\n         */\n        let maxDuration = 0;\n        const resolveValueSequence = (valueKeyframes, valueTransition, valueSequence, elementIndex = 0, numSubjects = 0) => {\n            const valueKeyframesAsList = keyframesAsList(valueKeyframes);\n            const { delay = 0, times = defaultOffset(valueKeyframesAsList), type = \"keyframes\", repeat, repeatType, repeatDelay = 0, ...remainingTransition } = valueTransition;\n            let { ease = defaultTransition.ease || \"easeOut\", duration } = valueTransition;\n            /**\n             * Resolve stagger() if defined.\n             */\n            const calculatedDelay = typeof delay === \"function\"\n                ? delay(elementIndex, numSubjects)\n                : delay;\n            /**\n             * If this animation should and can use a spring, generate a spring easing function.\n             */\n            const numKeyframes = valueKeyframesAsList.length;\n            const createGenerator = isGenerator(type)\n                ? type\n                : generators === null || generators === void 0 ? void 0 : generators[type];\n            if (numKeyframes <= 2 && createGenerator) {\n                /**\n                 * As we're creating an easing function from a spring,\n                 * ideally we want to generate it using the real distance\n                 * between the two keyframes. However this isn't always\n                 * possible - in these situations we use 0-100.\n                 */\n                let absoluteDelta = 100;\n                if (numKeyframes === 2 &&\n                    isNumberKeyframesArray(valueKeyframesAsList)) {\n                    const delta = valueKeyframesAsList[1] - valueKeyframesAsList[0];\n                    absoluteDelta = Math.abs(delta);\n                }\n                const springTransition = { ...remainingTransition };\n                if (duration !== undefined) {\n                    springTransition.duration = secondsToMilliseconds(duration);\n                }\n                const springEasing = createGeneratorEasing(springTransition, absoluteDelta, createGenerator);\n                ease = springEasing.ease;\n                duration = springEasing.duration;\n            }\n            duration !== null && duration !== void 0 ? duration : (duration = defaultDuration);\n            const startTime = currentTime + calculatedDelay;\n            /**\n             * If there's only one time offset of 0, fill in a second with length 1\n             */\n            if (times.length === 1 && times[0] === 0) {\n                times[1] = 1;\n            }\n            /**\n             * Fill out if offset if fewer offsets than keyframes\n             */\n            const remainder = times.length - valueKeyframesAsList.length;\n            remainder > 0 && fillOffset(times, remainder);\n            /**\n             * If only one value has been set, ie [1], push a null to the start of\n             * the keyframe array. This will let us mark a keyframe at this point\n             * that will later be hydrated with the previous value.\n             */\n            valueKeyframesAsList.length === 1 &&\n                valueKeyframesAsList.unshift(null);\n            /**\n             * Handle repeat options\n             */\n            if (repeat) {\n                invariant(repeat < MAX_REPEAT, \"Repeat count too high, must be less than 20\");\n                duration = calculateRepeatDuration(duration, repeat);\n                const originalKeyframes = [...valueKeyframesAsList];\n                const originalTimes = [...times];\n                ease = Array.isArray(ease) ? [...ease] : [ease];\n                const originalEase = [...ease];\n                for (let repeatIndex = 0; repeatIndex < repeat; repeatIndex++) {\n                    valueKeyframesAsList.push(...originalKeyframes);\n                    for (let keyframeIndex = 0; keyframeIndex < originalKeyframes.length; keyframeIndex++) {\n                        times.push(originalTimes[keyframeIndex] + (repeatIndex + 1));\n                        ease.push(keyframeIndex === 0\n                            ? \"linear\"\n                            : getEasingForSegment(originalEase, keyframeIndex - 1));\n                    }\n                }\n                normalizeTimes(times, repeat);\n            }\n            const targetTime = startTime + duration;\n            /**\n             * Add keyframes, mapping offsets to absolute time.\n             */\n            addKeyframes(valueSequence, valueKeyframesAsList, ease, times, startTime, targetTime);\n            maxDuration = Math.max(calculatedDelay + duration, maxDuration);\n            totalDuration = Math.max(targetTime, totalDuration);\n        };\n        if (isMotionValue(subject)) {\n            const subjectSequence = getSubjectSequence(subject, sequences);\n            resolveValueSequence(keyframes, transition, getValueSequence(\"default\", subjectSequence));\n        }\n        else {\n            const subjects = resolveSubjects(subject, keyframes, scope, elementCache);\n            const numSubjects = subjects.length;\n            /**\n             * For every element in this segment, process the defined values.\n             */\n            for (let subjectIndex = 0; subjectIndex < numSubjects; subjectIndex++) {\n                /**\n                 * Cast necessary, but we know these are of this type\n                 */\n                keyframes = keyframes;\n                transition = transition;\n                const thisSubject = subjects[subjectIndex];\n                const subjectSequence = getSubjectSequence(thisSubject, sequences);\n                for (const key in keyframes) {\n                    resolveValueSequence(keyframes[key], getValueTransition(transition, key), getValueSequence(key, subjectSequence), subjectIndex, numSubjects);\n                }\n            }\n        }\n        prevTime = currentTime;\n        currentTime += maxDuration;\n    }\n    /**\n     * For every element and value combination create a new animation.\n     */\n    sequences.forEach((valueSequences, element) => {\n        for (const key in valueSequences) {\n            const valueSequence = valueSequences[key];\n            /**\n             * Arrange all the keyframes in ascending time order.\n             */\n            valueSequence.sort(compareByTime);\n            const keyframes = [];\n            const valueOffset = [];\n            const valueEasing = [];\n            /**\n             * For each keyframe, translate absolute times into\n             * relative offsets based on the total duration of the timeline.\n             */\n            for (let i = 0; i < valueSequence.length; i++) {\n                const { at, value, easing } = valueSequence[i];\n                keyframes.push(value);\n                valueOffset.push(progress(0, totalDuration, at));\n                valueEasing.push(easing || \"easeOut\");\n            }\n            /**\n             * If the first keyframe doesn't land on offset: 0\n             * provide one by duplicating the initial keyframe. This ensures\n             * it snaps to the first keyframe when the animation starts.\n             */\n            if (valueOffset[0] !== 0) {\n                valueOffset.unshift(0);\n                keyframes.unshift(keyframes[0]);\n                valueEasing.unshift(defaultSegmentEasing);\n            }\n            /**\n             * If the last keyframe doesn't land on offset: 1\n             * provide one with a null wildcard value. This will ensure it\n             * stays static until the end of the animation.\n             */\n            if (valueOffset[valueOffset.length - 1] !== 1) {\n                valueOffset.push(1);\n                keyframes.push(null);\n            }\n            if (!animationDefinitions.has(element)) {\n                animationDefinitions.set(element, {\n                    keyframes: {},\n                    transition: {},\n                });\n            }\n            const definition = animationDefinitions.get(element);\n            definition.keyframes[key] = keyframes;\n            definition.transition[key] = {\n                ...defaultTransition,\n                duration: totalDuration,\n                ease: valueEasing,\n                times: valueOffset,\n                ...sequenceTransition,\n            };\n        }\n    });\n    return animationDefinitions;\n}\nfunction getSubjectSequence(subject, sequences) {\n    !sequences.has(subject) && sequences.set(subject, {});\n    return sequences.get(subject);\n}\nfunction getValueSequence(name, sequences) {\n    if (!sequences[name])\n        sequences[name] = [];\n    return sequences[name];\n}\nfunction keyframesAsList(keyframes) {\n    return Array.isArray(keyframes) ? keyframes : [keyframes];\n}\nfunction getValueTransition(transition, key) {\n    return transition && transition[key]\n        ? {\n            ...transition,\n            ...transition[key],\n        }\n        : { ...transition };\n}\nconst isNumber = (keyframe) => typeof keyframe === \"number\";\nconst isNumberKeyframesArray = (keyframes) => keyframes.every(isNumber);\n\nexport { createAnimationsFromSequence, getValueTransition };\n"],"mappings":"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","ignoreList":[]},"targets":{},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/Users/anshul/Masters/Internship/POC/Meteor_Mobile/mieweb_push_auth","root":"/Users/anshul/Masters/Internship/POC/Meteor_Mobile/mieweb_push_auth","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true},"externalDependencies":[]},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.17.2","helpers":true,"useESModules":false,"corejs":false},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-react-jsx","visitor":{"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXFragment":{"exit":[null]},"JSXElement":{"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false},"externalDependencies":[]},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-nullish-coalescing-operator","visitor":{"LogicalExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-chaining","visitor":{"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-catch-binding","visitor":{"CatchClause":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"proposal-logical-assignment-operators","visitor":{"AssignmentExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]}],"presets":[],"generatorOpts":{"filename":"/Users/anshul/Masters/Internship/POC/Meteor_Mobile/mieweb_push_auth/node_modules/framer-motion/dist/es/animation/sequence/create.mjs","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"node_modules/framer-motion/dist/es/animation/sequence/create.mjs","inputSourceMap":{"version":3,"names":["createGeneratorEasing","defaultOffset","fillOffset","progress","secondsToMilliseconds","isMotionValue","resolveSubjects","isGenerator","calcNextTime","addKeyframes","compareByTime","invariant","normalizeTimes","calculateRepeatDuration","getEasingForSegment","defaultSegmentEasing","MAX_REPEAT","createAnimationsFromSequence","sequence","defaultTransition","sequenceTransition","scope","generators","defaultDuration","duration","animationDefinitions","Map","sequences","elementCache","timeLabels","prevTime","currentTime","totalDuration","i","length","segment","set","Array","isArray","name","at","subject","keyframes","transition","undefined","maxDuration","resolveValueSequence","valueKeyframes","valueTransition","valueSequence","elementIndex","numSubjects","valueKeyframesAsList","keyframesAsList","delay","times","type","repeat","repeatType","repeatDelay","remainingTransition","ease","calculatedDelay","numKeyframes","createGenerator","absoluteDelta","isNumberKeyframesArray","delta","Math","abs","springTransition","springEasing","startTime","remainder","unshift","originalKeyframes","originalTimes","originalEase","repeatIndex","push","keyframeIndex","targetTime","max","subjectSequence","getSubjectSequence","getValueSequence","subjects","subjectIndex","thisSubject","key","getValueTransition","forEach","valueSequences","element","sort","valueOffset","valueEasing","value","easing","has","definition","get","isNumber","keyframe","every"],"sources":["node_modules/framer-motion/dist/es/animation/sequence/create.mjs"],"sourcesContent":["import { createGeneratorEasing } from '../../easing/utils/create-generator-easing.mjs';\nimport { defaultOffset } from '../../utils/offsets/default.mjs';\nimport { fillOffset } from '../../utils/offsets/fill.mjs';\nimport { progress } from '../../utils/progress.mjs';\nimport { secondsToMilliseconds } from '../../utils/time-conversion.mjs';\nimport { isMotionValue } from '../../value/utils/is-motion-value.mjs';\nimport { resolveSubjects } from '../animate/resolve-subjects.mjs';\nimport { isGenerator } from '../generators/utils/is-generator.mjs';\nimport { calcNextTime } from './utils/calc-time.mjs';\nimport { addKeyframes } from './utils/edit.mjs';\nimport { compareByTime } from './utils/sort.mjs';\nimport { invariant } from 'motion-utils';\nimport { normalizeTimes } from './utils/normalize-times.mjs';\nimport { calculateRepeatDuration } from './utils/calc-repeat-duration.mjs';\nimport { getEasingForSegment } from '../../easing/utils/get-easing-for-segment.mjs';\n\nconst defaultSegmentEasing = \"easeInOut\";\nconst MAX_REPEAT = 20;\nfunction createAnimationsFromSequence(sequence, { defaultTransition = {}, ...sequenceTransition } = {}, scope, generators) {\n    const defaultDuration = defaultTransition.duration || 0.3;\n    const animationDefinitions = new Map();\n    const sequences = new Map();\n    const elementCache = {};\n    const timeLabels = new Map();\n    let prevTime = 0;\n    let currentTime = 0;\n    let totalDuration = 0;\n    /**\n     * Build the timeline by mapping over the sequence array and converting\n     * the definitions into keyframes and offsets with absolute time values.\n     * These will later get converted into relative offsets in a second pass.\n     */\n    for (let i = 0; i < sequence.length; i++) {\n        const segment = sequence[i];\n        /**\n         * If this is a timeline label, mark it and skip the rest of this iteration.\n         */\n        if (typeof segment === \"string\") {\n            timeLabels.set(segment, currentTime);\n            continue;\n        }\n        else if (!Array.isArray(segment)) {\n            timeLabels.set(segment.name, calcNextTime(currentTime, segment.at, prevTime, timeLabels));\n            continue;\n        }\n        let [subject, keyframes, transition = {}] = segment;\n        /**\n         * If a relative or absolute time value has been specified we need to resolve\n         * it in relation to the currentTime.\n         */\n        if (transition.at !== undefined) {\n            currentTime = calcNextTime(currentTime, transition.at, prevTime, timeLabels);\n        }\n        /**\n         * Keep track of the maximum duration in this definition. This will be\n         * applied to currentTime once the definition has been parsed.\n         */\n        let maxDuration = 0;\n        const resolveValueSequence = (valueKeyframes, valueTransition, valueSequence, elementIndex = 0, numSubjects = 0) => {\n            const valueKeyframesAsList = keyframesAsList(valueKeyframes);\n            const { delay = 0, times = defaultOffset(valueKeyframesAsList), type = \"keyframes\", repeat, repeatType, repeatDelay = 0, ...remainingTransition } = valueTransition;\n            let { ease = defaultTransition.ease || \"easeOut\", duration } = valueTransition;\n            /**\n             * Resolve stagger() if defined.\n             */\n            const calculatedDelay = typeof delay === \"function\"\n                ? delay(elementIndex, numSubjects)\n                : delay;\n            /**\n             * If this animation should and can use a spring, generate a spring easing function.\n             */\n            const numKeyframes = valueKeyframesAsList.length;\n            const createGenerator = isGenerator(type)\n                ? type\n                : generators === null || generators === void 0 ? void 0 : generators[type];\n            if (numKeyframes <= 2 && createGenerator) {\n                /**\n                 * As we're creating an easing function from a spring,\n                 * ideally we want to generate it using the real distance\n                 * between the two keyframes. However this isn't always\n                 * possible - in these situations we use 0-100.\n                 */\n                let absoluteDelta = 100;\n                if (numKeyframes === 2 &&\n                    isNumberKeyframesArray(valueKeyframesAsList)) {\n                    const delta = valueKeyframesAsList[1] - valueKeyframesAsList[0];\n                    absoluteDelta = Math.abs(delta);\n                }\n                const springTransition = { ...remainingTransition };\n                if (duration !== undefined) {\n                    springTransition.duration = secondsToMilliseconds(duration);\n                }\n                const springEasing = createGeneratorEasing(springTransition, absoluteDelta, createGenerator);\n                ease = springEasing.ease;\n                duration = springEasing.duration;\n            }\n            duration !== null && duration !== void 0 ? duration : (duration = defaultDuration);\n            const startTime = currentTime + calculatedDelay;\n            /**\n             * If there's only one time offset of 0, fill in a second with length 1\n             */\n            if (times.length === 1 && times[0] === 0) {\n                times[1] = 1;\n            }\n            /**\n             * Fill out if offset if fewer offsets than keyframes\n             */\n            const remainder = times.length - valueKeyframesAsList.length;\n            remainder > 0 && fillOffset(times, remainder);\n            /**\n             * If only one value has been set, ie [1], push a null to the start of\n             * the keyframe array. This will let us mark a keyframe at this point\n             * that will later be hydrated with the previous value.\n             */\n            valueKeyframesAsList.length === 1 &&\n                valueKeyframesAsList.unshift(null);\n            /**\n             * Handle repeat options\n             */\n            if (repeat) {\n                invariant(repeat < MAX_REPEAT, \"Repeat count too high, must be less than 20\");\n                duration = calculateRepeatDuration(duration, repeat);\n                const originalKeyframes = [...valueKeyframesAsList];\n                const originalTimes = [...times];\n                ease = Array.isArray(ease) ? [...ease] : [ease];\n                const originalEase = [...ease];\n                for (let repeatIndex = 0; repeatIndex < repeat; repeatIndex++) {\n                    valueKeyframesAsList.push(...originalKeyframes);\n                    for (let keyframeIndex = 0; keyframeIndex < originalKeyframes.length; keyframeIndex++) {\n                        times.push(originalTimes[keyframeIndex] + (repeatIndex + 1));\n                        ease.push(keyframeIndex === 0\n                            ? \"linear\"\n                            : getEasingForSegment(originalEase, keyframeIndex - 1));\n                    }\n                }\n                normalizeTimes(times, repeat);\n            }\n            const targetTime = startTime + duration;\n            /**\n             * Add keyframes, mapping offsets to absolute time.\n             */\n            addKeyframes(valueSequence, valueKeyframesAsList, ease, times, startTime, targetTime);\n            maxDuration = Math.max(calculatedDelay + duration, maxDuration);\n            totalDuration = Math.max(targetTime, totalDuration);\n        };\n        if (isMotionValue(subject)) {\n            const subjectSequence = getSubjectSequence(subject, sequences);\n            resolveValueSequence(keyframes, transition, getValueSequence(\"default\", subjectSequence));\n        }\n        else {\n            const subjects = resolveSubjects(subject, keyframes, scope, elementCache);\n            const numSubjects = subjects.length;\n            /**\n             * For every element in this segment, process the defined values.\n             */\n            for (let subjectIndex = 0; subjectIndex < numSubjects; subjectIndex++) {\n                /**\n                 * Cast necessary, but we know these are of this type\n                 */\n                keyframes = keyframes;\n                transition = transition;\n                const thisSubject = subjects[subjectIndex];\n                const subjectSequence = getSubjectSequence(thisSubject, sequences);\n                for (const key in keyframes) {\n                    resolveValueSequence(keyframes[key], getValueTransition(transition, key), getValueSequence(key, subjectSequence), subjectIndex, numSubjects);\n                }\n            }\n        }\n        prevTime = currentTime;\n        currentTime += maxDuration;\n    }\n    /**\n     * For every element and value combination create a new animation.\n     */\n    sequences.forEach((valueSequences, element) => {\n        for (const key in valueSequences) {\n            const valueSequence = valueSequences[key];\n            /**\n             * Arrange all the keyframes in ascending time order.\n             */\n            valueSequence.sort(compareByTime);\n            const keyframes = [];\n            const valueOffset = [];\n            const valueEasing = [];\n            /**\n             * For each keyframe, translate absolute times into\n             * relative offsets based on the total duration of the timeline.\n             */\n            for (let i = 0; i < valueSequence.length; i++) {\n                const { at, value, easing } = valueSequence[i];\n                keyframes.push(value);\n                valueOffset.push(progress(0, totalDuration, at));\n                valueEasing.push(easing || \"easeOut\");\n            }\n            /**\n             * If the first keyframe doesn't land on offset: 0\n             * provide one by duplicating the initial keyframe. This ensures\n             * it snaps to the first keyframe when the animation starts.\n             */\n            if (valueOffset[0] !== 0) {\n                valueOffset.unshift(0);\n                keyframes.unshift(keyframes[0]);\n                valueEasing.unshift(defaultSegmentEasing);\n            }\n            /**\n             * If the last keyframe doesn't land on offset: 1\n             * provide one with a null wildcard value. This will ensure it\n             * stays static until the end of the animation.\n             */\n            if (valueOffset[valueOffset.length - 1] !== 1) {\n                valueOffset.push(1);\n                keyframes.push(null);\n            }\n            if (!animationDefinitions.has(element)) {\n                animationDefinitions.set(element, {\n                    keyframes: {},\n                    transition: {},\n                });\n            }\n            const definition = animationDefinitions.get(element);\n            definition.keyframes[key] = keyframes;\n            definition.transition[key] = {\n                ...defaultTransition,\n                duration: totalDuration,\n                ease: valueEasing,\n                times: valueOffset,\n                ...sequenceTransition,\n            };\n        }\n    });\n    return animationDefinitions;\n}\nfunction getSubjectSequence(subject, sequences) {\n    !sequences.has(subject) && sequences.set(subject, {});\n    return sequences.get(subject);\n}\nfunction getValueSequence(name, sequences) {\n    if (!sequences[name])\n        sequences[name] = [];\n    return sequences[name];\n}\nfunction keyframesAsList(keyframes) {\n    return Array.isArray(keyframes) ? keyframes : [keyframes];\n}\nfunction getValueTransition(transition, key) {\n    return transition && transition[key]\n        ? {\n            ...transition,\n            ...transition[key],\n        }\n        : { ...transition };\n}\nconst isNumber = (keyframe) => typeof keyframe === \"number\";\nconst isNumberKeyframesArray = (keyframes) => keyframes.every(isNumber);\n\nexport { createAnimationsFromSequence, getValueTransition };\n"],"mappings":"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","ignoreList":[]}}},"code":"!function (module1) {\n  let _objectSpread;\n  module1.link(\"@babel/runtime/helpers/objectSpread2\", {\n    default(v) {\n      _objectSpread = v;\n    }\n  }, 0);\n  let _objectWithoutProperties;\n  module1.link(\"@babel/runtime/helpers/objectWithoutProperties\", {\n    default(v) {\n      _objectWithoutProperties = v;\n    }\n  }, 1);\n  const _excluded = [\"defaultTransition\"],\n    _excluded2 = [\"delay\", \"times\", \"type\", \"repeat\", \"repeatType\", \"repeatDelay\"];\n  module1.export({\n    createAnimationsFromSequence: () => createAnimationsFromSequence,\n    getValueTransition: () => getValueTransition\n  });\n  let createGeneratorEasing;\n  module1.link(\"../../easing/utils/create-generator-easing.mjs\", {\n    createGeneratorEasing(v) {\n      createGeneratorEasing = v;\n    }\n  }, 0);\n  let defaultOffset;\n  module1.link(\"../../utils/offsets/default.mjs\", {\n    defaultOffset(v) {\n      defaultOffset = v;\n    }\n  }, 1);\n  let fillOffset;\n  module1.link(\"../../utils/offsets/fill.mjs\", {\n    fillOffset(v) {\n      fillOffset = v;\n    }\n  }, 2);\n  let progress;\n  module1.link(\"../../utils/progress.mjs\", {\n    progress(v) {\n      progress = v;\n    }\n  }, 3);\n  let secondsToMilliseconds;\n  module1.link(\"../../utils/time-conversion.mjs\", {\n    secondsToMilliseconds(v) {\n      secondsToMilliseconds = v;\n    }\n  }, 4);\n  let isMotionValue;\n  module1.link(\"../../value/utils/is-motion-value.mjs\", {\n    isMotionValue(v) {\n      isMotionValue = v;\n    }\n  }, 5);\n  let resolveSubjects;\n  module1.link(\"../animate/resolve-subjects.mjs\", {\n    resolveSubjects(v) {\n      resolveSubjects = v;\n    }\n  }, 6);\n  let isGenerator;\n  module1.link(\"../generators/utils/is-generator.mjs\", {\n    isGenerator(v) {\n      isGenerator = v;\n    }\n  }, 7);\n  let calcNextTime;\n  module1.link(\"./utils/calc-time.mjs\", {\n    calcNextTime(v) {\n      calcNextTime = v;\n    }\n  }, 8);\n  let addKeyframes;\n  module1.link(\"./utils/edit.mjs\", {\n    addKeyframes(v) {\n      addKeyframes = v;\n    }\n  }, 9);\n  let compareByTime;\n  module1.link(\"./utils/sort.mjs\", {\n    compareByTime(v) {\n      compareByTime = v;\n    }\n  }, 10);\n  let invariant;\n  module1.link(\"motion-utils\", {\n    invariant(v) {\n      invariant = v;\n    }\n  }, 11);\n  let normalizeTimes;\n  module1.link(\"./utils/normalize-times.mjs\", {\n    normalizeTimes(v) {\n      normalizeTimes = v;\n    }\n  }, 12);\n  let calculateRepeatDuration;\n  module1.link(\"./utils/calc-repeat-duration.mjs\", {\n    calculateRepeatDuration(v) {\n      calculateRepeatDuration = v;\n    }\n  }, 13);\n  let getEasingForSegment;\n  module1.link(\"../../easing/utils/get-easing-for-segment.mjs\", {\n    getEasingForSegment(v) {\n      getEasingForSegment = v;\n    }\n  }, 14);\n  ___INIT_METEOR_FAST_REFRESH(module);\n  const defaultSegmentEasing = \"easeInOut\";\n  const MAX_REPEAT = 20;\n  function createAnimationsFromSequence(sequence) {\n    let _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let scope = arguments.length > 2 ? arguments[2] : undefined;\n    let generators = arguments.length > 3 ? arguments[3] : undefined;\n    let {\n        defaultTransition = {}\n      } = _ref,\n      sequenceTransition = _objectWithoutProperties(_ref, _excluded);\n    const defaultDuration = defaultTransition.duration || 0.3;\n    const animationDefinitions = new Map();\n    const sequences = new Map();\n    const elementCache = {};\n    const timeLabels = new Map();\n    let prevTime = 0;\n    let currentTime = 0;\n    let totalDuration = 0;\n    /**\n     * Build the timeline by mapping over the sequence array and converting\n     * the definitions into keyframes and offsets with absolute time values.\n     * These will later get converted into relative offsets in a second pass.\n     */\n    for (let i = 0; i < sequence.length; i++) {\n      const segment = sequence[i];\n      /**\n       * If this is a timeline label, mark it and skip the rest of this iteration.\n       */\n      if (typeof segment === \"string\") {\n        timeLabels.set(segment, currentTime);\n        continue;\n      } else if (!Array.isArray(segment)) {\n        timeLabels.set(segment.name, calcNextTime(currentTime, segment.at, prevTime, timeLabels));\n        continue;\n      }\n      let [subject, keyframes, transition = {}] = segment;\n      /**\n       * If a relative or absolute time value has been specified we need to resolve\n       * it in relation to the currentTime.\n       */\n      if (transition.at !== undefined) {\n        currentTime = calcNextTime(currentTime, transition.at, prevTime, timeLabels);\n      }\n      /**\n       * Keep track of the maximum duration in this definition. This will be\n       * applied to currentTime once the definition has been parsed.\n       */\n      let maxDuration = 0;\n      const resolveValueSequence = function (valueKeyframes, valueTransition, valueSequence) {\n        let elementIndex = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n        let numSubjects = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n        const valueKeyframesAsList = keyframesAsList(valueKeyframes);\n        const {\n            delay = 0,\n            times = defaultOffset(valueKeyframesAsList),\n            type = \"keyframes\",\n            repeat,\n            repeatType,\n            repeatDelay = 0\n          } = valueTransition,\n          remainingTransition = _objectWithoutProperties(valueTransition, _excluded2);\n        let {\n          ease = defaultTransition.ease || \"easeOut\",\n          duration\n        } = valueTransition;\n        /**\n         * Resolve stagger() if defined.\n         */\n        const calculatedDelay = typeof delay === \"function\" ? delay(elementIndex, numSubjects) : delay;\n        /**\n         * If this animation should and can use a spring, generate a spring easing function.\n         */\n        const numKeyframes = valueKeyframesAsList.length;\n        const createGenerator = isGenerator(type) ? type : generators === null || generators === void 0 ? void 0 : generators[type];\n        if (numKeyframes <= 2 && createGenerator) {\n          /**\n           * As we're creating an easing function from a spring,\n           * ideally we want to generate it using the real distance\n           * between the two keyframes. However this isn't always\n           * possible - in these situations we use 0-100.\n           */\n          let absoluteDelta = 100;\n          if (numKeyframes === 2 && isNumberKeyframesArray(valueKeyframesAsList)) {\n            const delta = valueKeyframesAsList[1] - valueKeyframesAsList[0];\n            absoluteDelta = Math.abs(delta);\n          }\n          const springTransition = _objectSpread({}, remainingTransition);\n          if (duration !== undefined) {\n            springTransition.duration = secondsToMilliseconds(duration);\n          }\n          const springEasing = createGeneratorEasing(springTransition, absoluteDelta, createGenerator);\n          ease = springEasing.ease;\n          duration = springEasing.duration;\n        }\n        duration !== null && duration !== void 0 ? duration : duration = defaultDuration;\n        const startTime = currentTime + calculatedDelay;\n        /**\n         * If there's only one time offset of 0, fill in a second with length 1\n         */\n        if (times.length === 1 && times[0] === 0) {\n          times[1] = 1;\n        }\n        /**\n         * Fill out if offset if fewer offsets than keyframes\n         */\n        const remainder = times.length - valueKeyframesAsList.length;\n        remainder > 0 && fillOffset(times, remainder);\n        /**\n         * If only one value has been set, ie [1], push a null to the start of\n         * the keyframe array. This will let us mark a keyframe at this point\n         * that will later be hydrated with the previous value.\n         */\n        valueKeyframesAsList.length === 1 && valueKeyframesAsList.unshift(null);\n        /**\n         * Handle repeat options\n         */\n        if (repeat) {\n          invariant(repeat < MAX_REPEAT, \"Repeat count too high, must be less than 20\");\n          duration = calculateRepeatDuration(duration, repeat);\n          const originalKeyframes = [...valueKeyframesAsList];\n          const originalTimes = [...times];\n          ease = Array.isArray(ease) ? [...ease] : [ease];\n          const originalEase = [...ease];\n          for (let repeatIndex = 0; repeatIndex < repeat; repeatIndex++) {\n            valueKeyframesAsList.push(...originalKeyframes);\n            for (let keyframeIndex = 0; keyframeIndex < originalKeyframes.length; keyframeIndex++) {\n              times.push(originalTimes[keyframeIndex] + (repeatIndex + 1));\n              ease.push(keyframeIndex === 0 ? \"linear\" : getEasingForSegment(originalEase, keyframeIndex - 1));\n            }\n          }\n          normalizeTimes(times, repeat);\n        }\n        const targetTime = startTime + duration;\n        /**\n         * Add keyframes, mapping offsets to absolute time.\n         */\n        addKeyframes(valueSequence, valueKeyframesAsList, ease, times, startTime, targetTime);\n        maxDuration = Math.max(calculatedDelay + duration, maxDuration);\n        totalDuration = Math.max(targetTime, totalDuration);\n      };\n      if (isMotionValue(subject)) {\n        const subjectSequence = getSubjectSequence(subject, sequences);\n        resolveValueSequence(keyframes, transition, getValueSequence(\"default\", subjectSequence));\n      } else {\n        const subjects = resolveSubjects(subject, keyframes, scope, elementCache);\n        const numSubjects = subjects.length;\n        /**\n         * For every element in this segment, process the defined values.\n         */\n        for (let subjectIndex = 0; subjectIndex < numSubjects; subjectIndex++) {\n          /**\n           * Cast necessary, but we know these are of this type\n           */\n          keyframes = keyframes;\n          transition = transition;\n          const thisSubject = subjects[subjectIndex];\n          const subjectSequence = getSubjectSequence(thisSubject, sequences);\n          for (const key in keyframes) {\n            resolveValueSequence(keyframes[key], getValueTransition(transition, key), getValueSequence(key, subjectSequence), subjectIndex, numSubjects);\n          }\n        }\n      }\n      prevTime = currentTime;\n      currentTime += maxDuration;\n    }\n    /**\n     * For every element and value combination create a new animation.\n     */\n    sequences.forEach((valueSequences, element) => {\n      for (const key in valueSequences) {\n        const valueSequence = valueSequences[key];\n        /**\n         * Arrange all the keyframes in ascending time order.\n         */\n        valueSequence.sort(compareByTime);\n        const keyframes = [];\n        const valueOffset = [];\n        const valueEasing = [];\n        /**\n         * For each keyframe, translate absolute times into\n         * relative offsets based on the total duration of the timeline.\n         */\n        for (let i = 0; i < valueSequence.length; i++) {\n          const {\n            at,\n            value,\n            easing\n          } = valueSequence[i];\n          keyframes.push(value);\n          valueOffset.push(progress(0, totalDuration, at));\n          valueEasing.push(easing || \"easeOut\");\n        }\n        /**\n         * If the first keyframe doesn't land on offset: 0\n         * provide one by duplicating the initial keyframe. This ensures\n         * it snaps to the first keyframe when the animation starts.\n         */\n        if (valueOffset[0] !== 0) {\n          valueOffset.unshift(0);\n          keyframes.unshift(keyframes[0]);\n          valueEasing.unshift(defaultSegmentEasing);\n        }\n        /**\n         * If the last keyframe doesn't land on offset: 1\n         * provide one with a null wildcard value. This will ensure it\n         * stays static until the end of the animation.\n         */\n        if (valueOffset[valueOffset.length - 1] !== 1) {\n          valueOffset.push(1);\n          keyframes.push(null);\n        }\n        if (!animationDefinitions.has(element)) {\n          animationDefinitions.set(element, {\n            keyframes: {},\n            transition: {}\n          });\n        }\n        const definition = animationDefinitions.get(element);\n        definition.keyframes[key] = keyframes;\n        definition.transition[key] = _objectSpread(_objectSpread({}, defaultTransition), {}, {\n          duration: totalDuration,\n          ease: valueEasing,\n          times: valueOffset\n        }, sequenceTransition);\n      }\n    });\n    return animationDefinitions;\n  }\n  function getSubjectSequence(subject, sequences) {\n    !sequences.has(subject) && sequences.set(subject, {});\n    return sequences.get(subject);\n  }\n  function getValueSequence(name, sequences) {\n    if (!sequences[name]) sequences[name] = [];\n    return sequences[name];\n  }\n  function keyframesAsList(keyframes) {\n    return Array.isArray(keyframes) ? keyframes : [keyframes];\n  }\n  function getValueTransition(transition, key) {\n    return transition && transition[key] ? _objectSpread(_objectSpread({}, transition), transition[key]) : _objectSpread({}, transition);\n  }\n  const isNumber = keyframe => typeof keyframe === \"number\";\n  const isNumberKeyframesArray = keyframes => keyframes.every(isNumber);\n}.call(this, module);","map":{"version":3,"names":["defaultSegmentEasing","MAX_REPEAT","createAnimationsFromSequence","sequence","_ref","arguments","length","undefined","scope","generators","defaultTransition","sequenceTransition","_objectWithoutProperties","_excluded","defaultDuration","duration","animationDefinitions","Map","sequences","elementCache","timeLabels","prevTime","currentTime","totalDuration","i","segment","set","Array","isArray","name","calcNextTime","at","subject","keyframes","transition","maxDuration","resolveValueSequence","valueKeyframes","valueTransition","valueSequence","elementIndex","numSubjects","valueKeyframesAsList","keyframesAsList","delay","times","defaultOffset","type","repeat","repeatType","repeatDelay","remainingTransition","_excluded2","ease","calculatedDelay","numKeyframes","createGenerator","isGenerator","absoluteDelta","isNumberKeyframesArray","delta","Math","abs","springTransition","_objectSpread","secondsToMilliseconds","springEasing","createGeneratorEasing","startTime","remainder","fillOffset","unshift","invariant","calculateRepeatDuration","originalKeyframes","originalTimes","originalEase","repeatIndex","push","keyframeIndex","getEasingForSegment","normalizeTimes","targetTime","addKeyframes","max","isMotionValue","subjectSequence","getSubjectSequence","getValueSequence","subjects","resolveSubjects","subjectIndex","thisSubject","key","getValueTransition","forEach","valueSequences","element","sort","compareByTime","valueOffset","valueEasing","value","easing","progress","has","definition","get","isNumber","keyframe","every","call","module"],"sources":["node_modules/framer-motion/dist/es/animation/sequence/create.mjs"],"sourcesContent":["import { createGeneratorEasing } from '../../easing/utils/create-generator-easing.mjs';\nimport { defaultOffset } from '../../utils/offsets/default.mjs';\nimport { fillOffset } from '../../utils/offsets/fill.mjs';\nimport { progress } from '../../utils/progress.mjs';\nimport { secondsToMilliseconds } from '../../utils/time-conversion.mjs';\nimport { isMotionValue } from '../../value/utils/is-motion-value.mjs';\nimport { resolveSubjects } from '../animate/resolve-subjects.mjs';\nimport { isGenerator } from '../generators/utils/is-generator.mjs';\nimport { calcNextTime } from './utils/calc-time.mjs';\nimport { addKeyframes } from './utils/edit.mjs';\nimport { compareByTime } from './utils/sort.mjs';\nimport { invariant } from 'motion-utils';\nimport { normalizeTimes } from './utils/normalize-times.mjs';\nimport { calculateRepeatDuration } from './utils/calc-repeat-duration.mjs';\nimport { getEasingForSegment } from '../../easing/utils/get-easing-for-segment.mjs';\n\nconst defaultSegmentEasing = \"easeInOut\";\nconst MAX_REPEAT = 20;\nfunction createAnimationsFromSequence(sequence, { defaultTransition = {}, ...sequenceTransition } = {}, scope, generators) {\n    const defaultDuration = defaultTransition.duration || 0.3;\n    const animationDefinitions = new Map();\n    const sequences = new Map();\n    const elementCache = {};\n    const timeLabels = new Map();\n    let prevTime = 0;\n    let currentTime = 0;\n    let totalDuration = 0;\n    /**\n     * Build the timeline by mapping over the sequence array and converting\n     * the definitions into keyframes and offsets with absolute time values.\n     * These will later get converted into relative offsets in a second pass.\n     */\n    for (let i = 0; i < sequence.length; i++) {\n        const segment = sequence[i];\n        /**\n         * If this is a timeline label, mark it and skip the rest of this iteration.\n         */\n        if (typeof segment === \"string\") {\n            timeLabels.set(segment, currentTime);\n            continue;\n        }\n        else if (!Array.isArray(segment)) {\n            timeLabels.set(segment.name, calcNextTime(currentTime, segment.at, prevTime, timeLabels));\n            continue;\n        }\n        let [subject, keyframes, transition = {}] = segment;\n        /**\n         * If a relative or absolute time value has been specified we need to resolve\n         * it in relation to the currentTime.\n         */\n        if (transition.at !== undefined) {\n            currentTime = calcNextTime(currentTime, transition.at, prevTime, timeLabels);\n        }\n        /**\n         * Keep track of the maximum duration in this definition. This will be\n         * applied to currentTime once the definition has been parsed.\n         */\n        let maxDuration = 0;\n        const resolveValueSequence = (valueKeyframes, valueTransition, valueSequence, elementIndex = 0, numSubjects = 0) => {\n            const valueKeyframesAsList = keyframesAsList(valueKeyframes);\n            const { delay = 0, times = defaultOffset(valueKeyframesAsList), type = \"keyframes\", repeat, repeatType, repeatDelay = 0, ...remainingTransition } = valueTransition;\n            let { ease = defaultTransition.ease || \"easeOut\", duration } = valueTransition;\n            /**\n             * Resolve stagger() if defined.\n             */\n            const calculatedDelay = typeof delay === \"function\"\n                ? delay(elementIndex, numSubjects)\n                : delay;\n            /**\n             * If this animation should and can use a spring, generate a spring easing function.\n             */\n            const numKeyframes = valueKeyframesAsList.length;\n            const createGenerator = isGenerator(type)\n                ? type\n                : generators === null || generators === void 0 ? void 0 : generators[type];\n            if (numKeyframes <= 2 && createGenerator) {\n                /**\n                 * As we're creating an easing function from a spring,\n                 * ideally we want to generate it using the real distance\n                 * between the two keyframes. However this isn't always\n                 * possible - in these situations we use 0-100.\n                 */\n                let absoluteDelta = 100;\n                if (numKeyframes === 2 &&\n                    isNumberKeyframesArray(valueKeyframesAsList)) {\n                    const delta = valueKeyframesAsList[1] - valueKeyframesAsList[0];\n                    absoluteDelta = Math.abs(delta);\n                }\n                const springTransition = { ...remainingTransition };\n                if (duration !== undefined) {\n                    springTransition.duration = secondsToMilliseconds(duration);\n                }\n                const springEasing = createGeneratorEasing(springTransition, absoluteDelta, createGenerator);\n                ease = springEasing.ease;\n                duration = springEasing.duration;\n            }\n            duration !== null && duration !== void 0 ? duration : (duration = defaultDuration);\n            const startTime = currentTime + calculatedDelay;\n            /**\n             * If there's only one time offset of 0, fill in a second with length 1\n             */\n            if (times.length === 1 && times[0] === 0) {\n                times[1] = 1;\n            }\n            /**\n             * Fill out if offset if fewer offsets than keyframes\n             */\n            const remainder = times.length - valueKeyframesAsList.length;\n            remainder > 0 && fillOffset(times, remainder);\n            /**\n             * If only one value has been set, ie [1], push a null to the start of\n             * the keyframe array. This will let us mark a keyframe at this point\n             * that will later be hydrated with the previous value.\n             */\n            valueKeyframesAsList.length === 1 &&\n                valueKeyframesAsList.unshift(null);\n            /**\n             * Handle repeat options\n             */\n            if (repeat) {\n                invariant(repeat < MAX_REPEAT, \"Repeat count too high, must be less than 20\");\n                duration = calculateRepeatDuration(duration, repeat);\n                const originalKeyframes = [...valueKeyframesAsList];\n                const originalTimes = [...times];\n                ease = Array.isArray(ease) ? [...ease] : [ease];\n                const originalEase = [...ease];\n                for (let repeatIndex = 0; repeatIndex < repeat; repeatIndex++) {\n                    valueKeyframesAsList.push(...originalKeyframes);\n                    for (let keyframeIndex = 0; keyframeIndex < originalKeyframes.length; keyframeIndex++) {\n                        times.push(originalTimes[keyframeIndex] + (repeatIndex + 1));\n                        ease.push(keyframeIndex === 0\n                            ? \"linear\"\n                            : getEasingForSegment(originalEase, keyframeIndex - 1));\n                    }\n                }\n                normalizeTimes(times, repeat);\n            }\n            const targetTime = startTime + duration;\n            /**\n             * Add keyframes, mapping offsets to absolute time.\n             */\n            addKeyframes(valueSequence, valueKeyframesAsList, ease, times, startTime, targetTime);\n            maxDuration = Math.max(calculatedDelay + duration, maxDuration);\n            totalDuration = Math.max(targetTime, totalDuration);\n        };\n        if (isMotionValue(subject)) {\n            const subjectSequence = getSubjectSequence(subject, sequences);\n            resolveValueSequence(keyframes, transition, getValueSequence(\"default\", subjectSequence));\n        }\n        else {\n            const subjects = resolveSubjects(subject, keyframes, scope, elementCache);\n            const numSubjects = subjects.length;\n            /**\n             * For every element in this segment, process the defined values.\n             */\n            for (let subjectIndex = 0; subjectIndex < numSubjects; subjectIndex++) {\n                /**\n                 * Cast necessary, but we know these are of this type\n                 */\n                keyframes = keyframes;\n                transition = transition;\n                const thisSubject = subjects[subjectIndex];\n                const subjectSequence = getSubjectSequence(thisSubject, sequences);\n                for (const key in keyframes) {\n                    resolveValueSequence(keyframes[key], getValueTransition(transition, key), getValueSequence(key, subjectSequence), subjectIndex, numSubjects);\n                }\n            }\n        }\n        prevTime = currentTime;\n        currentTime += maxDuration;\n    }\n    /**\n     * For every element and value combination create a new animation.\n     */\n    sequences.forEach((valueSequences, element) => {\n        for (const key in valueSequences) {\n            const valueSequence = valueSequences[key];\n            /**\n             * Arrange all the keyframes in ascending time order.\n             */\n            valueSequence.sort(compareByTime);\n            const keyframes = [];\n            const valueOffset = [];\n            const valueEasing = [];\n            /**\n             * For each keyframe, translate absolute times into\n             * relative offsets based on the total duration of the timeline.\n             */\n            for (let i = 0; i < valueSequence.length; i++) {\n                const { at, value, easing } = valueSequence[i];\n                keyframes.push(value);\n                valueOffset.push(progress(0, totalDuration, at));\n                valueEasing.push(easing || \"easeOut\");\n            }\n            /**\n             * If the first keyframe doesn't land on offset: 0\n             * provide one by duplicating the initial keyframe. This ensures\n             * it snaps to the first keyframe when the animation starts.\n             */\n            if (valueOffset[0] !== 0) {\n                valueOffset.unshift(0);\n                keyframes.unshift(keyframes[0]);\n                valueEasing.unshift(defaultSegmentEasing);\n            }\n            /**\n             * If the last keyframe doesn't land on offset: 1\n             * provide one with a null wildcard value. This will ensure it\n             * stays static until the end of the animation.\n             */\n            if (valueOffset[valueOffset.length - 1] !== 1) {\n                valueOffset.push(1);\n                keyframes.push(null);\n            }\n            if (!animationDefinitions.has(element)) {\n                animationDefinitions.set(element, {\n                    keyframes: {},\n                    transition: {},\n                });\n            }\n            const definition = animationDefinitions.get(element);\n            definition.keyframes[key] = keyframes;\n            definition.transition[key] = {\n                ...defaultTransition,\n                duration: totalDuration,\n                ease: valueEasing,\n                times: valueOffset,\n                ...sequenceTransition,\n            };\n        }\n    });\n    return animationDefinitions;\n}\nfunction getSubjectSequence(subject, sequences) {\n    !sequences.has(subject) && sequences.set(subject, {});\n    return sequences.get(subject);\n}\nfunction getValueSequence(name, sequences) {\n    if (!sequences[name])\n        sequences[name] = [];\n    return sequences[name];\n}\nfunction keyframesAsList(keyframes) {\n    return Array.isArray(keyframes) ? keyframes : [keyframes];\n}\nfunction getValueTransition(transition, key) {\n    return transition && transition[key]\n        ? {\n            ...transition,\n            ...transition[key],\n        }\n        : { ...transition };\n}\nconst isNumber = (keyframe) => typeof keyframe === \"number\";\nconst isNumberKeyframesArray = (keyframes) => keyframes.every(isNumber);\n\nexport { createAnimationsFromSequence, getValueTransition };\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAgBA,MAAMA,oBAAoB,GAAG,WAAW;EACxC,MAAMC,UAAU,GAAG,EAAE;EACrB,SAASC,4BAA4BA,CAACC,QAAQ,EAA6E;IAAA,IAAAC,IAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAvB,CAAC,CAAC;IAAA,IAAEG,KAAK,GAAAH,SAAA,CAAAC,MAAA,OAAAD,SAAA,MAAAE,SAAA;IAAA,IAAEE,UAAU,GAAAJ,SAAA,CAAAC,MAAA,OAAAD,SAAA,MAAAE,SAAA;IAAA,IAAzE;QAAEG,iBAAiB,GAAG,CAAC;MAAyB,CAAC,GAAAN,IAAA;MAApBO,kBAAA,GAAAC,wBAAA,CAAAR,IAAA,EAAAS,SAAA;IACzE,MAAMC,eAAe,GAAGJ,iBAAiB,CAACK,QAAQ,IAAI,GAAG;IACzD,MAAMC,oBAAoB,GAAG,IAAIC,GAAG,CAAC,CAAC;IACtC,MAAMC,SAAS,GAAG,IAAID,GAAG,CAAC,CAAC;IAC3B,MAAME,YAAY,GAAG,CAAC,CAAC;IACvB,MAAMC,UAAU,GAAG,IAAIH,GAAG,CAAC,CAAC;IAC5B,IAAII,QAAQ,GAAG,CAAC;IAChB,IAAIC,WAAW,GAAG,CAAC;IACnB,IAAIC,aAAa,GAAG,CAAC;IACrB;AACJ;AACA;AACA;AACA;IACI,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGrB,QAAQ,CAACG,MAAM,EAAEkB,CAAC,EAAE,EAAE;MACtC,MAAMC,OAAO,GAAGtB,QAAQ,CAACqB,CAAC,CAAC;MAC3B;AACR;AACA;MACQ,IAAI,OAAOC,OAAO,KAAK,QAAQ,EAAE;QAC7BL,UAAU,CAACM,GAAG,CAACD,OAAO,EAAEH,WAAW,CAAC;QACpC;MACJ,CAAC,MACI,IAAI,CAACK,KAAK,CAACC,OAAO,CAACH,OAAO,CAAC,EAAE;QAC9BL,UAAU,CAACM,GAAG,CAACD,OAAO,CAACI,IAAI,EAAEC,YAAY,CAACR,WAAW,EAAEG,OAAO,CAACM,EAAE,EAAEV,QAAQ,EAAED,UAAU,CAAC,CAAC;QACzF;MACJ;MACA,IAAI,CAACY,OAAO,EAAEC,SAAS,EAAEC,UAAU,GAAG,CAAC,CAAC,CAAC,GAAGT,OAAO;MACnD;AACR;AACA;AACA;MACQ,IAAIS,UAAU,CAACH,EAAE,KAAKxB,SAAS,EAAE;QAC7Be,WAAW,GAAGQ,YAAY,CAACR,WAAW,EAAEY,UAAU,CAACH,EAAE,EAAEV,QAAQ,EAAED,UAAU,CAAC;MAChF;MACA;AACR;AACA;AACA;MACQ,IAAIe,WAAW,GAAG,CAAC;MACnB,MAAMC,oBAAoB,GAAG,SAAAA,CAACC,cAAc,EAAEC,eAAe,EAAEC,aAAa,EAAwC;QAAA,IAAtCC,YAAY,GAAAnC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC;QAAA,IAAEoC,WAAW,GAAApC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC;QAC3G,MAAMqC,oBAAoB,GAAGC,eAAe,CAACN,cAAc,CAAC;QAC5D,MAAM;YAAEO,KAAK,GAAG,CAAC;YAAEC,KAAK,GAAGC,aAAa,CAACJ,oBAAoB,CAAC;YAAEK,IAAI,GAAG,WAAW;YAAEC,MAAM;YAAEC,UAAU;YAAEC,WAAW,GAAG;UAA0B,CAAC,GAAGZ,eAAe;UAAvCa,mBAAA,GAAAvC,wBAAA,CAAwB0B,eAAe,EAAAc,UAAA;QACnK,IAAI;UAAEC,IAAI,GAAG3C,iBAAiB,CAAC2C,IAAI,IAAI,SAAS;UAAEtC;QAAS,CAAC,GAAGuB,eAAe;QAC9E;AACZ;AACA;QACY,MAAMgB,eAAe,GAAG,OAAOV,KAAK,KAAK,UAAU,GAC7CA,KAAK,CAACJ,YAAY,EAAEC,WAAW,CAAC,GAChCG,KAAK;QACX;AACZ;AACA;QACY,MAAMW,YAAY,GAAGb,oBAAoB,CAACpC,MAAM;QAChD,MAAMkD,eAAe,GAAGC,WAAW,CAACV,IAAI,CAAC,GACnCA,IAAI,GACJtC,UAAU,KAAK,IAAI,IAAIA,UAAU,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,UAAU,CAACsC,IAAI,CAAC;QAC9E,IAAIQ,YAAY,IAAI,CAAC,IAAIC,eAAe,EAAE;UACtC;AAChB;AACA;AACA;AACA;AACA;UACgB,IAAIE,aAAa,GAAG,GAAG;UACvB,IAAIH,YAAY,KAAK,CAAC,IAClBI,sBAAsB,CAACjB,oBAAoB,CAAC,EAAE;YAC9C,MAAMkB,KAAK,GAAGlB,oBAAoB,CAAC,CAAC,CAAC,GAAGA,oBAAoB,CAAC,CAAC,CAAC;YAC/DgB,aAAa,GAAGG,IAAI,CAACC,GAAG,CAACF,KAAK,CAAC;UACnC;UACA,MAAMG,gBAAgB,GAAAC,aAAA,KAAQb,mBAAA,CAAqB;UACnD,IAAIpC,QAAQ,KAAKR,SAAS,EAAE;YACxBwD,gBAAgB,CAAChD,QAAQ,GAAGkD,qBAAqB,CAAClD,QAAQ,CAAC;UAC/D;UACA,MAAMmD,YAAY,GAAGC,qBAAqB,CAACJ,gBAAgB,EAAEL,aAAa,EAAEF,eAAe,CAAC;UAC5FH,IAAI,GAAGa,YAAY,CAACb,IAAI;UACxBtC,QAAQ,GAAGmD,YAAY,CAACnD,QAAQ;QACpC;QACAA,QAAQ,KAAK,IAAI,IAAIA,QAAQ,KAAK,KAAK,CAAC,GAAGA,QAAQ,GAAIA,QAAQ,GAAGD,eAAgB;QAClF,MAAMsD,SAAS,GAAG9C,WAAW,GAAGgC,eAAe;QAC/C;AACZ;AACA;QACY,IAAIT,KAAK,CAACvC,MAAM,KAAK,CAAC,IAAIuC,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,EAAE;UACtCA,KAAK,CAAC,CAAC,CAAC,GAAG,CAAC;QAChB;QACA;AACZ;AACA;QACY,MAAMwB,SAAS,GAAGxB,KAAK,CAACvC,MAAM,GAAGoC,oBAAoB,CAACpC,MAAM;QAC5D+D,SAAS,GAAG,CAAC,IAAIC,UAAU,CAACzB,KAAK,EAAEwB,SAAS,CAAC;QAC7C;AACZ;AACA;AACA;AACA;QACY3B,oBAAoB,CAACpC,MAAM,KAAK,CAAC,IAC7BoC,oBAAoB,CAAC6B,OAAO,CAAC,IAAI,CAAC;QACtC;AACZ;AACA;QACY,IAAIvB,MAAM,EAAE;UACRwB,SAAS,CAACxB,MAAM,GAAG/C,UAAU,EAAE,6CAA6C,CAAC;UAC7Ec,QAAQ,GAAG0D,uBAAuB,CAAC1D,QAAQ,EAAEiC,MAAM,CAAC;UACpD,MAAM0B,iBAAiB,GAAG,CAAC,GAAGhC,oBAAoB,CAAC;UACnD,MAAMiC,aAAa,GAAG,CAAC,GAAG9B,KAAK,CAAC;UAChCQ,IAAI,GAAG1B,KAAK,CAACC,OAAO,CAACyB,IAAI,CAAC,GAAG,CAAC,GAAGA,IAAI,CAAC,GAAG,CAACA,IAAI,CAAC;UAC/C,MAAMuB,YAAY,GAAG,CAAC,GAAGvB,IAAI,CAAC;UAC9B,KAAK,IAAIwB,WAAW,GAAG,CAAC,EAAEA,WAAW,GAAG7B,MAAM,EAAE6B,WAAW,EAAE,EAAE;YAC3DnC,oBAAoB,CAACoC,IAAI,CAAC,GAAGJ,iBAAiB,CAAC;YAC/C,KAAK,IAAIK,aAAa,GAAG,CAAC,EAAEA,aAAa,GAAGL,iBAAiB,CAACpE,MAAM,EAAEyE,aAAa,EAAE,EAAE;cACnFlC,KAAK,CAACiC,IAAI,CAACH,aAAa,CAACI,aAAa,CAAC,IAAIF,WAAW,GAAG,CAAC,CAAC,CAAC;cAC5DxB,IAAI,CAACyB,IAAI,CAACC,aAAa,KAAK,CAAC,GACvB,QAAQ,GACRC,mBAAmB,CAACJ,YAAY,EAAEG,aAAa,GAAG,CAAC,CAAC,CAAC;YAC/D;UACJ;UACAE,cAAc,CAACpC,KAAK,EAAEG,MAAM,CAAC;QACjC;QACA,MAAMkC,UAAU,GAAGd,SAAS,GAAGrD,QAAQ;QACvC;AACZ;AACA;QACYoE,YAAY,CAAC5C,aAAa,EAAEG,oBAAoB,EAAEW,IAAI,EAAER,KAAK,EAAEuB,SAAS,EAAEc,UAAU,CAAC;QACrF/C,WAAW,GAAG0B,IAAI,CAACuB,GAAG,CAAC9B,eAAe,GAAGvC,QAAQ,EAAEoB,WAAW,CAAC;QAC/DZ,aAAa,GAAGsC,IAAI,CAACuB,GAAG,CAACF,UAAU,EAAE3D,aAAa,CAAC;MACvD,CAAC;MACD,IAAI8D,aAAa,CAACrD,OAAO,CAAC,EAAE;QACxB,MAAMsD,eAAe,GAAGC,kBAAkB,CAACvD,OAAO,EAAEd,SAAS,CAAC;QAC9DkB,oBAAoB,CAACH,SAAS,EAAEC,UAAU,EAAEsD,gBAAgB,CAAC,SAAS,EAAEF,eAAe,CAAC,CAAC;MAC7F,CAAC,MACI;QACD,MAAMG,QAAQ,GAAGC,eAAe,CAAC1D,OAAO,EAAEC,SAAS,EAAEzB,KAAK,EAAEW,YAAY,CAAC;QACzE,MAAMsB,WAAW,GAAGgD,QAAQ,CAACnF,MAAM;QACnC;AACZ;AACA;QACY,KAAK,IAAIqF,YAAY,GAAG,CAAC,EAAEA,YAAY,GAAGlD,WAAW,EAAEkD,YAAY,EAAE,EAAE;UACnE;AAChB;AACA;UACgB1D,SAAS,GAAGA,SAAS;UACrBC,UAAU,GAAGA,UAAU;UACvB,MAAM0D,WAAW,GAAGH,QAAQ,CAACE,YAAY,CAAC;UAC1C,MAAML,eAAe,GAAGC,kBAAkB,CAACK,WAAW,EAAE1E,SAAS,CAAC;UAClE,KAAK,MAAM2E,GAAG,IAAI5D,SAAS,EAAE;YACzBG,oBAAoB,CAACH,SAAS,CAAC4D,GAAG,CAAC,EAAEC,kBAAkB,CAAC5D,UAAU,EAAE2D,GAAG,CAAC,EAAEL,gBAAgB,CAACK,GAAG,EAAEP,eAAe,CAAC,EAAEK,YAAY,EAAElD,WAAW,CAAC;UAChJ;QACJ;MACJ;MACApB,QAAQ,GAAGC,WAAW;MACtBA,WAAW,IAAIa,WAAW;IAC9B;IACA;AACJ;AACA;IACIjB,SAAS,CAAC6E,OAAO,CAAC,CAACC,cAAc,EAAEC,OAAO,KAAK;MAC3C,KAAK,MAAMJ,GAAG,IAAIG,cAAc,EAAE;QAC9B,MAAMzD,aAAa,GAAGyD,cAAc,CAACH,GAAG,CAAC;QACzC;AACZ;AACA;QACYtD,aAAa,CAAC2D,IAAI,CAACC,aAAa,CAAC;QACjC,MAAMlE,SAAS,GAAG,EAAE;QACpB,MAAMmE,WAAW,GAAG,EAAE;QACtB,MAAMC,WAAW,GAAG,EAAE;QACtB;AACZ;AACA;AACA;QACY,KAAK,IAAI7E,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGe,aAAa,CAACjC,MAAM,EAAEkB,CAAC,EAAE,EAAE;UAC3C,MAAM;YAAEO,EAAE;YAAEuE,KAAK;YAAEC;UAAO,CAAC,GAAGhE,aAAa,CAACf,CAAC,CAAC;UAC9CS,SAAS,CAAC6C,IAAI,CAACwB,KAAK,CAAC;UACrBF,WAAW,CAACtB,IAAI,CAAC0B,QAAQ,CAAC,CAAC,EAAEjF,aAAa,EAAEQ,EAAE,CAAC,CAAC;UAChDsE,WAAW,CAACvB,IAAI,CAACyB,MAAM,IAAI,SAAS,CAAC;QACzC;QACA;AACZ;AACA;AACA;AACA;QACY,IAAIH,WAAW,CAAC,CAAC,CAAC,KAAK,CAAC,EAAE;UACtBA,WAAW,CAAC7B,OAAO,CAAC,CAAC,CAAC;UACtBtC,SAAS,CAACsC,OAAO,CAACtC,SAAS,CAAC,CAAC,CAAC,CAAC;UAC/BoE,WAAW,CAAC9B,OAAO,CAACvE,oBAAoB,CAAC;QAC7C;QACA;AACZ;AACA;AACA;AACA;QACY,IAAIoG,WAAW,CAACA,WAAW,CAAC9F,MAAM,GAAG,CAAC,CAAC,KAAK,CAAC,EAAE;UAC3C8F,WAAW,CAACtB,IAAI,CAAC,CAAC,CAAC;UACnB7C,SAAS,CAAC6C,IAAI,CAAC,IAAI,CAAC;QACxB;QACA,IAAI,CAAC9D,oBAAoB,CAACyF,GAAG,CAACR,OAAO,CAAC,EAAE;UACpCjF,oBAAoB,CAACU,GAAG,CAACuE,OAAO,EAAE;YAC9BhE,SAAS,EAAE,CAAC,CAAC;YACbC,UAAU,EAAE,CAAC;UACjB,CAAC,CAAC;QACN;QACA,MAAMwE,UAAU,GAAG1F,oBAAoB,CAAC2F,GAAG,CAACV,OAAO,CAAC;QACpDS,UAAU,CAACzE,SAAS,CAAC4D,GAAG,CAAC,GAAG5D,SAAS;QACrCyE,UAAU,CAACxE,UAAU,CAAC2D,GAAG,CAAC,GAAA7B,aAAA,CAAAA,aAAA,KACnBtD,iBAAiB;UACpBK,QAAQ,EAAEQ,aAAa;UACvB8B,IAAI,EAAEgD,WAAW;UACjBxD,KAAK,EAAEuD;QAAW,GACfzF,kBAAA,CACN;MACL;IACJ,CAAC,CAAC;IACF,OAAOK,oBAAoB;EAC/B;EACA,SAASuE,kBAAkBA,CAACvD,OAAO,EAAEd,SAAS,EAAE;IAC5C,CAACA,SAAS,CAACuF,GAAG,CAACzE,OAAO,CAAC,IAAId,SAAS,CAACQ,GAAG,CAACM,OAAO,EAAE,CAAC,CAAC,CAAC;IACrD,OAAOd,SAAS,CAACyF,GAAG,CAAC3E,OAAO,CAAC;EACjC;EACA,SAASwD,gBAAgBA,CAAC3D,IAAI,EAAEX,SAAS,EAAE;IACvC,IAAI,CAACA,SAAS,CAACW,IAAI,CAAC,EAChBX,SAAS,CAACW,IAAI,CAAC,GAAG,EAAE;IACxB,OAAOX,SAAS,CAACW,IAAI,CAAC;EAC1B;EACA,SAASc,eAAeA,CAACV,SAAS,EAAE;IAChC,OAAON,KAAK,CAACC,OAAO,CAACK,SAAS,CAAC,GAAGA,SAAS,GAAG,CAACA,SAAS,CAAC;EAC7D;EACA,SAAS6D,kBAAkBA,CAAC5D,UAAU,EAAE2D,GAAG,EAAE;IACzC,OAAO3D,UAAU,IAAIA,UAAU,CAAC2D,GAAG,CAAC,GAAA7B,aAAA,CAAAA,aAAA,KAEzB9B,UAAU,GACVA,UAAU,CAAC2D,GAAG,KAAA7B,aAAA,KAEd9B,UAAA,CAAY;EAC3B;EACA,MAAM0E,QAAQ,GAAIC,QAAQ,IAAK,OAAOA,QAAQ,KAAK,QAAQ;EAC3D,MAAMlD,sBAAsB,GAAI1B,SAAS,IAAKA,SAAS,CAAC6E,KAAK,CAACF,QAAQ,CAAC;AAAA,EAAAG,IAAA,OAAAC,MAAA","ignoreList":[]},"sourceType":"module","externalDependencies":{},"hash":"600f2075b0a105050052a48ce2925f66a44549ee"}
