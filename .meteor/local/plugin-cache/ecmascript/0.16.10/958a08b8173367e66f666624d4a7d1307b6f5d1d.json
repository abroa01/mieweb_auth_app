{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/anshul/Masters/Internship/POC/Meteor_Mobile/mieweb_push_auth/node_modules/framer-motion/dist/es/animation/generators/spring/index.mjs","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","topLevelAwait","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"web.browser"},"sourceFileName":"node_modules/framer-motion/dist/es/animation/generators/spring/index.mjs","filename":"/Users/anshul/Masters/Internship/POC/Meteor_Mobile/mieweb_push_auth/node_modules/framer-motion/dist/es/animation/generators/spring/index.mjs","inputSourceMap":{"version":3,"names":["calcGeneratorDuration","maxGeneratorDuration","generateLinearEasing","millisecondsToSeconds","secondsToMilliseconds","clamp","calcGeneratorVelocity","springDefaults","findSpring","calcAngularFreq","durationKeys","physicsKeys","isSpringType","options","keys","some","key","undefined","getSpringOptions","springOptions","velocity","stiffness","damping","mass","isResolvedFromDuration","visualDuration","root","Math","PI","bounce","sqrt","derived","spring","optionsOrVisualDuration","keyframes","restSpeed","restDelta","origin","target","length","state","done","value","duration","initialVelocity","dampingRatio","initialDelta","undampedAngularFreq","isGranularScale","abs","granular","default","resolveSpring","angularFreq","t","envelope","exp","sin","cos","dampedAngularFreq","freqForT","min","sinh","cosh","generator","calculatedDuration","next","current","currentVelocity","isBelowVelocityThreshold","isBelowDisplacementThreshold","toString","easing","progress"],"sources":["node_modules/framer-motion/dist/es/animation/generators/spring/index.mjs"],"sourcesContent":["import { calcGeneratorDuration, maxGeneratorDuration, generateLinearEasing } from 'motion-dom';\nimport { millisecondsToSeconds, secondsToMilliseconds } from 'motion-utils';\nimport { clamp } from '../../../utils/clamp.mjs';\nimport { calcGeneratorVelocity } from '../utils/velocity.mjs';\nimport { springDefaults } from './defaults.mjs';\nimport { findSpring, calcAngularFreq } from './find.mjs';\n\nconst durationKeys = [\"duration\", \"bounce\"];\nconst physicsKeys = [\"stiffness\", \"damping\", \"mass\"];\nfunction isSpringType(options, keys) {\n    return keys.some((key) => options[key] !== undefined);\n}\nfunction getSpringOptions(options) {\n    let springOptions = {\n        velocity: springDefaults.velocity,\n        stiffness: springDefaults.stiffness,\n        damping: springDefaults.damping,\n        mass: springDefaults.mass,\n        isResolvedFromDuration: false,\n        ...options,\n    };\n    // stiffness/damping/mass overrides duration/bounce\n    if (!isSpringType(options, physicsKeys) &&\n        isSpringType(options, durationKeys)) {\n        if (options.visualDuration) {\n            const visualDuration = options.visualDuration;\n            const root = (2 * Math.PI) / (visualDuration * 1.2);\n            const stiffness = root * root;\n            const damping = 2 *\n                clamp(0.05, 1, 1 - (options.bounce || 0)) *\n                Math.sqrt(stiffness);\n            springOptions = {\n                ...springOptions,\n                mass: springDefaults.mass,\n                stiffness,\n                damping,\n            };\n        }\n        else {\n            const derived = findSpring(options);\n            springOptions = {\n                ...springOptions,\n                ...derived,\n                mass: springDefaults.mass,\n            };\n            springOptions.isResolvedFromDuration = true;\n        }\n    }\n    return springOptions;\n}\nfunction spring(optionsOrVisualDuration = springDefaults.visualDuration, bounce = springDefaults.bounce) {\n    const options = typeof optionsOrVisualDuration !== \"object\"\n        ? {\n            visualDuration: optionsOrVisualDuration,\n            keyframes: [0, 1],\n            bounce,\n        }\n        : optionsOrVisualDuration;\n    let { restSpeed, restDelta } = options;\n    const origin = options.keyframes[0];\n    const target = options.keyframes[options.keyframes.length - 1];\n    /**\n     * This is the Iterator-spec return value. We ensure it's mutable rather than using a generator\n     * to reduce GC during animation.\n     */\n    const state = { done: false, value: origin };\n    const { stiffness, damping, mass, duration, velocity, isResolvedFromDuration, } = getSpringOptions({\n        ...options,\n        velocity: -millisecondsToSeconds(options.velocity || 0),\n    });\n    const initialVelocity = velocity || 0.0;\n    const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));\n    const initialDelta = target - origin;\n    const undampedAngularFreq = millisecondsToSeconds(Math.sqrt(stiffness / mass));\n    /**\n     * If we're working on a granular scale, use smaller defaults for determining\n     * when the spring is finished.\n     *\n     * These defaults have been selected emprically based on what strikes a good\n     * ratio between feeling good and finishing as soon as changes are imperceptible.\n     */\n    const isGranularScale = Math.abs(initialDelta) < 5;\n    restSpeed || (restSpeed = isGranularScale\n        ? springDefaults.restSpeed.granular\n        : springDefaults.restSpeed.default);\n    restDelta || (restDelta = isGranularScale\n        ? springDefaults.restDelta.granular\n        : springDefaults.restDelta.default);\n    let resolveSpring;\n    if (dampingRatio < 1) {\n        const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);\n        // Underdamped spring\n        resolveSpring = (t) => {\n            const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n            return (target -\n                envelope *\n                    (((initialVelocity +\n                        dampingRatio * undampedAngularFreq * initialDelta) /\n                        angularFreq) *\n                        Math.sin(angularFreq * t) +\n                        initialDelta * Math.cos(angularFreq * t)));\n        };\n    }\n    else if (dampingRatio === 1) {\n        // Critically damped spring\n        resolveSpring = (t) => target -\n            Math.exp(-undampedAngularFreq * t) *\n                (initialDelta +\n                    (initialVelocity + undampedAngularFreq * initialDelta) * t);\n    }\n    else {\n        // Overdamped spring\n        const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);\n        resolveSpring = (t) => {\n            const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n            // When performing sinh or cosh values can hit Infinity so we cap them here\n            const freqForT = Math.min(dampedAngularFreq * t, 300);\n            return (target -\n                (envelope *\n                    ((initialVelocity +\n                        dampingRatio * undampedAngularFreq * initialDelta) *\n                        Math.sinh(freqForT) +\n                        dampedAngularFreq *\n                            initialDelta *\n                            Math.cosh(freqForT))) /\n                    dampedAngularFreq);\n        };\n    }\n    const generator = {\n        calculatedDuration: isResolvedFromDuration ? duration || null : null,\n        next: (t) => {\n            const current = resolveSpring(t);\n            if (!isResolvedFromDuration) {\n                let currentVelocity = 0.0;\n                /**\n                 * We only need to calculate velocity for under-damped springs\n                 * as over- and critically-damped springs can't overshoot, so\n                 * checking only for displacement is enough.\n                 */\n                if (dampingRatio < 1) {\n                    currentVelocity =\n                        t === 0\n                            ? secondsToMilliseconds(initialVelocity)\n                            : calcGeneratorVelocity(resolveSpring, t, current);\n                }\n                const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;\n                const isBelowDisplacementThreshold = Math.abs(target - current) <= restDelta;\n                state.done =\n                    isBelowVelocityThreshold && isBelowDisplacementThreshold;\n            }\n            else {\n                state.done = t >= duration;\n            }\n            state.value = state.done ? target : current;\n            return state;\n        },\n        toString: () => {\n            const calculatedDuration = Math.min(calcGeneratorDuration(generator), maxGeneratorDuration);\n            const easing = generateLinearEasing((progress) => generator.next(calculatedDuration * progress).value, calculatedDuration, 30);\n            return calculatedDuration + \"ms \" + easing;\n        },\n    };\n    return generator;\n}\n\nexport { spring };\n"],"mappings":"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","ignoreList":[]},"targets":{},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/Users/anshul/Masters/Internship/POC/Meteor_Mobile/mieweb_push_auth","root":"/Users/anshul/Masters/Internship/POC/Meteor_Mobile/mieweb_push_auth","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true},"externalDependencies":[]},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.17.2","helpers":true,"useESModules":false,"corejs":false},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-react-jsx","visitor":{"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXFragment":{"exit":[null]},"JSXElement":{"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false},"externalDependencies":[]},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-nullish-coalescing-operator","visitor":{"LogicalExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-chaining","visitor":{"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-catch-binding","visitor":{"CatchClause":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"proposal-logical-assignment-operators","visitor":{"AssignmentExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]}],"presets":[],"generatorOpts":{"filename":"/Users/anshul/Masters/Internship/POC/Meteor_Mobile/mieweb_push_auth/node_modules/framer-motion/dist/es/animation/generators/spring/index.mjs","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"node_modules/framer-motion/dist/es/animation/generators/spring/index.mjs","inputSourceMap":{"version":3,"names":["calcGeneratorDuration","maxGeneratorDuration","generateLinearEasing","millisecondsToSeconds","secondsToMilliseconds","clamp","calcGeneratorVelocity","springDefaults","findSpring","calcAngularFreq","durationKeys","physicsKeys","isSpringType","options","keys","some","key","undefined","getSpringOptions","springOptions","velocity","stiffness","damping","mass","isResolvedFromDuration","visualDuration","root","Math","PI","bounce","sqrt","derived","spring","optionsOrVisualDuration","keyframes","restSpeed","restDelta","origin","target","length","state","done","value","duration","initialVelocity","dampingRatio","initialDelta","undampedAngularFreq","isGranularScale","abs","granular","default","resolveSpring","angularFreq","t","envelope","exp","sin","cos","dampedAngularFreq","freqForT","min","sinh","cosh","generator","calculatedDuration","next","current","currentVelocity","isBelowVelocityThreshold","isBelowDisplacementThreshold","toString","easing","progress"],"sources":["node_modules/framer-motion/dist/es/animation/generators/spring/index.mjs"],"sourcesContent":["import { calcGeneratorDuration, maxGeneratorDuration, generateLinearEasing } from 'motion-dom';\nimport { millisecondsToSeconds, secondsToMilliseconds } from 'motion-utils';\nimport { clamp } from '../../../utils/clamp.mjs';\nimport { calcGeneratorVelocity } from '../utils/velocity.mjs';\nimport { springDefaults } from './defaults.mjs';\nimport { findSpring, calcAngularFreq } from './find.mjs';\n\nconst durationKeys = [\"duration\", \"bounce\"];\nconst physicsKeys = [\"stiffness\", \"damping\", \"mass\"];\nfunction isSpringType(options, keys) {\n    return keys.some((key) => options[key] !== undefined);\n}\nfunction getSpringOptions(options) {\n    let springOptions = {\n        velocity: springDefaults.velocity,\n        stiffness: springDefaults.stiffness,\n        damping: springDefaults.damping,\n        mass: springDefaults.mass,\n        isResolvedFromDuration: false,\n        ...options,\n    };\n    // stiffness/damping/mass overrides duration/bounce\n    if (!isSpringType(options, physicsKeys) &&\n        isSpringType(options, durationKeys)) {\n        if (options.visualDuration) {\n            const visualDuration = options.visualDuration;\n            const root = (2 * Math.PI) / (visualDuration * 1.2);\n            const stiffness = root * root;\n            const damping = 2 *\n                clamp(0.05, 1, 1 - (options.bounce || 0)) *\n                Math.sqrt(stiffness);\n            springOptions = {\n                ...springOptions,\n                mass: springDefaults.mass,\n                stiffness,\n                damping,\n            };\n        }\n        else {\n            const derived = findSpring(options);\n            springOptions = {\n                ...springOptions,\n                ...derived,\n                mass: springDefaults.mass,\n            };\n            springOptions.isResolvedFromDuration = true;\n        }\n    }\n    return springOptions;\n}\nfunction spring(optionsOrVisualDuration = springDefaults.visualDuration, bounce = springDefaults.bounce) {\n    const options = typeof optionsOrVisualDuration !== \"object\"\n        ? {\n            visualDuration: optionsOrVisualDuration,\n            keyframes: [0, 1],\n            bounce,\n        }\n        : optionsOrVisualDuration;\n    let { restSpeed, restDelta } = options;\n    const origin = options.keyframes[0];\n    const target = options.keyframes[options.keyframes.length - 1];\n    /**\n     * This is the Iterator-spec return value. We ensure it's mutable rather than using a generator\n     * to reduce GC during animation.\n     */\n    const state = { done: false, value: origin };\n    const { stiffness, damping, mass, duration, velocity, isResolvedFromDuration, } = getSpringOptions({\n        ...options,\n        velocity: -millisecondsToSeconds(options.velocity || 0),\n    });\n    const initialVelocity = velocity || 0.0;\n    const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));\n    const initialDelta = target - origin;\n    const undampedAngularFreq = millisecondsToSeconds(Math.sqrt(stiffness / mass));\n    /**\n     * If we're working on a granular scale, use smaller defaults for determining\n     * when the spring is finished.\n     *\n     * These defaults have been selected emprically based on what strikes a good\n     * ratio between feeling good and finishing as soon as changes are imperceptible.\n     */\n    const isGranularScale = Math.abs(initialDelta) < 5;\n    restSpeed || (restSpeed = isGranularScale\n        ? springDefaults.restSpeed.granular\n        : springDefaults.restSpeed.default);\n    restDelta || (restDelta = isGranularScale\n        ? springDefaults.restDelta.granular\n        : springDefaults.restDelta.default);\n    let resolveSpring;\n    if (dampingRatio < 1) {\n        const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);\n        // Underdamped spring\n        resolveSpring = (t) => {\n            const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n            return (target -\n                envelope *\n                    (((initialVelocity +\n                        dampingRatio * undampedAngularFreq * initialDelta) /\n                        angularFreq) *\n                        Math.sin(angularFreq * t) +\n                        initialDelta * Math.cos(angularFreq * t)));\n        };\n    }\n    else if (dampingRatio === 1) {\n        // Critically damped spring\n        resolveSpring = (t) => target -\n            Math.exp(-undampedAngularFreq * t) *\n                (initialDelta +\n                    (initialVelocity + undampedAngularFreq * initialDelta) * t);\n    }\n    else {\n        // Overdamped spring\n        const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);\n        resolveSpring = (t) => {\n            const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n            // When performing sinh or cosh values can hit Infinity so we cap them here\n            const freqForT = Math.min(dampedAngularFreq * t, 300);\n            return (target -\n                (envelope *\n                    ((initialVelocity +\n                        dampingRatio * undampedAngularFreq * initialDelta) *\n                        Math.sinh(freqForT) +\n                        dampedAngularFreq *\n                            initialDelta *\n                            Math.cosh(freqForT))) /\n                    dampedAngularFreq);\n        };\n    }\n    const generator = {\n        calculatedDuration: isResolvedFromDuration ? duration || null : null,\n        next: (t) => {\n            const current = resolveSpring(t);\n            if (!isResolvedFromDuration) {\n                let currentVelocity = 0.0;\n                /**\n                 * We only need to calculate velocity for under-damped springs\n                 * as over- and critically-damped springs can't overshoot, so\n                 * checking only for displacement is enough.\n                 */\n                if (dampingRatio < 1) {\n                    currentVelocity =\n                        t === 0\n                            ? secondsToMilliseconds(initialVelocity)\n                            : calcGeneratorVelocity(resolveSpring, t, current);\n                }\n                const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;\n                const isBelowDisplacementThreshold = Math.abs(target - current) <= restDelta;\n                state.done =\n                    isBelowVelocityThreshold && isBelowDisplacementThreshold;\n            }\n            else {\n                state.done = t >= duration;\n            }\n            state.value = state.done ? target : current;\n            return state;\n        },\n        toString: () => {\n            const calculatedDuration = Math.min(calcGeneratorDuration(generator), maxGeneratorDuration);\n            const easing = generateLinearEasing((progress) => generator.next(calculatedDuration * progress).value, calculatedDuration, 30);\n            return calculatedDuration + \"ms \" + easing;\n        },\n    };\n    return generator;\n}\n\nexport { spring };\n"],"mappings":"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","ignoreList":[]}}},"code":"!function (module1) {\n  let _objectSpread;\n  module1.link(\"@babel/runtime/helpers/objectSpread2\", {\n    default(v) {\n      _objectSpread = v;\n    }\n  }, 0);\n  module1.export({\n    spring: () => spring\n  });\n  let calcGeneratorDuration, maxGeneratorDuration, generateLinearEasing;\n  module1.link(\"motion-dom\", {\n    calcGeneratorDuration(v) {\n      calcGeneratorDuration = v;\n    },\n    maxGeneratorDuration(v) {\n      maxGeneratorDuration = v;\n    },\n    generateLinearEasing(v) {\n      generateLinearEasing = v;\n    }\n  }, 0);\n  let millisecondsToSeconds, secondsToMilliseconds;\n  module1.link(\"motion-utils\", {\n    millisecondsToSeconds(v) {\n      millisecondsToSeconds = v;\n    },\n    secondsToMilliseconds(v) {\n      secondsToMilliseconds = v;\n    }\n  }, 1);\n  let clamp;\n  module1.link(\"../../../utils/clamp.mjs\", {\n    clamp(v) {\n      clamp = v;\n    }\n  }, 2);\n  let calcGeneratorVelocity;\n  module1.link(\"../utils/velocity.mjs\", {\n    calcGeneratorVelocity(v) {\n      calcGeneratorVelocity = v;\n    }\n  }, 3);\n  let springDefaults;\n  module1.link(\"./defaults.mjs\", {\n    springDefaults(v) {\n      springDefaults = v;\n    }\n  }, 4);\n  let findSpring, calcAngularFreq;\n  module1.link(\"./find.mjs\", {\n    findSpring(v) {\n      findSpring = v;\n    },\n    calcAngularFreq(v) {\n      calcAngularFreq = v;\n    }\n  }, 5);\n  ___INIT_METEOR_FAST_REFRESH(module);\n  const durationKeys = [\"duration\", \"bounce\"];\n  const physicsKeys = [\"stiffness\", \"damping\", \"mass\"];\n  function isSpringType(options, keys) {\n    return keys.some(key => options[key] !== undefined);\n  }\n  function getSpringOptions(options) {\n    let springOptions = _objectSpread({\n      velocity: springDefaults.velocity,\n      stiffness: springDefaults.stiffness,\n      damping: springDefaults.damping,\n      mass: springDefaults.mass,\n      isResolvedFromDuration: false\n    }, options);\n    // stiffness/damping/mass overrides duration/bounce\n    if (!isSpringType(options, physicsKeys) && isSpringType(options, durationKeys)) {\n      if (options.visualDuration) {\n        const visualDuration = options.visualDuration;\n        const root = 2 * Math.PI / (visualDuration * 1.2);\n        const stiffness = root * root;\n        const damping = 2 * clamp(0.05, 1, 1 - (options.bounce || 0)) * Math.sqrt(stiffness);\n        springOptions = _objectSpread(_objectSpread({}, springOptions), {}, {\n          mass: springDefaults.mass,\n          stiffness,\n          damping\n        });\n      } else {\n        const derived = findSpring(options);\n        springOptions = _objectSpread(_objectSpread(_objectSpread({}, springOptions), derived), {}, {\n          mass: springDefaults.mass\n        });\n        springOptions.isResolvedFromDuration = true;\n      }\n    }\n    return springOptions;\n  }\n  function spring() {\n    let optionsOrVisualDuration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : springDefaults.visualDuration;\n    let bounce = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : springDefaults.bounce;\n    const options = typeof optionsOrVisualDuration !== \"object\" ? {\n      visualDuration: optionsOrVisualDuration,\n      keyframes: [0, 1],\n      bounce\n    } : optionsOrVisualDuration;\n    let {\n      restSpeed,\n      restDelta\n    } = options;\n    const origin = options.keyframes[0];\n    const target = options.keyframes[options.keyframes.length - 1];\n    /**\n     * This is the Iterator-spec return value. We ensure it's mutable rather than using a generator\n     * to reduce GC during animation.\n     */\n    const state = {\n      done: false,\n      value: origin\n    };\n    const {\n      stiffness,\n      damping,\n      mass,\n      duration,\n      velocity,\n      isResolvedFromDuration\n    } = getSpringOptions(_objectSpread(_objectSpread({}, options), {}, {\n      velocity: -millisecondsToSeconds(options.velocity || 0)\n    }));\n    const initialVelocity = velocity || 0.0;\n    const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));\n    const initialDelta = target - origin;\n    const undampedAngularFreq = millisecondsToSeconds(Math.sqrt(stiffness / mass));\n    /**\n     * If we're working on a granular scale, use smaller defaults for determining\n     * when the spring is finished.\n     *\n     * These defaults have been selected emprically based on what strikes a good\n     * ratio between feeling good and finishing as soon as changes are imperceptible.\n     */\n    const isGranularScale = Math.abs(initialDelta) < 5;\n    restSpeed || (restSpeed = isGranularScale ? springDefaults.restSpeed.granular : springDefaults.restSpeed.default);\n    restDelta || (restDelta = isGranularScale ? springDefaults.restDelta.granular : springDefaults.restDelta.default);\n    let resolveSpring;\n    if (dampingRatio < 1) {\n      const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);\n      // Underdamped spring\n      resolveSpring = t => {\n        const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n        return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq * Math.sin(angularFreq * t) + initialDelta * Math.cos(angularFreq * t));\n      };\n    } else if (dampingRatio === 1) {\n      // Critically damped spring\n      resolveSpring = t => target - Math.exp(-undampedAngularFreq * t) * (initialDelta + (initialVelocity + undampedAngularFreq * initialDelta) * t);\n    } else {\n      // Overdamped spring\n      const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);\n      resolveSpring = t => {\n        const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n        // When performing sinh or cosh values can hit Infinity so we cap them here\n        const freqForT = Math.min(dampedAngularFreq * t, 300);\n        return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) * Math.sinh(freqForT) + dampedAngularFreq * initialDelta * Math.cosh(freqForT)) / dampedAngularFreq;\n      };\n    }\n    const generator = {\n      calculatedDuration: isResolvedFromDuration ? duration || null : null,\n      next: t => {\n        const current = resolveSpring(t);\n        if (!isResolvedFromDuration) {\n          let currentVelocity = 0.0;\n          /**\n           * We only need to calculate velocity for under-damped springs\n           * as over- and critically-damped springs can't overshoot, so\n           * checking only for displacement is enough.\n           */\n          if (dampingRatio < 1) {\n            currentVelocity = t === 0 ? secondsToMilliseconds(initialVelocity) : calcGeneratorVelocity(resolveSpring, t, current);\n          }\n          const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;\n          const isBelowDisplacementThreshold = Math.abs(target - current) <= restDelta;\n          state.done = isBelowVelocityThreshold && isBelowDisplacementThreshold;\n        } else {\n          state.done = t >= duration;\n        }\n        state.value = state.done ? target : current;\n        return state;\n      },\n      toString: () => {\n        const calculatedDuration = Math.min(calcGeneratorDuration(generator), maxGeneratorDuration);\n        const easing = generateLinearEasing(progress => generator.next(calculatedDuration * progress).value, calculatedDuration, 30);\n        return calculatedDuration + \"ms \" + easing;\n      }\n    };\n    return generator;\n  }\n}.call(this, module);","map":{"version":3,"names":["durationKeys","physicsKeys","isSpringType","options","keys","some","key","undefined","getSpringOptions","springOptions","_objectSpread","velocity","springDefaults","stiffness","damping","mass","isResolvedFromDuration","visualDuration","root","Math","PI","clamp","bounce","sqrt","derived","findSpring","spring","optionsOrVisualDuration","arguments","length","keyframes","restSpeed","restDelta","origin","target","state","done","value","duration","millisecondsToSeconds","initialVelocity","dampingRatio","initialDelta","undampedAngularFreq","isGranularScale","abs","granular","default","resolveSpring","angularFreq","calcAngularFreq","t","envelope","exp","sin","cos","dampedAngularFreq","freqForT","min","sinh","cosh","generator","calculatedDuration","next","current","currentVelocity","secondsToMilliseconds","calcGeneratorVelocity","isBelowVelocityThreshold","isBelowDisplacementThreshold","toString","calcGeneratorDuration","maxGeneratorDuration","easing","generateLinearEasing","progress","call","module"],"sources":["node_modules/framer-motion/dist/es/animation/generators/spring/index.mjs"],"sourcesContent":["import { calcGeneratorDuration, maxGeneratorDuration, generateLinearEasing } from 'motion-dom';\nimport { millisecondsToSeconds, secondsToMilliseconds } from 'motion-utils';\nimport { clamp } from '../../../utils/clamp.mjs';\nimport { calcGeneratorVelocity } from '../utils/velocity.mjs';\nimport { springDefaults } from './defaults.mjs';\nimport { findSpring, calcAngularFreq } from './find.mjs';\n\nconst durationKeys = [\"duration\", \"bounce\"];\nconst physicsKeys = [\"stiffness\", \"damping\", \"mass\"];\nfunction isSpringType(options, keys) {\n    return keys.some((key) => options[key] !== undefined);\n}\nfunction getSpringOptions(options) {\n    let springOptions = {\n        velocity: springDefaults.velocity,\n        stiffness: springDefaults.stiffness,\n        damping: springDefaults.damping,\n        mass: springDefaults.mass,\n        isResolvedFromDuration: false,\n        ...options,\n    };\n    // stiffness/damping/mass overrides duration/bounce\n    if (!isSpringType(options, physicsKeys) &&\n        isSpringType(options, durationKeys)) {\n        if (options.visualDuration) {\n            const visualDuration = options.visualDuration;\n            const root = (2 * Math.PI) / (visualDuration * 1.2);\n            const stiffness = root * root;\n            const damping = 2 *\n                clamp(0.05, 1, 1 - (options.bounce || 0)) *\n                Math.sqrt(stiffness);\n            springOptions = {\n                ...springOptions,\n                mass: springDefaults.mass,\n                stiffness,\n                damping,\n            };\n        }\n        else {\n            const derived = findSpring(options);\n            springOptions = {\n                ...springOptions,\n                ...derived,\n                mass: springDefaults.mass,\n            };\n            springOptions.isResolvedFromDuration = true;\n        }\n    }\n    return springOptions;\n}\nfunction spring(optionsOrVisualDuration = springDefaults.visualDuration, bounce = springDefaults.bounce) {\n    const options = typeof optionsOrVisualDuration !== \"object\"\n        ? {\n            visualDuration: optionsOrVisualDuration,\n            keyframes: [0, 1],\n            bounce,\n        }\n        : optionsOrVisualDuration;\n    let { restSpeed, restDelta } = options;\n    const origin = options.keyframes[0];\n    const target = options.keyframes[options.keyframes.length - 1];\n    /**\n     * This is the Iterator-spec return value. We ensure it's mutable rather than using a generator\n     * to reduce GC during animation.\n     */\n    const state = { done: false, value: origin };\n    const { stiffness, damping, mass, duration, velocity, isResolvedFromDuration, } = getSpringOptions({\n        ...options,\n        velocity: -millisecondsToSeconds(options.velocity || 0),\n    });\n    const initialVelocity = velocity || 0.0;\n    const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));\n    const initialDelta = target - origin;\n    const undampedAngularFreq = millisecondsToSeconds(Math.sqrt(stiffness / mass));\n    /**\n     * If we're working on a granular scale, use smaller defaults for determining\n     * when the spring is finished.\n     *\n     * These defaults have been selected emprically based on what strikes a good\n     * ratio between feeling good and finishing as soon as changes are imperceptible.\n     */\n    const isGranularScale = Math.abs(initialDelta) < 5;\n    restSpeed || (restSpeed = isGranularScale\n        ? springDefaults.restSpeed.granular\n        : springDefaults.restSpeed.default);\n    restDelta || (restDelta = isGranularScale\n        ? springDefaults.restDelta.granular\n        : springDefaults.restDelta.default);\n    let resolveSpring;\n    if (dampingRatio < 1) {\n        const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);\n        // Underdamped spring\n        resolveSpring = (t) => {\n            const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n            return (target -\n                envelope *\n                    (((initialVelocity +\n                        dampingRatio * undampedAngularFreq * initialDelta) /\n                        angularFreq) *\n                        Math.sin(angularFreq * t) +\n                        initialDelta * Math.cos(angularFreq * t)));\n        };\n    }\n    else if (dampingRatio === 1) {\n        // Critically damped spring\n        resolveSpring = (t) => target -\n            Math.exp(-undampedAngularFreq * t) *\n                (initialDelta +\n                    (initialVelocity + undampedAngularFreq * initialDelta) * t);\n    }\n    else {\n        // Overdamped spring\n        const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);\n        resolveSpring = (t) => {\n            const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n            // When performing sinh or cosh values can hit Infinity so we cap them here\n            const freqForT = Math.min(dampedAngularFreq * t, 300);\n            return (target -\n                (envelope *\n                    ((initialVelocity +\n                        dampingRatio * undampedAngularFreq * initialDelta) *\n                        Math.sinh(freqForT) +\n                        dampedAngularFreq *\n                            initialDelta *\n                            Math.cosh(freqForT))) /\n                    dampedAngularFreq);\n        };\n    }\n    const generator = {\n        calculatedDuration: isResolvedFromDuration ? duration || null : null,\n        next: (t) => {\n            const current = resolveSpring(t);\n            if (!isResolvedFromDuration) {\n                let currentVelocity = 0.0;\n                /**\n                 * We only need to calculate velocity for under-damped springs\n                 * as over- and critically-damped springs can't overshoot, so\n                 * checking only for displacement is enough.\n                 */\n                if (dampingRatio < 1) {\n                    currentVelocity =\n                        t === 0\n                            ? secondsToMilliseconds(initialVelocity)\n                            : calcGeneratorVelocity(resolveSpring, t, current);\n                }\n                const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;\n                const isBelowDisplacementThreshold = Math.abs(target - current) <= restDelta;\n                state.done =\n                    isBelowVelocityThreshold && isBelowDisplacementThreshold;\n            }\n            else {\n                state.done = t >= duration;\n            }\n            state.value = state.done ? target : current;\n            return state;\n        },\n        toString: () => {\n            const calculatedDuration = Math.min(calcGeneratorDuration(generator), maxGeneratorDuration);\n            const easing = generateLinearEasing((progress) => generator.next(calculatedDuration * progress).value, calculatedDuration, 30);\n            return calculatedDuration + \"ms \" + easing;\n        },\n    };\n    return generator;\n}\n\nexport { spring };\n"],"mappings":"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","ignoreList":[]},"sourceType":"module","externalDependencies":{},"hash":"958a08b8173367e66f666624d4a7d1307b6f5d1d"}
