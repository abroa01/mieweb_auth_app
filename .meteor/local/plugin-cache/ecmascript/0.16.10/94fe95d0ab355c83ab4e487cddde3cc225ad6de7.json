{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/anshul/Masters/Internship/POC/Meteor_Mobile/mieweb_push_auth/node_modules/framer-motion/dist/es/gestures/pan/PanSession.mjs","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","topLevelAwait","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"web.browser"},"sourceFileName":"node_modules/framer-motion/dist/es/gestures/pan/PanSession.mjs","filename":"/Users/anshul/Masters/Internship/POC/Meteor_Mobile/mieweb_push_auth/node_modules/framer-motion/dist/es/gestures/pan/PanSession.mjs","inputSourceMap":{"version":3,"names":["extractEventInfo","secondsToMilliseconds","millisecondsToSeconds","addPointerEvent","pipe","distance2D","isPrimaryPointer","frame","cancelFrame","frameData","PanSession","constructor","event","handlers","transformPagePoint","contextWindow","dragSnapToOrigin","startEvent","lastMoveEvent","lastMoveEventInfo","window","updatePoint","info","getPanInfo","history","isPanStarted","isDistancePastThreshold","offset","x","y","point","timestamp","push","onStart","onMove","handlePointerMove","transformPoint","update","handlePointerUp","end","onEnd","onSessionEnd","resumeAnimation","panInfo","type","initialInfo","onSessionStart","removeListeners","updateHandlers","subtractPoint","a","b","delta","lastDevicePoint","startDevicePoint","velocity","getVelocity","length","timeDelta","i","timestampedPoint","lastPoint","time","currentVelocity","Infinity"],"sources":["node_modules/framer-motion/dist/es/gestures/pan/PanSession.mjs"],"sourcesContent":["import { extractEventInfo } from '../../events/event-info.mjs';\nimport { secondsToMilliseconds, millisecondsToSeconds } from '../../utils/time-conversion.mjs';\nimport { addPointerEvent } from '../../events/add-pointer-event.mjs';\nimport { pipe } from '../../utils/pipe.mjs';\nimport { distance2D } from '../../utils/distance.mjs';\nimport { isPrimaryPointer } from 'motion-dom';\nimport { frame, cancelFrame, frameData } from '../../frameloop/frame.mjs';\n\n/**\n * @internal\n */\nclass PanSession {\n    constructor(event, handlers, { transformPagePoint, contextWindow, dragSnapToOrigin = false, } = {}) {\n        /**\n         * @internal\n         */\n        this.startEvent = null;\n        /**\n         * @internal\n         */\n        this.lastMoveEvent = null;\n        /**\n         * @internal\n         */\n        this.lastMoveEventInfo = null;\n        /**\n         * @internal\n         */\n        this.handlers = {};\n        /**\n         * @internal\n         */\n        this.contextWindow = window;\n        this.updatePoint = () => {\n            if (!(this.lastMoveEvent && this.lastMoveEventInfo))\n                return;\n            const info = getPanInfo(this.lastMoveEventInfo, this.history);\n            const isPanStarted = this.startEvent !== null;\n            // Only start panning if the offset is larger than 3 pixels. If we make it\n            // any larger than this we'll want to reset the pointer history\n            // on the first update to avoid visual snapping to the cursoe.\n            const isDistancePastThreshold = distance2D(info.offset, { x: 0, y: 0 }) >= 3;\n            if (!isPanStarted && !isDistancePastThreshold)\n                return;\n            const { point } = info;\n            const { timestamp } = frameData;\n            this.history.push({ ...point, timestamp });\n            const { onStart, onMove } = this.handlers;\n            if (!isPanStarted) {\n                onStart && onStart(this.lastMoveEvent, info);\n                this.startEvent = this.lastMoveEvent;\n            }\n            onMove && onMove(this.lastMoveEvent, info);\n        };\n        this.handlePointerMove = (event, info) => {\n            this.lastMoveEvent = event;\n            this.lastMoveEventInfo = transformPoint(info, this.transformPagePoint);\n            // Throttle mouse move event to once per frame\n            frame.update(this.updatePoint, true);\n        };\n        this.handlePointerUp = (event, info) => {\n            this.end();\n            const { onEnd, onSessionEnd, resumeAnimation } = this.handlers;\n            if (this.dragSnapToOrigin)\n                resumeAnimation && resumeAnimation();\n            if (!(this.lastMoveEvent && this.lastMoveEventInfo))\n                return;\n            const panInfo = getPanInfo(event.type === \"pointercancel\"\n                ? this.lastMoveEventInfo\n                : transformPoint(info, this.transformPagePoint), this.history);\n            if (this.startEvent && onEnd) {\n                onEnd(event, panInfo);\n            }\n            onSessionEnd && onSessionEnd(event, panInfo);\n        };\n        // If we have more than one touch, don't start detecting this gesture\n        if (!isPrimaryPointer(event))\n            return;\n        this.dragSnapToOrigin = dragSnapToOrigin;\n        this.handlers = handlers;\n        this.transformPagePoint = transformPagePoint;\n        this.contextWindow = contextWindow || window;\n        const info = extractEventInfo(event);\n        const initialInfo = transformPoint(info, this.transformPagePoint);\n        const { point } = initialInfo;\n        const { timestamp } = frameData;\n        this.history = [{ ...point, timestamp }];\n        const { onSessionStart } = handlers;\n        onSessionStart &&\n            onSessionStart(event, getPanInfo(initialInfo, this.history));\n        this.removeListeners = pipe(addPointerEvent(this.contextWindow, \"pointermove\", this.handlePointerMove), addPointerEvent(this.contextWindow, \"pointerup\", this.handlePointerUp), addPointerEvent(this.contextWindow, \"pointercancel\", this.handlePointerUp));\n    }\n    updateHandlers(handlers) {\n        this.handlers = handlers;\n    }\n    end() {\n        this.removeListeners && this.removeListeners();\n        cancelFrame(this.updatePoint);\n    }\n}\nfunction transformPoint(info, transformPagePoint) {\n    return transformPagePoint ? { point: transformPagePoint(info.point) } : info;\n}\nfunction subtractPoint(a, b) {\n    return { x: a.x - b.x, y: a.y - b.y };\n}\nfunction getPanInfo({ point }, history) {\n    return {\n        point,\n        delta: subtractPoint(point, lastDevicePoint(history)),\n        offset: subtractPoint(point, startDevicePoint(history)),\n        velocity: getVelocity(history, 0.1),\n    };\n}\nfunction startDevicePoint(history) {\n    return history[0];\n}\nfunction lastDevicePoint(history) {\n    return history[history.length - 1];\n}\nfunction getVelocity(history, timeDelta) {\n    if (history.length < 2) {\n        return { x: 0, y: 0 };\n    }\n    let i = history.length - 1;\n    let timestampedPoint = null;\n    const lastPoint = lastDevicePoint(history);\n    while (i >= 0) {\n        timestampedPoint = history[i];\n        if (lastPoint.timestamp - timestampedPoint.timestamp >\n            secondsToMilliseconds(timeDelta)) {\n            break;\n        }\n        i--;\n    }\n    if (!timestampedPoint) {\n        return { x: 0, y: 0 };\n    }\n    const time = millisecondsToSeconds(lastPoint.timestamp - timestampedPoint.timestamp);\n    if (time === 0) {\n        return { x: 0, y: 0 };\n    }\n    const currentVelocity = {\n        x: (lastPoint.x - timestampedPoint.x) / time,\n        y: (lastPoint.y - timestampedPoint.y) / time,\n    };\n    if (currentVelocity.x === Infinity) {\n        currentVelocity.x = 0;\n    }\n    if (currentVelocity.y === Infinity) {\n        currentVelocity.y = 0;\n    }\n    return currentVelocity;\n}\n\nexport { PanSession };\n"],"mappings":"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","ignoreList":[]},"targets":{},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/Users/anshul/Masters/Internship/POC/Meteor_Mobile/mieweb_push_auth","root":"/Users/anshul/Masters/Internship/POC/Meteor_Mobile/mieweb_push_auth","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true},"externalDependencies":[]},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.17.2","helpers":true,"useESModules":false,"corejs":false},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-react-jsx","visitor":{"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXFragment":{"exit":[null]},"JSXElement":{"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false},"externalDependencies":[]},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-nullish-coalescing-operator","visitor":{"LogicalExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-chaining","visitor":{"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-catch-binding","visitor":{"CatchClause":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"proposal-logical-assignment-operators","visitor":{"AssignmentExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]}],"presets":[],"generatorOpts":{"filename":"/Users/anshul/Masters/Internship/POC/Meteor_Mobile/mieweb_push_auth/node_modules/framer-motion/dist/es/gestures/pan/PanSession.mjs","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"node_modules/framer-motion/dist/es/gestures/pan/PanSession.mjs","inputSourceMap":{"version":3,"names":["extractEventInfo","secondsToMilliseconds","millisecondsToSeconds","addPointerEvent","pipe","distance2D","isPrimaryPointer","frame","cancelFrame","frameData","PanSession","constructor","event","handlers","transformPagePoint","contextWindow","dragSnapToOrigin","startEvent","lastMoveEvent","lastMoveEventInfo","window","updatePoint","info","getPanInfo","history","isPanStarted","isDistancePastThreshold","offset","x","y","point","timestamp","push","onStart","onMove","handlePointerMove","transformPoint","update","handlePointerUp","end","onEnd","onSessionEnd","resumeAnimation","panInfo","type","initialInfo","onSessionStart","removeListeners","updateHandlers","subtractPoint","a","b","delta","lastDevicePoint","startDevicePoint","velocity","getVelocity","length","timeDelta","i","timestampedPoint","lastPoint","time","currentVelocity","Infinity"],"sources":["node_modules/framer-motion/dist/es/gestures/pan/PanSession.mjs"],"sourcesContent":["import { extractEventInfo } from '../../events/event-info.mjs';\nimport { secondsToMilliseconds, millisecondsToSeconds } from '../../utils/time-conversion.mjs';\nimport { addPointerEvent } from '../../events/add-pointer-event.mjs';\nimport { pipe } from '../../utils/pipe.mjs';\nimport { distance2D } from '../../utils/distance.mjs';\nimport { isPrimaryPointer } from 'motion-dom';\nimport { frame, cancelFrame, frameData } from '../../frameloop/frame.mjs';\n\n/**\n * @internal\n */\nclass PanSession {\n    constructor(event, handlers, { transformPagePoint, contextWindow, dragSnapToOrigin = false, } = {}) {\n        /**\n         * @internal\n         */\n        this.startEvent = null;\n        /**\n         * @internal\n         */\n        this.lastMoveEvent = null;\n        /**\n         * @internal\n         */\n        this.lastMoveEventInfo = null;\n        /**\n         * @internal\n         */\n        this.handlers = {};\n        /**\n         * @internal\n         */\n        this.contextWindow = window;\n        this.updatePoint = () => {\n            if (!(this.lastMoveEvent && this.lastMoveEventInfo))\n                return;\n            const info = getPanInfo(this.lastMoveEventInfo, this.history);\n            const isPanStarted = this.startEvent !== null;\n            // Only start panning if the offset is larger than 3 pixels. If we make it\n            // any larger than this we'll want to reset the pointer history\n            // on the first update to avoid visual snapping to the cursoe.\n            const isDistancePastThreshold = distance2D(info.offset, { x: 0, y: 0 }) >= 3;\n            if (!isPanStarted && !isDistancePastThreshold)\n                return;\n            const { point } = info;\n            const { timestamp } = frameData;\n            this.history.push({ ...point, timestamp });\n            const { onStart, onMove } = this.handlers;\n            if (!isPanStarted) {\n                onStart && onStart(this.lastMoveEvent, info);\n                this.startEvent = this.lastMoveEvent;\n            }\n            onMove && onMove(this.lastMoveEvent, info);\n        };\n        this.handlePointerMove = (event, info) => {\n            this.lastMoveEvent = event;\n            this.lastMoveEventInfo = transformPoint(info, this.transformPagePoint);\n            // Throttle mouse move event to once per frame\n            frame.update(this.updatePoint, true);\n        };\n        this.handlePointerUp = (event, info) => {\n            this.end();\n            const { onEnd, onSessionEnd, resumeAnimation } = this.handlers;\n            if (this.dragSnapToOrigin)\n                resumeAnimation && resumeAnimation();\n            if (!(this.lastMoveEvent && this.lastMoveEventInfo))\n                return;\n            const panInfo = getPanInfo(event.type === \"pointercancel\"\n                ? this.lastMoveEventInfo\n                : transformPoint(info, this.transformPagePoint), this.history);\n            if (this.startEvent && onEnd) {\n                onEnd(event, panInfo);\n            }\n            onSessionEnd && onSessionEnd(event, panInfo);\n        };\n        // If we have more than one touch, don't start detecting this gesture\n        if (!isPrimaryPointer(event))\n            return;\n        this.dragSnapToOrigin = dragSnapToOrigin;\n        this.handlers = handlers;\n        this.transformPagePoint = transformPagePoint;\n        this.contextWindow = contextWindow || window;\n        const info = extractEventInfo(event);\n        const initialInfo = transformPoint(info, this.transformPagePoint);\n        const { point } = initialInfo;\n        const { timestamp } = frameData;\n        this.history = [{ ...point, timestamp }];\n        const { onSessionStart } = handlers;\n        onSessionStart &&\n            onSessionStart(event, getPanInfo(initialInfo, this.history));\n        this.removeListeners = pipe(addPointerEvent(this.contextWindow, \"pointermove\", this.handlePointerMove), addPointerEvent(this.contextWindow, \"pointerup\", this.handlePointerUp), addPointerEvent(this.contextWindow, \"pointercancel\", this.handlePointerUp));\n    }\n    updateHandlers(handlers) {\n        this.handlers = handlers;\n    }\n    end() {\n        this.removeListeners && this.removeListeners();\n        cancelFrame(this.updatePoint);\n    }\n}\nfunction transformPoint(info, transformPagePoint) {\n    return transformPagePoint ? { point: transformPagePoint(info.point) } : info;\n}\nfunction subtractPoint(a, b) {\n    return { x: a.x - b.x, y: a.y - b.y };\n}\nfunction getPanInfo({ point }, history) {\n    return {\n        point,\n        delta: subtractPoint(point, lastDevicePoint(history)),\n        offset: subtractPoint(point, startDevicePoint(history)),\n        velocity: getVelocity(history, 0.1),\n    };\n}\nfunction startDevicePoint(history) {\n    return history[0];\n}\nfunction lastDevicePoint(history) {\n    return history[history.length - 1];\n}\nfunction getVelocity(history, timeDelta) {\n    if (history.length < 2) {\n        return { x: 0, y: 0 };\n    }\n    let i = history.length - 1;\n    let timestampedPoint = null;\n    const lastPoint = lastDevicePoint(history);\n    while (i >= 0) {\n        timestampedPoint = history[i];\n        if (lastPoint.timestamp - timestampedPoint.timestamp >\n            secondsToMilliseconds(timeDelta)) {\n            break;\n        }\n        i--;\n    }\n    if (!timestampedPoint) {\n        return { x: 0, y: 0 };\n    }\n    const time = millisecondsToSeconds(lastPoint.timestamp - timestampedPoint.timestamp);\n    if (time === 0) {\n        return { x: 0, y: 0 };\n    }\n    const currentVelocity = {\n        x: (lastPoint.x - timestampedPoint.x) / time,\n        y: (lastPoint.y - timestampedPoint.y) / time,\n    };\n    if (currentVelocity.x === Infinity) {\n        currentVelocity.x = 0;\n    }\n    if (currentVelocity.y === Infinity) {\n        currentVelocity.y = 0;\n    }\n    return currentVelocity;\n}\n\nexport { PanSession };\n"],"mappings":"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","ignoreList":[]}}},"code":"!function (module1) {\n  let _objectSpread;\n  module1.link(\"@babel/runtime/helpers/objectSpread2\", {\n    default(v) {\n      _objectSpread = v;\n    }\n  }, 0);\n  module1.export({\n    PanSession: () => PanSession\n  });\n  let extractEventInfo;\n  module1.link(\"../../events/event-info.mjs\", {\n    extractEventInfo(v) {\n      extractEventInfo = v;\n    }\n  }, 0);\n  let secondsToMilliseconds, millisecondsToSeconds;\n  module1.link(\"../../utils/time-conversion.mjs\", {\n    secondsToMilliseconds(v) {\n      secondsToMilliseconds = v;\n    },\n    millisecondsToSeconds(v) {\n      millisecondsToSeconds = v;\n    }\n  }, 1);\n  let addPointerEvent;\n  module1.link(\"../../events/add-pointer-event.mjs\", {\n    addPointerEvent(v) {\n      addPointerEvent = v;\n    }\n  }, 2);\n  let pipe;\n  module1.link(\"../../utils/pipe.mjs\", {\n    pipe(v) {\n      pipe = v;\n    }\n  }, 3);\n  let distance2D;\n  module1.link(\"../../utils/distance.mjs\", {\n    distance2D(v) {\n      distance2D = v;\n    }\n  }, 4);\n  let isPrimaryPointer;\n  module1.link(\"motion-dom\", {\n    isPrimaryPointer(v) {\n      isPrimaryPointer = v;\n    }\n  }, 5);\n  let frame, cancelFrame, frameData;\n  module1.link(\"../../frameloop/frame.mjs\", {\n    frame(v) {\n      frame = v;\n    },\n    cancelFrame(v) {\n      cancelFrame = v;\n    },\n    frameData(v) {\n      frameData = v;\n    }\n  }, 6);\n  ___INIT_METEOR_FAST_REFRESH(module);\n  /**\n   * @internal\n   */\n  class PanSession {\n    constructor(event, handlers) {\n      let {\n        transformPagePoint,\n        contextWindow,\n        dragSnapToOrigin = false\n      } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      /**\n       * @internal\n       */\n      this.startEvent = null;\n      /**\n       * @internal\n       */\n      this.lastMoveEvent = null;\n      /**\n       * @internal\n       */\n      this.lastMoveEventInfo = null;\n      /**\n       * @internal\n       */\n      this.handlers = {};\n      /**\n       * @internal\n       */\n      this.contextWindow = window;\n      this.updatePoint = () => {\n        if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return;\n        const info = getPanInfo(this.lastMoveEventInfo, this.history);\n        const isPanStarted = this.startEvent !== null;\n        // Only start panning if the offset is larger than 3 pixels. If we make it\n        // any larger than this we'll want to reset the pointer history\n        // on the first update to avoid visual snapping to the cursoe.\n        const isDistancePastThreshold = distance2D(info.offset, {\n          x: 0,\n          y: 0\n        }) >= 3;\n        if (!isPanStarted && !isDistancePastThreshold) return;\n        const {\n          point\n        } = info;\n        const {\n          timestamp\n        } = frameData;\n        this.history.push(_objectSpread(_objectSpread({}, point), {}, {\n          timestamp\n        }));\n        const {\n          onStart,\n          onMove\n        } = this.handlers;\n        if (!isPanStarted) {\n          onStart && onStart(this.lastMoveEvent, info);\n          this.startEvent = this.lastMoveEvent;\n        }\n        onMove && onMove(this.lastMoveEvent, info);\n      };\n      this.handlePointerMove = (event, info) => {\n        this.lastMoveEvent = event;\n        this.lastMoveEventInfo = transformPoint(info, this.transformPagePoint);\n        // Throttle mouse move event to once per frame\n        frame.update(this.updatePoint, true);\n      };\n      this.handlePointerUp = (event, info) => {\n        this.end();\n        const {\n          onEnd,\n          onSessionEnd,\n          resumeAnimation\n        } = this.handlers;\n        if (this.dragSnapToOrigin) resumeAnimation && resumeAnimation();\n        if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return;\n        const panInfo = getPanInfo(event.type === \"pointercancel\" ? this.lastMoveEventInfo : transformPoint(info, this.transformPagePoint), this.history);\n        if (this.startEvent && onEnd) {\n          onEnd(event, panInfo);\n        }\n        onSessionEnd && onSessionEnd(event, panInfo);\n      };\n      // If we have more than one touch, don't start detecting this gesture\n      if (!isPrimaryPointer(event)) return;\n      this.dragSnapToOrigin = dragSnapToOrigin;\n      this.handlers = handlers;\n      this.transformPagePoint = transformPagePoint;\n      this.contextWindow = contextWindow || window;\n      const info = extractEventInfo(event);\n      const initialInfo = transformPoint(info, this.transformPagePoint);\n      const {\n        point\n      } = initialInfo;\n      const {\n        timestamp\n      } = frameData;\n      this.history = [_objectSpread(_objectSpread({}, point), {}, {\n        timestamp\n      })];\n      const {\n        onSessionStart\n      } = handlers;\n      onSessionStart && onSessionStart(event, getPanInfo(initialInfo, this.history));\n      this.removeListeners = pipe(addPointerEvent(this.contextWindow, \"pointermove\", this.handlePointerMove), addPointerEvent(this.contextWindow, \"pointerup\", this.handlePointerUp), addPointerEvent(this.contextWindow, \"pointercancel\", this.handlePointerUp));\n    }\n    updateHandlers(handlers) {\n      this.handlers = handlers;\n    }\n    end() {\n      this.removeListeners && this.removeListeners();\n      cancelFrame(this.updatePoint);\n    }\n  }\n  function transformPoint(info, transformPagePoint) {\n    return transformPagePoint ? {\n      point: transformPagePoint(info.point)\n    } : info;\n  }\n  function subtractPoint(a, b) {\n    return {\n      x: a.x - b.x,\n      y: a.y - b.y\n    };\n  }\n  function getPanInfo(_ref, history) {\n    let {\n      point\n    } = _ref;\n    return {\n      point,\n      delta: subtractPoint(point, lastDevicePoint(history)),\n      offset: subtractPoint(point, startDevicePoint(history)),\n      velocity: getVelocity(history, 0.1)\n    };\n  }\n  function startDevicePoint(history) {\n    return history[0];\n  }\n  function lastDevicePoint(history) {\n    return history[history.length - 1];\n  }\n  function getVelocity(history, timeDelta) {\n    if (history.length < 2) {\n      return {\n        x: 0,\n        y: 0\n      };\n    }\n    let i = history.length - 1;\n    let timestampedPoint = null;\n    const lastPoint = lastDevicePoint(history);\n    while (i >= 0) {\n      timestampedPoint = history[i];\n      if (lastPoint.timestamp - timestampedPoint.timestamp > secondsToMilliseconds(timeDelta)) {\n        break;\n      }\n      i--;\n    }\n    if (!timestampedPoint) {\n      return {\n        x: 0,\n        y: 0\n      };\n    }\n    const time = millisecondsToSeconds(lastPoint.timestamp - timestampedPoint.timestamp);\n    if (time === 0) {\n      return {\n        x: 0,\n        y: 0\n      };\n    }\n    const currentVelocity = {\n      x: (lastPoint.x - timestampedPoint.x) / time,\n      y: (lastPoint.y - timestampedPoint.y) / time\n    };\n    if (currentVelocity.x === Infinity) {\n      currentVelocity.x = 0;\n    }\n    if (currentVelocity.y === Infinity) {\n      currentVelocity.y = 0;\n    }\n    return currentVelocity;\n  }\n}.call(this, module);","map":{"version":3,"names":["PanSession","constructor","event","handlers","transformPagePoint","contextWindow","dragSnapToOrigin","arguments","length","undefined","startEvent","lastMoveEvent","lastMoveEventInfo","window","updatePoint","info","getPanInfo","history","isPanStarted","isDistancePastThreshold","distance2D","offset","x","y","point","timestamp","frameData","push","_objectSpread","onStart","onMove","handlePointerMove","transformPoint","frame","update","handlePointerUp","end","onEnd","onSessionEnd","resumeAnimation","panInfo","type","isPrimaryPointer","extractEventInfo","initialInfo","onSessionStart","removeListeners","pipe","addPointerEvent","updateHandlers","cancelFrame","subtractPoint","a","b","_ref","delta","lastDevicePoint","startDevicePoint","velocity","getVelocity","timeDelta","i","timestampedPoint","lastPoint","secondsToMilliseconds","time","millisecondsToSeconds","currentVelocity","Infinity","call","module"],"sources":["node_modules/framer-motion/dist/es/gestures/pan/PanSession.mjs"],"sourcesContent":["import { extractEventInfo } from '../../events/event-info.mjs';\nimport { secondsToMilliseconds, millisecondsToSeconds } from '../../utils/time-conversion.mjs';\nimport { addPointerEvent } from '../../events/add-pointer-event.mjs';\nimport { pipe } from '../../utils/pipe.mjs';\nimport { distance2D } from '../../utils/distance.mjs';\nimport { isPrimaryPointer } from 'motion-dom';\nimport { frame, cancelFrame, frameData } from '../../frameloop/frame.mjs';\n\n/**\n * @internal\n */\nclass PanSession {\n    constructor(event, handlers, { transformPagePoint, contextWindow, dragSnapToOrigin = false, } = {}) {\n        /**\n         * @internal\n         */\n        this.startEvent = null;\n        /**\n         * @internal\n         */\n        this.lastMoveEvent = null;\n        /**\n         * @internal\n         */\n        this.lastMoveEventInfo = null;\n        /**\n         * @internal\n         */\n        this.handlers = {};\n        /**\n         * @internal\n         */\n        this.contextWindow = window;\n        this.updatePoint = () => {\n            if (!(this.lastMoveEvent && this.lastMoveEventInfo))\n                return;\n            const info = getPanInfo(this.lastMoveEventInfo, this.history);\n            const isPanStarted = this.startEvent !== null;\n            // Only start panning if the offset is larger than 3 pixels. If we make it\n            // any larger than this we'll want to reset the pointer history\n            // on the first update to avoid visual snapping to the cursoe.\n            const isDistancePastThreshold = distance2D(info.offset, { x: 0, y: 0 }) >= 3;\n            if (!isPanStarted && !isDistancePastThreshold)\n                return;\n            const { point } = info;\n            const { timestamp } = frameData;\n            this.history.push({ ...point, timestamp });\n            const { onStart, onMove } = this.handlers;\n            if (!isPanStarted) {\n                onStart && onStart(this.lastMoveEvent, info);\n                this.startEvent = this.lastMoveEvent;\n            }\n            onMove && onMove(this.lastMoveEvent, info);\n        };\n        this.handlePointerMove = (event, info) => {\n            this.lastMoveEvent = event;\n            this.lastMoveEventInfo = transformPoint(info, this.transformPagePoint);\n            // Throttle mouse move event to once per frame\n            frame.update(this.updatePoint, true);\n        };\n        this.handlePointerUp = (event, info) => {\n            this.end();\n            const { onEnd, onSessionEnd, resumeAnimation } = this.handlers;\n            if (this.dragSnapToOrigin)\n                resumeAnimation && resumeAnimation();\n            if (!(this.lastMoveEvent && this.lastMoveEventInfo))\n                return;\n            const panInfo = getPanInfo(event.type === \"pointercancel\"\n                ? this.lastMoveEventInfo\n                : transformPoint(info, this.transformPagePoint), this.history);\n            if (this.startEvent && onEnd) {\n                onEnd(event, panInfo);\n            }\n            onSessionEnd && onSessionEnd(event, panInfo);\n        };\n        // If we have more than one touch, don't start detecting this gesture\n        if (!isPrimaryPointer(event))\n            return;\n        this.dragSnapToOrigin = dragSnapToOrigin;\n        this.handlers = handlers;\n        this.transformPagePoint = transformPagePoint;\n        this.contextWindow = contextWindow || window;\n        const info = extractEventInfo(event);\n        const initialInfo = transformPoint(info, this.transformPagePoint);\n        const { point } = initialInfo;\n        const { timestamp } = frameData;\n        this.history = [{ ...point, timestamp }];\n        const { onSessionStart } = handlers;\n        onSessionStart &&\n            onSessionStart(event, getPanInfo(initialInfo, this.history));\n        this.removeListeners = pipe(addPointerEvent(this.contextWindow, \"pointermove\", this.handlePointerMove), addPointerEvent(this.contextWindow, \"pointerup\", this.handlePointerUp), addPointerEvent(this.contextWindow, \"pointercancel\", this.handlePointerUp));\n    }\n    updateHandlers(handlers) {\n        this.handlers = handlers;\n    }\n    end() {\n        this.removeListeners && this.removeListeners();\n        cancelFrame(this.updatePoint);\n    }\n}\nfunction transformPoint(info, transformPagePoint) {\n    return transformPagePoint ? { point: transformPagePoint(info.point) } : info;\n}\nfunction subtractPoint(a, b) {\n    return { x: a.x - b.x, y: a.y - b.y };\n}\nfunction getPanInfo({ point }, history) {\n    return {\n        point,\n        delta: subtractPoint(point, lastDevicePoint(history)),\n        offset: subtractPoint(point, startDevicePoint(history)),\n        velocity: getVelocity(history, 0.1),\n    };\n}\nfunction startDevicePoint(history) {\n    return history[0];\n}\nfunction lastDevicePoint(history) {\n    return history[history.length - 1];\n}\nfunction getVelocity(history, timeDelta) {\n    if (history.length < 2) {\n        return { x: 0, y: 0 };\n    }\n    let i = history.length - 1;\n    let timestampedPoint = null;\n    const lastPoint = lastDevicePoint(history);\n    while (i >= 0) {\n        timestampedPoint = history[i];\n        if (lastPoint.timestamp - timestampedPoint.timestamp >\n            secondsToMilliseconds(timeDelta)) {\n            break;\n        }\n        i--;\n    }\n    if (!timestampedPoint) {\n        return { x: 0, y: 0 };\n    }\n    const time = millisecondsToSeconds(lastPoint.timestamp - timestampedPoint.timestamp);\n    if (time === 0) {\n        return { x: 0, y: 0 };\n    }\n    const currentVelocity = {\n        x: (lastPoint.x - timestampedPoint.x) / time,\n        y: (lastPoint.y - timestampedPoint.y) / time,\n    };\n    if (currentVelocity.x === Infinity) {\n        currentVelocity.x = 0;\n    }\n    if (currentVelocity.y === Infinity) {\n        currentVelocity.y = 0;\n    }\n    return currentVelocity;\n}\n\nexport { PanSession };\n"],"mappings":"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","ignoreList":[]},"sourceType":"module","externalDependencies":{},"hash":"94fe95d0ab355c83ab4e487cddde3cc225ad6de7"}
