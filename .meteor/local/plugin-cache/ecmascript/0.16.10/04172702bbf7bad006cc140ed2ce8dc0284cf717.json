{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/anshul/Masters/Internship/POC/Meteor_Mobile/mieweb_push_auth/node_modules/framer-motion/dist/es/frameloop/render-step.mjs","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","topLevelAwait","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"web.browser"},"sourceFileName":"node_modules/framer-motion/dist/es/frameloop/render-step.mjs","filename":"/Users/anshul/Masters/Internship/POC/Meteor_Mobile/mieweb_push_auth/node_modules/framer-motion/dist/es/frameloop/render-step.mjs","inputSourceMap":{"version":3,"names":["createRenderStep","runNextFrame","thisFrame","Set","nextFrame","isProcessing","flushNextFrame","toKeepAlive","WeakSet","latestFrameData","delta","timestamp","triggerCallback","callback","has","step","schedule","keepAlive","immediate","addToCurrentFrame","queue","add","cancel","delete","process","frameData","forEach","clear"],"sources":["node_modules/framer-motion/dist/es/frameloop/render-step.mjs"],"sourcesContent":["function createRenderStep(runNextFrame) {\n    /**\n     * We create and reuse two queues, one to queue jobs for the current frame\n     * and one for the next. We reuse to avoid triggering GC after x frames.\n     */\n    let thisFrame = new Set();\n    let nextFrame = new Set();\n    /**\n     * Track whether we're currently processing jobs in this step. This way\n     * we can decide whether to schedule new jobs for this frame or next.\n     */\n    let isProcessing = false;\n    let flushNextFrame = false;\n    /**\n     * A set of processes which were marked keepAlive when scheduled.\n     */\n    const toKeepAlive = new WeakSet();\n    let latestFrameData = {\n        delta: 0.0,\n        timestamp: 0.0,\n        isProcessing: false,\n    };\n    function triggerCallback(callback) {\n        if (toKeepAlive.has(callback)) {\n            step.schedule(callback);\n            runNextFrame();\n        }\n        callback(latestFrameData);\n    }\n    const step = {\n        /**\n         * Schedule a process to run on the next frame.\n         */\n        schedule: (callback, keepAlive = false, immediate = false) => {\n            const addToCurrentFrame = immediate && isProcessing;\n            const queue = addToCurrentFrame ? thisFrame : nextFrame;\n            if (keepAlive)\n                toKeepAlive.add(callback);\n            if (!queue.has(callback))\n                queue.add(callback);\n            return callback;\n        },\n        /**\n         * Cancel the provided callback from running on the next frame.\n         */\n        cancel: (callback) => {\n            nextFrame.delete(callback);\n            toKeepAlive.delete(callback);\n        },\n        /**\n         * Execute all schedule callbacks.\n         */\n        process: (frameData) => {\n            latestFrameData = frameData;\n            /**\n             * If we're already processing we've probably been triggered by a flushSync\n             * inside an existing process. Instead of executing, mark flushNextFrame\n             * as true and ensure we flush the following frame at the end of this one.\n             */\n            if (isProcessing) {\n                flushNextFrame = true;\n                return;\n            }\n            isProcessing = true;\n            [thisFrame, nextFrame] = [nextFrame, thisFrame];\n            // Execute this frame\n            thisFrame.forEach(triggerCallback);\n            // Clear the frame so no callbacks remain. This is to avoid\n            // memory leaks should this render step not run for a while.\n            thisFrame.clear();\n            isProcessing = false;\n            if (flushNextFrame) {\n                flushNextFrame = false;\n                step.process(frameData);\n            }\n        },\n    };\n    return step;\n}\n\nexport { createRenderStep };\n"],"mappings":";AAAA,SAASA,gBAAgBA,CAACC,YAAY,EAAE;EACpC;AACJ;AACA;AACA;EACI,IAAIC,SAAS,GAAG,IAAIC,GAAG,CAAC,CAAC;EACzB,IAAIC,SAAS,GAAG,IAAID,GAAG,CAAC,CAAC;EACzB;AACJ;AACA;AACA;EACI,IAAIE,YAAY,GAAG,KAAK;EACxB,IAAIC,cAAc,GAAG,KAAK;EAC1B;AACJ;AACA;EACI,MAAMC,WAAW,GAAG,IAAIC,OAAO,CAAC,CAAC;EACjC,IAAIC,eAAe,GAAG;IAClBC,KAAK,EAAE,GAAG;IACVC,SAAS,EAAE,GAAG;IACdN,YAAY,EAAE;EAClB,CAAC;EACD,SAASO,eAAeA,CAACC,QAAQ,EAAE;IAC/B,IAAIN,WAAW,CAACO,GAAG,CAACD,QAAQ,CAAC,EAAE;MAC3BE,IAAI,CAACC,QAAQ,CAACH,QAAQ,CAAC;MACvBZ,YAAY,CAAC,CAAC;IAClB;IACAY,QAAQ,CAACJ,eAAe,CAAC;EAC7B;EACA,MAAMM,IAAI,GAAG;IACT;AACR;AACA;IACQC,QAAQ,EAAEA,CAACH,QAAQ,EAAEI,SAAS,GAAG,KAAK,EAAEC,SAAS,GAAG,KAAK,KAAK;MAC1D,MAAMC,iBAAiB,GAAGD,SAAS,IAAIb,YAAY;MACnD,MAAMe,KAAK,GAAGD,iBAAiB,GAAGjB,SAAS,GAAGE,SAAS;MACvD,IAAIa,SAAS,EACTV,WAAW,CAACc,GAAG,CAACR,QAAQ,CAAC;MAC7B,IAAI,CAACO,KAAK,CAACN,GAAG,CAACD,QAAQ,CAAC,EACpBO,KAAK,CAACC,GAAG,CAACR,QAAQ,CAAC;MACvB,OAAOA,QAAQ;IACnB,CAAC;IACD;AACR;AACA;IACQS,MAAM,EAAGT,QAAQ,IAAK;MAClBT,SAAS,CAACmB,MAAM,CAACV,QAAQ,CAAC;MAC1BN,WAAW,CAACgB,MAAM,CAACV,QAAQ,CAAC;IAChC,CAAC;IACD;AACR;AACA;IACQW,OAAO,EAAGC,SAAS,IAAK;MACpBhB,eAAe,GAAGgB,SAAS;MAC3B;AACZ;AACA;AACA;AACA;MACY,IAAIpB,YAAY,EAAE;QACdC,cAAc,GAAG,IAAI;QACrB;MACJ;MACAD,YAAY,GAAG,IAAI;MACnB,CAACH,SAAS,EAAEE,SAAS,CAAC,GAAG,CAACA,SAAS,EAAEF,SAAS,CAAC;MAC/C;MACAA,SAAS,CAACwB,OAAO,CAACd,eAAe,CAAC;MAClC;MACA;MACAV,SAAS,CAACyB,KAAK,CAAC,CAAC;MACjBtB,YAAY,GAAG,KAAK;MACpB,IAAIC,cAAc,EAAE;QAChBA,cAAc,GAAG,KAAK;QACtBS,IAAI,CAACS,OAAO,CAACC,SAAS,CAAC;MAC3B;IACJ;EACJ,CAAC;EACD,OAAOV,IAAI;AACf;AAEA,SAASf,gBAAgB","ignoreList":[]},"targets":{},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/Users/anshul/Masters/Internship/POC/Meteor_Mobile/mieweb_push_auth","root":"/Users/anshul/Masters/Internship/POC/Meteor_Mobile/mieweb_push_auth","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true},"externalDependencies":[]},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.17.2","helpers":true,"useESModules":false,"corejs":false},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-react-jsx","visitor":{"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXFragment":{"exit":[null]},"JSXElement":{"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false},"externalDependencies":[]},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-nullish-coalescing-operator","visitor":{"LogicalExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-chaining","visitor":{"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-catch-binding","visitor":{"CatchClause":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"proposal-logical-assignment-operators","visitor":{"AssignmentExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]}],"presets":[],"generatorOpts":{"filename":"/Users/anshul/Masters/Internship/POC/Meteor_Mobile/mieweb_push_auth/node_modules/framer-motion/dist/es/frameloop/render-step.mjs","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"node_modules/framer-motion/dist/es/frameloop/render-step.mjs","inputSourceMap":{"version":3,"names":["createRenderStep","runNextFrame","thisFrame","Set","nextFrame","isProcessing","flushNextFrame","toKeepAlive","WeakSet","latestFrameData","delta","timestamp","triggerCallback","callback","has","step","schedule","keepAlive","immediate","addToCurrentFrame","queue","add","cancel","delete","process","frameData","forEach","clear"],"sources":["node_modules/framer-motion/dist/es/frameloop/render-step.mjs"],"sourcesContent":["function createRenderStep(runNextFrame) {\n    /**\n     * We create and reuse two queues, one to queue jobs for the current frame\n     * and one for the next. We reuse to avoid triggering GC after x frames.\n     */\n    let thisFrame = new Set();\n    let nextFrame = new Set();\n    /**\n     * Track whether we're currently processing jobs in this step. This way\n     * we can decide whether to schedule new jobs for this frame or next.\n     */\n    let isProcessing = false;\n    let flushNextFrame = false;\n    /**\n     * A set of processes which were marked keepAlive when scheduled.\n     */\n    const toKeepAlive = new WeakSet();\n    let latestFrameData = {\n        delta: 0.0,\n        timestamp: 0.0,\n        isProcessing: false,\n    };\n    function triggerCallback(callback) {\n        if (toKeepAlive.has(callback)) {\n            step.schedule(callback);\n            runNextFrame();\n        }\n        callback(latestFrameData);\n    }\n    const step = {\n        /**\n         * Schedule a process to run on the next frame.\n         */\n        schedule: (callback, keepAlive = false, immediate = false) => {\n            const addToCurrentFrame = immediate && isProcessing;\n            const queue = addToCurrentFrame ? thisFrame : nextFrame;\n            if (keepAlive)\n                toKeepAlive.add(callback);\n            if (!queue.has(callback))\n                queue.add(callback);\n            return callback;\n        },\n        /**\n         * Cancel the provided callback from running on the next frame.\n         */\n        cancel: (callback) => {\n            nextFrame.delete(callback);\n            toKeepAlive.delete(callback);\n        },\n        /**\n         * Execute all schedule callbacks.\n         */\n        process: (frameData) => {\n            latestFrameData = frameData;\n            /**\n             * If we're already processing we've probably been triggered by a flushSync\n             * inside an existing process. Instead of executing, mark flushNextFrame\n             * as true and ensure we flush the following frame at the end of this one.\n             */\n            if (isProcessing) {\n                flushNextFrame = true;\n                return;\n            }\n            isProcessing = true;\n            [thisFrame, nextFrame] = [nextFrame, thisFrame];\n            // Execute this frame\n            thisFrame.forEach(triggerCallback);\n            // Clear the frame so no callbacks remain. This is to avoid\n            // memory leaks should this render step not run for a while.\n            thisFrame.clear();\n            isProcessing = false;\n            if (flushNextFrame) {\n                flushNextFrame = false;\n                step.process(frameData);\n            }\n        },\n    };\n    return step;\n}\n\nexport { createRenderStep };\n"],"mappings":";AAAA,SAASA,gBAAgBA,CAACC,YAAY,EAAE;EACpC;AACJ;AACA;AACA;EACI,IAAIC,SAAS,GAAG,IAAIC,GAAG,CAAC,CAAC;EACzB,IAAIC,SAAS,GAAG,IAAID,GAAG,CAAC,CAAC;EACzB;AACJ;AACA;AACA;EACI,IAAIE,YAAY,GAAG,KAAK;EACxB,IAAIC,cAAc,GAAG,KAAK;EAC1B;AACJ;AACA;EACI,MAAMC,WAAW,GAAG,IAAIC,OAAO,CAAC,CAAC;EACjC,IAAIC,eAAe,GAAG;IAClBC,KAAK,EAAE,GAAG;IACVC,SAAS,EAAE,GAAG;IACdN,YAAY,EAAE;EAClB,CAAC;EACD,SAASO,eAAeA,CAACC,QAAQ,EAAE;IAC/B,IAAIN,WAAW,CAACO,GAAG,CAACD,QAAQ,CAAC,EAAE;MAC3BE,IAAI,CAACC,QAAQ,CAACH,QAAQ,CAAC;MACvBZ,YAAY,CAAC,CAAC;IAClB;IACAY,QAAQ,CAACJ,eAAe,CAAC;EAC7B;EACA,MAAMM,IAAI,GAAG;IACT;AACR;AACA;IACQC,QAAQ,EAAEA,CAACH,QAAQ,EAAEI,SAAS,GAAG,KAAK,EAAEC,SAAS,GAAG,KAAK,KAAK;MAC1D,MAAMC,iBAAiB,GAAGD,SAAS,IAAIb,YAAY;MACnD,MAAMe,KAAK,GAAGD,iBAAiB,GAAGjB,SAAS,GAAGE,SAAS;MACvD,IAAIa,SAAS,EACTV,WAAW,CAACc,GAAG,CAACR,QAAQ,CAAC;MAC7B,IAAI,CAACO,KAAK,CAACN,GAAG,CAACD,QAAQ,CAAC,EACpBO,KAAK,CAACC,GAAG,CAACR,QAAQ,CAAC;MACvB,OAAOA,QAAQ;IACnB,CAAC;IACD;AACR;AACA;IACQS,MAAM,EAAGT,QAAQ,IAAK;MAClBT,SAAS,CAACmB,MAAM,CAACV,QAAQ,CAAC;MAC1BN,WAAW,CAACgB,MAAM,CAACV,QAAQ,CAAC;IAChC,CAAC;IACD;AACR;AACA;IACQW,OAAO,EAAGC,SAAS,IAAK;MACpBhB,eAAe,GAAGgB,SAAS;MAC3B;AACZ;AACA;AACA;AACA;MACY,IAAIpB,YAAY,EAAE;QACdC,cAAc,GAAG,IAAI;QACrB;MACJ;MACAD,YAAY,GAAG,IAAI;MACnB,CAACH,SAAS,EAAEE,SAAS,CAAC,GAAG,CAACA,SAAS,EAAEF,SAAS,CAAC;MAC/C;MACAA,SAAS,CAACwB,OAAO,CAACd,eAAe,CAAC;MAClC;MACA;MACAV,SAAS,CAACyB,KAAK,CAAC,CAAC;MACjBtB,YAAY,GAAG,KAAK;MACpB,IAAIC,cAAc,EAAE;QAChBA,cAAc,GAAG,KAAK;QACtBS,IAAI,CAACS,OAAO,CAACC,SAAS,CAAC;MAC3B;IACJ;EACJ,CAAC;EACD,OAAOV,IAAI;AACf;AAEA,SAASf,gBAAgB","ignoreList":[]}}},"code":"!function (module1) {\n  module1.export({\n    createRenderStep: () => createRenderStep\n  });\n  ___INIT_METEOR_FAST_REFRESH(module);\n  function createRenderStep(runNextFrame) {\n    /**\n     * We create and reuse two queues, one to queue jobs for the current frame\n     * and one for the next. We reuse to avoid triggering GC after x frames.\n     */\n    let thisFrame = new Set();\n    let nextFrame = new Set();\n    /**\n     * Track whether we're currently processing jobs in this step. This way\n     * we can decide whether to schedule new jobs for this frame or next.\n     */\n    let isProcessing = false;\n    let flushNextFrame = false;\n    /**\n     * A set of processes which were marked keepAlive when scheduled.\n     */\n    const toKeepAlive = new WeakSet();\n    let latestFrameData = {\n      delta: 0.0,\n      timestamp: 0.0,\n      isProcessing: false\n    };\n    function triggerCallback(callback) {\n      if (toKeepAlive.has(callback)) {\n        step.schedule(callback);\n        runNextFrame();\n      }\n      callback(latestFrameData);\n    }\n    const step = {\n      /**\n       * Schedule a process to run on the next frame.\n       */\n      schedule: function (callback) {\n        let keepAlive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        let immediate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n        const addToCurrentFrame = immediate && isProcessing;\n        const queue = addToCurrentFrame ? thisFrame : nextFrame;\n        if (keepAlive) toKeepAlive.add(callback);\n        if (!queue.has(callback)) queue.add(callback);\n        return callback;\n      },\n      /**\n       * Cancel the provided callback from running on the next frame.\n       */\n      cancel: callback => {\n        nextFrame.delete(callback);\n        toKeepAlive.delete(callback);\n      },\n      /**\n       * Execute all schedule callbacks.\n       */\n      process: frameData => {\n        latestFrameData = frameData;\n        /**\n         * If we're already processing we've probably been triggered by a flushSync\n         * inside an existing process. Instead of executing, mark flushNextFrame\n         * as true and ensure we flush the following frame at the end of this one.\n         */\n        if (isProcessing) {\n          flushNextFrame = true;\n          return;\n        }\n        isProcessing = true;\n        [thisFrame, nextFrame] = [nextFrame, thisFrame];\n        // Execute this frame\n        thisFrame.forEach(triggerCallback);\n        // Clear the frame so no callbacks remain. This is to avoid\n        // memory leaks should this render step not run for a while.\n        thisFrame.clear();\n        isProcessing = false;\n        if (flushNextFrame) {\n          flushNextFrame = false;\n          step.process(frameData);\n        }\n      }\n    };\n    return step;\n  }\n}.call(this, module);","map":{"version":3,"names":["createRenderStep","runNextFrame","thisFrame","Set","nextFrame","isProcessing","flushNextFrame","toKeepAlive","WeakSet","latestFrameData","delta","timestamp","triggerCallback","callback","has","step","schedule","keepAlive","arguments","length","undefined","immediate","addToCurrentFrame","queue","add","cancel","delete","process","frameData","forEach","clear","call","module"],"sources":["node_modules/framer-motion/dist/es/frameloop/render-step.mjs"],"sourcesContent":["function createRenderStep(runNextFrame) {\n    /**\n     * We create and reuse two queues, one to queue jobs for the current frame\n     * and one for the next. We reuse to avoid triggering GC after x frames.\n     */\n    let thisFrame = new Set();\n    let nextFrame = new Set();\n    /**\n     * Track whether we're currently processing jobs in this step. This way\n     * we can decide whether to schedule new jobs for this frame or next.\n     */\n    let isProcessing = false;\n    let flushNextFrame = false;\n    /**\n     * A set of processes which were marked keepAlive when scheduled.\n     */\n    const toKeepAlive = new WeakSet();\n    let latestFrameData = {\n        delta: 0.0,\n        timestamp: 0.0,\n        isProcessing: false,\n    };\n    function triggerCallback(callback) {\n        if (toKeepAlive.has(callback)) {\n            step.schedule(callback);\n            runNextFrame();\n        }\n        callback(latestFrameData);\n    }\n    const step = {\n        /**\n         * Schedule a process to run on the next frame.\n         */\n        schedule: (callback, keepAlive = false, immediate = false) => {\n            const addToCurrentFrame = immediate && isProcessing;\n            const queue = addToCurrentFrame ? thisFrame : nextFrame;\n            if (keepAlive)\n                toKeepAlive.add(callback);\n            if (!queue.has(callback))\n                queue.add(callback);\n            return callback;\n        },\n        /**\n         * Cancel the provided callback from running on the next frame.\n         */\n        cancel: (callback) => {\n            nextFrame.delete(callback);\n            toKeepAlive.delete(callback);\n        },\n        /**\n         * Execute all schedule callbacks.\n         */\n        process: (frameData) => {\n            latestFrameData = frameData;\n            /**\n             * If we're already processing we've probably been triggered by a flushSync\n             * inside an existing process. Instead of executing, mark flushNextFrame\n             * as true and ensure we flush the following frame at the end of this one.\n             */\n            if (isProcessing) {\n                flushNextFrame = true;\n                return;\n            }\n            isProcessing = true;\n            [thisFrame, nextFrame] = [nextFrame, thisFrame];\n            // Execute this frame\n            thisFrame.forEach(triggerCallback);\n            // Clear the frame so no callbacks remain. This is to avoid\n            // memory leaks should this render step not run for a while.\n            thisFrame.clear();\n            isProcessing = false;\n            if (flushNextFrame) {\n                flushNextFrame = false;\n                step.process(frameData);\n            }\n        },\n    };\n    return step;\n}\n\nexport { createRenderStep };\n"],"mappings":";;;;;EAAA,SAASA,gBAAgBA,CAACC,YAAY,EAAE;IACpC;AACJ;AACA;AACA;IACI,IAAIC,SAAS,GAAG,IAAIC,GAAG,CAAC,CAAC;IACzB,IAAIC,SAAS,GAAG,IAAID,GAAG,CAAC,CAAC;IACzB;AACJ;AACA;AACA;IACI,IAAIE,YAAY,GAAG,KAAK;IACxB,IAAIC,cAAc,GAAG,KAAK;IAC1B;AACJ;AACA;IACI,MAAMC,WAAW,GAAG,IAAIC,OAAO,CAAC,CAAC;IACjC,IAAIC,eAAe,GAAG;MAClBC,KAAK,EAAE,GAAG;MACVC,SAAS,EAAE,GAAG;MACdN,YAAY,EAAE;IAClB,CAAC;IACD,SAASO,eAAeA,CAACC,QAAQ,EAAE;MAC/B,IAAIN,WAAW,CAACO,GAAG,CAACD,QAAQ,CAAC,EAAE;QAC3BE,IAAI,CAACC,QAAQ,CAACH,QAAQ,CAAC;QACvBZ,YAAY,CAAC,CAAC;MAClB;MACAY,QAAQ,CAACJ,eAAe,CAAC;IAC7B;IACA,MAAMM,IAAI,GAAG;MACT;AACR;AACA;MACQC,QAAQ,EAAE,SAAAA,CAACH,QAAQ,EAA2C;QAAA,IAAzCI,SAAS,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,KAAK;QAAA,IAAEG,SAAS,GAAAH,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,KAAK;QACrD,MAAMI,iBAAiB,GAAGD,SAAS,IAAIhB,YAAY;QACnD,MAAMkB,KAAK,GAAGD,iBAAiB,GAAGpB,SAAS,GAAGE,SAAS;QACvD,IAAIa,SAAS,EACTV,WAAW,CAACiB,GAAG,CAACX,QAAQ,CAAC;QAC7B,IAAI,CAACU,KAAK,CAACT,GAAG,CAACD,QAAQ,CAAC,EACpBU,KAAK,CAACC,GAAG,CAACX,QAAQ,CAAC;QACvB,OAAOA,QAAQ;MACnB,CAAC;MACD;AACR;AACA;MACQY,MAAM,EAAGZ,QAAQ,IAAK;QAClBT,SAAS,CAACsB,MAAM,CAACb,QAAQ,CAAC;QAC1BN,WAAW,CAACmB,MAAM,CAACb,QAAQ,CAAC;MAChC,CAAC;MACD;AACR;AACA;MACQc,OAAO,EAAGC,SAAS,IAAK;QACpBnB,eAAe,GAAGmB,SAAS;QAC3B;AACZ;AACA;AACA;AACA;QACY,IAAIvB,YAAY,EAAE;UACdC,cAAc,GAAG,IAAI;UACrB;QACJ;QACAD,YAAY,GAAG,IAAI;QACnB,CAACH,SAAS,EAAEE,SAAS,CAAC,GAAG,CAACA,SAAS,EAAEF,SAAS,CAAC;QAC/C;QACAA,SAAS,CAAC2B,OAAO,CAACjB,eAAe,CAAC;QAClC;QACA;QACAV,SAAS,CAAC4B,KAAK,CAAC,CAAC;QACjBzB,YAAY,GAAG,KAAK;QACpB,IAAIC,cAAc,EAAE;UAChBA,cAAc,GAAG,KAAK;UACtBS,IAAI,CAACY,OAAO,CAACC,SAAS,CAAC;QAC3B;MACJ;IACJ,CAAC;IACD,OAAOb,IAAI;EACf;AAAA,EAAAgB,IAAA,OAAAC,MAAA","ignoreList":[]},"sourceType":"module","externalDependencies":{},"hash":"04172702bbf7bad006cc140ed2ce8dc0284cf717"}
