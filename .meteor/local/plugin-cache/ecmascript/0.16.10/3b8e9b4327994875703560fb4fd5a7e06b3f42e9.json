{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/anshul/Masters/Internship/POC/Meteor_Mobile/mieweb_push_auth/node_modules/framer-motion/dist/es/animation/interfaces/motion-value.mjs","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","topLevelAwait","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"web.browser"},"sourceFileName":"node_modules/framer-motion/dist/es/animation/interfaces/motion-value.mjs","filename":"/Users/anshul/Masters/Internship/POC/Meteor_Mobile/mieweb_push_auth/node_modules/framer-motion/dist/es/animation/interfaces/motion-value.mjs","inputSourceMap":{"version":3,"names":["secondsToMilliseconds","getDefaultTransition","getValueTransition","MotionGlobalConfig","instantAnimationState","getFinalKeyframe","frame","AcceleratedAnimation","MainThreadAnimation","GroupPlaybackControls","isTransitionDefined","animateMotionValue","name","value","target","transition","element","isHandoff","onComplete","valueTransition","delay","elapsed","options","keyframes","Array","isArray","ease","velocity","getVelocity","onUpdate","v","set","motionValue","undefined","duration","repeatDelay","from","shouldSkip","type","current","skipAnimations","get","finalKeyframe","update","supports"],"sources":["node_modules/framer-motion/dist/es/animation/interfaces/motion-value.mjs"],"sourcesContent":["import { secondsToMilliseconds } from '../../utils/time-conversion.mjs';\nimport { getDefaultTransition } from '../utils/default-transitions.mjs';\nimport { getValueTransition } from '../utils/get-value-transition.mjs';\nimport { MotionGlobalConfig } from '../../utils/GlobalConfig.mjs';\nimport { instantAnimationState } from '../../utils/use-instant-transition-state.mjs';\nimport { getFinalKeyframe } from '../animators/waapi/utils/get-final-keyframe.mjs';\nimport { frame } from '../../frameloop/frame.mjs';\nimport { AcceleratedAnimation } from '../animators/AcceleratedAnimation.mjs';\nimport { MainThreadAnimation } from '../animators/MainThreadAnimation.mjs';\nimport { GroupPlaybackControls } from '../GroupPlaybackControls.mjs';\nimport { isTransitionDefined } from '../utils/is-transition-defined.mjs';\n\nconst animateMotionValue = (name, value, target, transition = {}, element, isHandoff) => (onComplete) => {\n    const valueTransition = getValueTransition(transition, name) || {};\n    /**\n     * Most transition values are currently completely overwritten by value-specific\n     * transitions. In the future it'd be nicer to blend these transitions. But for now\n     * delay actually does inherit from the root transition if not value-specific.\n     */\n    const delay = valueTransition.delay || transition.delay || 0;\n    /**\n     * Elapsed isn't a public transition option but can be passed through from\n     * optimized appear effects in milliseconds.\n     */\n    let { elapsed = 0 } = transition;\n    elapsed = elapsed - secondsToMilliseconds(delay);\n    let options = {\n        keyframes: Array.isArray(target) ? target : [null, target],\n        ease: \"easeOut\",\n        velocity: value.getVelocity(),\n        ...valueTransition,\n        delay: -elapsed,\n        onUpdate: (v) => {\n            value.set(v);\n            valueTransition.onUpdate && valueTransition.onUpdate(v);\n        },\n        onComplete: () => {\n            onComplete();\n            valueTransition.onComplete && valueTransition.onComplete();\n        },\n        name,\n        motionValue: value,\n        element: isHandoff ? undefined : element,\n    };\n    /**\n     * If there's no transition defined for this value, we can generate\n     * unqiue transition settings for this value.\n     */\n    if (!isTransitionDefined(valueTransition)) {\n        options = {\n            ...options,\n            ...getDefaultTransition(name, options),\n        };\n    }\n    /**\n     * Both WAAPI and our internal animation functions use durations\n     * as defined by milliseconds, while our external API defines them\n     * as seconds.\n     */\n    if (options.duration) {\n        options.duration = secondsToMilliseconds(options.duration);\n    }\n    if (options.repeatDelay) {\n        options.repeatDelay = secondsToMilliseconds(options.repeatDelay);\n    }\n    if (options.from !== undefined) {\n        options.keyframes[0] = options.from;\n    }\n    let shouldSkip = false;\n    if (options.type === false ||\n        (options.duration === 0 && !options.repeatDelay)) {\n        options.duration = 0;\n        if (options.delay === 0) {\n            shouldSkip = true;\n        }\n    }\n    if (instantAnimationState.current ||\n        MotionGlobalConfig.skipAnimations) {\n        shouldSkip = true;\n        options.duration = 0;\n        options.delay = 0;\n    }\n    /**\n     * If we can or must skip creating the animation, and apply only\n     * the final keyframe, do so. We also check once keyframes are resolved but\n     * this early check prevents the need to create an animation at all.\n     */\n    if (shouldSkip && !isHandoff && value.get() !== undefined) {\n        const finalKeyframe = getFinalKeyframe(options.keyframes, valueTransition);\n        if (finalKeyframe !== undefined) {\n            frame.update(() => {\n                options.onUpdate(finalKeyframe);\n                options.onComplete();\n            });\n            // We still want to return some animation controls here rather\n            // than returning undefined\n            return new GroupPlaybackControls([]);\n        }\n    }\n    /**\n     * Animate via WAAPI if possible. If this is a handoff animation, the optimised animation will be running via\n     * WAAPI. Therefore, this animation must be JS to ensure it runs \"under\" the\n     * optimised animation.\n     */\n    if (!isHandoff && AcceleratedAnimation.supports(options)) {\n        return new AcceleratedAnimation(options);\n    }\n    else {\n        return new MainThreadAnimation(options);\n    }\n};\n\nexport { animateMotionValue };\n"],"mappings":"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","ignoreList":[]},"targets":{},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/Users/anshul/Masters/Internship/POC/Meteor_Mobile/mieweb_push_auth","root":"/Users/anshul/Masters/Internship/POC/Meteor_Mobile/mieweb_push_auth","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true},"externalDependencies":[]},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.17.2","helpers":true,"useESModules":false,"corejs":false},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-react-jsx","visitor":{"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXFragment":{"exit":[null]},"JSXElement":{"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false},"externalDependencies":[]},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-nullish-coalescing-operator","visitor":{"LogicalExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-chaining","visitor":{"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-catch-binding","visitor":{"CatchClause":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"proposal-logical-assignment-operators","visitor":{"AssignmentExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]}],"presets":[],"generatorOpts":{"filename":"/Users/anshul/Masters/Internship/POC/Meteor_Mobile/mieweb_push_auth/node_modules/framer-motion/dist/es/animation/interfaces/motion-value.mjs","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"node_modules/framer-motion/dist/es/animation/interfaces/motion-value.mjs","inputSourceMap":{"version":3,"names":["secondsToMilliseconds","getDefaultTransition","getValueTransition","MotionGlobalConfig","instantAnimationState","getFinalKeyframe","frame","AcceleratedAnimation","MainThreadAnimation","GroupPlaybackControls","isTransitionDefined","animateMotionValue","name","value","target","transition","element","isHandoff","onComplete","valueTransition","delay","elapsed","options","keyframes","Array","isArray","ease","velocity","getVelocity","onUpdate","v","set","motionValue","undefined","duration","repeatDelay","from","shouldSkip","type","current","skipAnimations","get","finalKeyframe","update","supports"],"sources":["node_modules/framer-motion/dist/es/animation/interfaces/motion-value.mjs"],"sourcesContent":["import { secondsToMilliseconds } from '../../utils/time-conversion.mjs';\nimport { getDefaultTransition } from '../utils/default-transitions.mjs';\nimport { getValueTransition } from '../utils/get-value-transition.mjs';\nimport { MotionGlobalConfig } from '../../utils/GlobalConfig.mjs';\nimport { instantAnimationState } from '../../utils/use-instant-transition-state.mjs';\nimport { getFinalKeyframe } from '../animators/waapi/utils/get-final-keyframe.mjs';\nimport { frame } from '../../frameloop/frame.mjs';\nimport { AcceleratedAnimation } from '../animators/AcceleratedAnimation.mjs';\nimport { MainThreadAnimation } from '../animators/MainThreadAnimation.mjs';\nimport { GroupPlaybackControls } from '../GroupPlaybackControls.mjs';\nimport { isTransitionDefined } from '../utils/is-transition-defined.mjs';\n\nconst animateMotionValue = (name, value, target, transition = {}, element, isHandoff) => (onComplete) => {\n    const valueTransition = getValueTransition(transition, name) || {};\n    /**\n     * Most transition values are currently completely overwritten by value-specific\n     * transitions. In the future it'd be nicer to blend these transitions. But for now\n     * delay actually does inherit from the root transition if not value-specific.\n     */\n    const delay = valueTransition.delay || transition.delay || 0;\n    /**\n     * Elapsed isn't a public transition option but can be passed through from\n     * optimized appear effects in milliseconds.\n     */\n    let { elapsed = 0 } = transition;\n    elapsed = elapsed - secondsToMilliseconds(delay);\n    let options = {\n        keyframes: Array.isArray(target) ? target : [null, target],\n        ease: \"easeOut\",\n        velocity: value.getVelocity(),\n        ...valueTransition,\n        delay: -elapsed,\n        onUpdate: (v) => {\n            value.set(v);\n            valueTransition.onUpdate && valueTransition.onUpdate(v);\n        },\n        onComplete: () => {\n            onComplete();\n            valueTransition.onComplete && valueTransition.onComplete();\n        },\n        name,\n        motionValue: value,\n        element: isHandoff ? undefined : element,\n    };\n    /**\n     * If there's no transition defined for this value, we can generate\n     * unqiue transition settings for this value.\n     */\n    if (!isTransitionDefined(valueTransition)) {\n        options = {\n            ...options,\n            ...getDefaultTransition(name, options),\n        };\n    }\n    /**\n     * Both WAAPI and our internal animation functions use durations\n     * as defined by milliseconds, while our external API defines them\n     * as seconds.\n     */\n    if (options.duration) {\n        options.duration = secondsToMilliseconds(options.duration);\n    }\n    if (options.repeatDelay) {\n        options.repeatDelay = secondsToMilliseconds(options.repeatDelay);\n    }\n    if (options.from !== undefined) {\n        options.keyframes[0] = options.from;\n    }\n    let shouldSkip = false;\n    if (options.type === false ||\n        (options.duration === 0 && !options.repeatDelay)) {\n        options.duration = 0;\n        if (options.delay === 0) {\n            shouldSkip = true;\n        }\n    }\n    if (instantAnimationState.current ||\n        MotionGlobalConfig.skipAnimations) {\n        shouldSkip = true;\n        options.duration = 0;\n        options.delay = 0;\n    }\n    /**\n     * If we can or must skip creating the animation, and apply only\n     * the final keyframe, do so. We also check once keyframes are resolved but\n     * this early check prevents the need to create an animation at all.\n     */\n    if (shouldSkip && !isHandoff && value.get() !== undefined) {\n        const finalKeyframe = getFinalKeyframe(options.keyframes, valueTransition);\n        if (finalKeyframe !== undefined) {\n            frame.update(() => {\n                options.onUpdate(finalKeyframe);\n                options.onComplete();\n            });\n            // We still want to return some animation controls here rather\n            // than returning undefined\n            return new GroupPlaybackControls([]);\n        }\n    }\n    /**\n     * Animate via WAAPI if possible. If this is a handoff animation, the optimised animation will be running via\n     * WAAPI. Therefore, this animation must be JS to ensure it runs \"under\" the\n     * optimised animation.\n     */\n    if (!isHandoff && AcceleratedAnimation.supports(options)) {\n        return new AcceleratedAnimation(options);\n    }\n    else {\n        return new MainThreadAnimation(options);\n    }\n};\n\nexport { animateMotionValue };\n"],"mappings":";AAAA,SAASA,qBAAqB,QAAQ,iCAAiC;AACvE,SAASC,oBAAoB,QAAQ,kCAAkC;AACvE,SAASC,kBAAkB,QAAQ,mCAAmC;AACtE,SAASC,kBAAkB,QAAQ,8BAA8B;AACjE,SAASC,qBAAqB,QAAQ,8CAA8C;AACpF,SAASC,gBAAgB,QAAQ,iDAAiD;AAClF,SAASC,KAAK,QAAQ,2BAA2B;AACjD,SAASC,oBAAoB,QAAQ,uCAAuC;AAC5E,SAASC,mBAAmB,QAAQ,sCAAsC;AAC1E,SAASC,qBAAqB,QAAQ,8BAA8B;AACpE,SAASC,mBAAmB,QAAQ,oCAAoC;AAExE,MAAMC,kBAAkB,GAAGA,CAACC,IAAI,EAAEC,KAAK,EAAEC,MAAM,EAAEC,UAAU,GAAG,CAAC,CAAC,EAAEC,OAAO,EAAEC,SAAS,KAAMC,UAAU,IAAK;EACrG,MAAMC,eAAe,GAAGjB,kBAAkB,CAACa,UAAU,EAAEH,IAAI,CAAC,IAAI,CAAC,CAAC;EAClE;AACJ;AACA;AACA;AACA;EACI,MAAMQ,KAAK,GAAGD,eAAe,CAACC,KAAK,IAAIL,UAAU,CAACK,KAAK,IAAI,CAAC;EAC5D;AACJ;AACA;AACA;EACI,IAAI;IAAEC,OAAO,GAAG;EAAE,CAAC,GAAGN,UAAU;EAChCM,OAAO,GAAGA,OAAO,GAAGrB,qBAAqB,CAACoB,KAAK,CAAC;EAChD,IAAIE,OAAO,GAAG;IACVC,SAAS,EAAEC,KAAK,CAACC,OAAO,CAACX,MAAM,CAAC,GAAGA,MAAM,GAAG,CAAC,IAAI,EAAEA,MAAM,CAAC;IAC1DY,IAAI,EAAE,SAAS;IACfC,QAAQ,EAAEd,KAAK,CAACe,WAAW,CAAC,CAAC;IAC7B,GAAGT,eAAe;IAClBC,KAAK,EAAE,CAACC,OAAO;IACfQ,QAAQ,EAAGC,CAAC,IAAK;MACbjB,KAAK,CAACkB,GAAG,CAACD,CAAC,CAAC;MACZX,eAAe,CAACU,QAAQ,IAAIV,eAAe,CAACU,QAAQ,CAACC,CAAC,CAAC;IAC3D,CAAC;IACDZ,UAAU,EAAEA,CAAA,KAAM;MACdA,UAAU,CAAC,CAAC;MACZC,eAAe,CAACD,UAAU,IAAIC,eAAe,CAACD,UAAU,CAAC,CAAC;IAC9D,CAAC;IACDN,IAAI;IACJoB,WAAW,EAAEnB,KAAK;IAClBG,OAAO,EAAEC,SAAS,GAAGgB,SAAS,GAAGjB;EACrC,CAAC;EACD;AACJ;AACA;AACA;EACI,IAAI,CAACN,mBAAmB,CAACS,eAAe,CAAC,EAAE;IACvCG,OAAO,GAAG;MACN,GAAGA,OAAO;MACV,GAAGrB,oBAAoB,CAACW,IAAI,EAAEU,OAAO;IACzC,CAAC;EACL;EACA;AACJ;AACA;AACA;AACA;EACI,IAAIA,OAAO,CAACY,QAAQ,EAAE;IAClBZ,OAAO,CAACY,QAAQ,GAAGlC,qBAAqB,CAACsB,OAAO,CAACY,QAAQ,CAAC;EAC9D;EACA,IAAIZ,OAAO,CAACa,WAAW,EAAE;IACrBb,OAAO,CAACa,WAAW,GAAGnC,qBAAqB,CAACsB,OAAO,CAACa,WAAW,CAAC;EACpE;EACA,IAAIb,OAAO,CAACc,IAAI,KAAKH,SAAS,EAAE;IAC5BX,OAAO,CAACC,SAAS,CAAC,CAAC,CAAC,GAAGD,OAAO,CAACc,IAAI;EACvC;EACA,IAAIC,UAAU,GAAG,KAAK;EACtB,IAAIf,OAAO,CAACgB,IAAI,KAAK,KAAK,IACrBhB,OAAO,CAACY,QAAQ,KAAK,CAAC,IAAI,CAACZ,OAAO,CAACa,WAAY,EAAE;IAClDb,OAAO,CAACY,QAAQ,GAAG,CAAC;IACpB,IAAIZ,OAAO,CAACF,KAAK,KAAK,CAAC,EAAE;MACrBiB,UAAU,GAAG,IAAI;IACrB;EACJ;EACA,IAAIjC,qBAAqB,CAACmC,OAAO,IAC7BpC,kBAAkB,CAACqC,cAAc,EAAE;IACnCH,UAAU,GAAG,IAAI;IACjBf,OAAO,CAACY,QAAQ,GAAG,CAAC;IACpBZ,OAAO,CAACF,KAAK,GAAG,CAAC;EACrB;EACA;AACJ;AACA;AACA;AACA;EACI,IAAIiB,UAAU,IAAI,CAACpB,SAAS,IAAIJ,KAAK,CAAC4B,GAAG,CAAC,CAAC,KAAKR,SAAS,EAAE;IACvD,MAAMS,aAAa,GAAGrC,gBAAgB,CAACiB,OAAO,CAACC,SAAS,EAAEJ,eAAe,CAAC;IAC1E,IAAIuB,aAAa,KAAKT,SAAS,EAAE;MAC7B3B,KAAK,CAACqC,MAAM,CAAC,MAAM;QACfrB,OAAO,CAACO,QAAQ,CAACa,aAAa,CAAC;QAC/BpB,OAAO,CAACJ,UAAU,CAAC,CAAC;MACxB,CAAC,CAAC;MACF;MACA;MACA,OAAO,IAAIT,qBAAqB,CAAC,EAAE,CAAC;IACxC;EACJ;EACA;AACJ;AACA;AACA;AACA;EACI,IAAI,CAACQ,SAAS,IAAIV,oBAAoB,CAACqC,QAAQ,CAACtB,OAAO,CAAC,EAAE;IACtD,OAAO,IAAIf,oBAAoB,CAACe,OAAO,CAAC;EAC5C,CAAC,MACI;IACD,OAAO,IAAId,mBAAmB,CAACc,OAAO,CAAC;EAC3C;AACJ,CAAC;AAED,SAASX,kBAAkB","ignoreList":[]}}},"code":"!function (module1) {\n  let _objectSpread;\n  module1.link(\"@babel/runtime/helpers/objectSpread2\", {\n    default(v) {\n      _objectSpread = v;\n    }\n  }, 0);\n  module1.export({\n    animateMotionValue: () => animateMotionValue\n  });\n  let secondsToMilliseconds;\n  module1.link(\"../../utils/time-conversion.mjs\", {\n    secondsToMilliseconds(v) {\n      secondsToMilliseconds = v;\n    }\n  }, 0);\n  let getDefaultTransition;\n  module1.link(\"../utils/default-transitions.mjs\", {\n    getDefaultTransition(v) {\n      getDefaultTransition = v;\n    }\n  }, 1);\n  let getValueTransition;\n  module1.link(\"../utils/get-value-transition.mjs\", {\n    getValueTransition(v) {\n      getValueTransition = v;\n    }\n  }, 2);\n  let MotionGlobalConfig;\n  module1.link(\"../../utils/GlobalConfig.mjs\", {\n    MotionGlobalConfig(v) {\n      MotionGlobalConfig = v;\n    }\n  }, 3);\n  let instantAnimationState;\n  module1.link(\"../../utils/use-instant-transition-state.mjs\", {\n    instantAnimationState(v) {\n      instantAnimationState = v;\n    }\n  }, 4);\n  let getFinalKeyframe;\n  module1.link(\"../animators/waapi/utils/get-final-keyframe.mjs\", {\n    getFinalKeyframe(v) {\n      getFinalKeyframe = v;\n    }\n  }, 5);\n  let frame;\n  module1.link(\"../../frameloop/frame.mjs\", {\n    frame(v) {\n      frame = v;\n    }\n  }, 6);\n  let AcceleratedAnimation;\n  module1.link(\"../animators/AcceleratedAnimation.mjs\", {\n    AcceleratedAnimation(v) {\n      AcceleratedAnimation = v;\n    }\n  }, 7);\n  let MainThreadAnimation;\n  module1.link(\"../animators/MainThreadAnimation.mjs\", {\n    MainThreadAnimation(v) {\n      MainThreadAnimation = v;\n    }\n  }, 8);\n  let GroupPlaybackControls;\n  module1.link(\"../GroupPlaybackControls.mjs\", {\n    GroupPlaybackControls(v) {\n      GroupPlaybackControls = v;\n    }\n  }, 9);\n  let isTransitionDefined;\n  module1.link(\"../utils/is-transition-defined.mjs\", {\n    isTransitionDefined(v) {\n      isTransitionDefined = v;\n    }\n  }, 10);\n  ___INIT_METEOR_FAST_REFRESH(module);\n  const animateMotionValue = function (name, value, target) {\n    let transition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    let element = arguments.length > 4 ? arguments[4] : undefined;\n    let isHandoff = arguments.length > 5 ? arguments[5] : undefined;\n    return onComplete => {\n      const valueTransition = getValueTransition(transition, name) || {};\n      /**\n       * Most transition values are currently completely overwritten by value-specific\n       * transitions. In the future it'd be nicer to blend these transitions. But for now\n       * delay actually does inherit from the root transition if not value-specific.\n       */\n      const delay = valueTransition.delay || transition.delay || 0;\n      /**\n       * Elapsed isn't a public transition option but can be passed through from\n       * optimized appear effects in milliseconds.\n       */\n      let {\n        elapsed = 0\n      } = transition;\n      elapsed = elapsed - secondsToMilliseconds(delay);\n      let options = _objectSpread(_objectSpread({\n        keyframes: Array.isArray(target) ? target : [null, target],\n        ease: \"easeOut\",\n        velocity: value.getVelocity()\n      }, valueTransition), {}, {\n        delay: -elapsed,\n        onUpdate: v => {\n          value.set(v);\n          valueTransition.onUpdate && valueTransition.onUpdate(v);\n        },\n        onComplete: () => {\n          onComplete();\n          valueTransition.onComplete && valueTransition.onComplete();\n        },\n        name,\n        motionValue: value,\n        element: isHandoff ? undefined : element\n      });\n      /**\n       * If there's no transition defined for this value, we can generate\n       * unqiue transition settings for this value.\n       */\n      if (!isTransitionDefined(valueTransition)) {\n        options = _objectSpread(_objectSpread({}, options), getDefaultTransition(name, options));\n      }\n      /**\n       * Both WAAPI and our internal animation functions use durations\n       * as defined by milliseconds, while our external API defines them\n       * as seconds.\n       */\n      if (options.duration) {\n        options.duration = secondsToMilliseconds(options.duration);\n      }\n      if (options.repeatDelay) {\n        options.repeatDelay = secondsToMilliseconds(options.repeatDelay);\n      }\n      if (options.from !== undefined) {\n        options.keyframes[0] = options.from;\n      }\n      let shouldSkip = false;\n      if (options.type === false || options.duration === 0 && !options.repeatDelay) {\n        options.duration = 0;\n        if (options.delay === 0) {\n          shouldSkip = true;\n        }\n      }\n      if (instantAnimationState.current || MotionGlobalConfig.skipAnimations) {\n        shouldSkip = true;\n        options.duration = 0;\n        options.delay = 0;\n      }\n      /**\n       * If we can or must skip creating the animation, and apply only\n       * the final keyframe, do so. We also check once keyframes are resolved but\n       * this early check prevents the need to create an animation at all.\n       */\n      if (shouldSkip && !isHandoff && value.get() !== undefined) {\n        const finalKeyframe = getFinalKeyframe(options.keyframes, valueTransition);\n        if (finalKeyframe !== undefined) {\n          frame.update(() => {\n            options.onUpdate(finalKeyframe);\n            options.onComplete();\n          });\n          // We still want to return some animation controls here rather\n          // than returning undefined\n          return new GroupPlaybackControls([]);\n        }\n      }\n      /**\n       * Animate via WAAPI if possible. If this is a handoff animation, the optimised animation will be running via\n       * WAAPI. Therefore, this animation must be JS to ensure it runs \"under\" the\n       * optimised animation.\n       */\n      if (!isHandoff && AcceleratedAnimation.supports(options)) {\n        return new AcceleratedAnimation(options);\n      } else {\n        return new MainThreadAnimation(options);\n      }\n    };\n  };\n}.call(this, module);","map":{"version":3,"names":["animateMotionValue","name","value","target","transition","arguments","length","undefined","element","isHandoff","onComplete","valueTransition","getValueTransition","delay","elapsed","secondsToMilliseconds","options","_objectSpread","keyframes","Array","isArray","ease","velocity","getVelocity","onUpdate","v","set","motionValue","isTransitionDefined","getDefaultTransition","duration","repeatDelay","from","shouldSkip","type","instantAnimationState","current","MotionGlobalConfig","skipAnimations","get","finalKeyframe","getFinalKeyframe","frame","update","GroupPlaybackControls","AcceleratedAnimation","supports","MainThreadAnimation","call","module"],"sources":["node_modules/framer-motion/dist/es/animation/interfaces/motion-value.mjs"],"sourcesContent":["import { secondsToMilliseconds } from '../../utils/time-conversion.mjs';\nimport { getDefaultTransition } from '../utils/default-transitions.mjs';\nimport { getValueTransition } from '../utils/get-value-transition.mjs';\nimport { MotionGlobalConfig } from '../../utils/GlobalConfig.mjs';\nimport { instantAnimationState } from '../../utils/use-instant-transition-state.mjs';\nimport { getFinalKeyframe } from '../animators/waapi/utils/get-final-keyframe.mjs';\nimport { frame } from '../../frameloop/frame.mjs';\nimport { AcceleratedAnimation } from '../animators/AcceleratedAnimation.mjs';\nimport { MainThreadAnimation } from '../animators/MainThreadAnimation.mjs';\nimport { GroupPlaybackControls } from '../GroupPlaybackControls.mjs';\nimport { isTransitionDefined } from '../utils/is-transition-defined.mjs';\n\nconst animateMotionValue = (name, value, target, transition = {}, element, isHandoff) => (onComplete) => {\n    const valueTransition = getValueTransition(transition, name) || {};\n    /**\n     * Most transition values are currently completely overwritten by value-specific\n     * transitions. In the future it'd be nicer to blend these transitions. But for now\n     * delay actually does inherit from the root transition if not value-specific.\n     */\n    const delay = valueTransition.delay || transition.delay || 0;\n    /**\n     * Elapsed isn't a public transition option but can be passed through from\n     * optimized appear effects in milliseconds.\n     */\n    let { elapsed = 0 } = transition;\n    elapsed = elapsed - secondsToMilliseconds(delay);\n    let options = {\n        keyframes: Array.isArray(target) ? target : [null, target],\n        ease: \"easeOut\",\n        velocity: value.getVelocity(),\n        ...valueTransition,\n        delay: -elapsed,\n        onUpdate: (v) => {\n            value.set(v);\n            valueTransition.onUpdate && valueTransition.onUpdate(v);\n        },\n        onComplete: () => {\n            onComplete();\n            valueTransition.onComplete && valueTransition.onComplete();\n        },\n        name,\n        motionValue: value,\n        element: isHandoff ? undefined : element,\n    };\n    /**\n     * If there's no transition defined for this value, we can generate\n     * unqiue transition settings for this value.\n     */\n    if (!isTransitionDefined(valueTransition)) {\n        options = {\n            ...options,\n            ...getDefaultTransition(name, options),\n        };\n    }\n    /**\n     * Both WAAPI and our internal animation functions use durations\n     * as defined by milliseconds, while our external API defines them\n     * as seconds.\n     */\n    if (options.duration) {\n        options.duration = secondsToMilliseconds(options.duration);\n    }\n    if (options.repeatDelay) {\n        options.repeatDelay = secondsToMilliseconds(options.repeatDelay);\n    }\n    if (options.from !== undefined) {\n        options.keyframes[0] = options.from;\n    }\n    let shouldSkip = false;\n    if (options.type === false ||\n        (options.duration === 0 && !options.repeatDelay)) {\n        options.duration = 0;\n        if (options.delay === 0) {\n            shouldSkip = true;\n        }\n    }\n    if (instantAnimationState.current ||\n        MotionGlobalConfig.skipAnimations) {\n        shouldSkip = true;\n        options.duration = 0;\n        options.delay = 0;\n    }\n    /**\n     * If we can or must skip creating the animation, and apply only\n     * the final keyframe, do so. We also check once keyframes are resolved but\n     * this early check prevents the need to create an animation at all.\n     */\n    if (shouldSkip && !isHandoff && value.get() !== undefined) {\n        const finalKeyframe = getFinalKeyframe(options.keyframes, valueTransition);\n        if (finalKeyframe !== undefined) {\n            frame.update(() => {\n                options.onUpdate(finalKeyframe);\n                options.onComplete();\n            });\n            // We still want to return some animation controls here rather\n            // than returning undefined\n            return new GroupPlaybackControls([]);\n        }\n    }\n    /**\n     * Animate via WAAPI if possible. If this is a handoff animation, the optimised animation will be running via\n     * WAAPI. Therefore, this animation must be JS to ensure it runs \"under\" the\n     * optimised animation.\n     */\n    if (!isHandoff && AcceleratedAnimation.supports(options)) {\n        return new AcceleratedAnimation(options);\n    }\n    else {\n        return new MainThreadAnimation(options);\n    }\n};\n\nexport { animateMotionValue };\n"],"mappings":"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","ignoreList":[]},"sourceType":"module","externalDependencies":{},"hash":"3b8e9b4327994875703560fb4fd5a7e06b3f42e9"}
