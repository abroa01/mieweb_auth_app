{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/anshul/Masters/Internship/POC/Meteor_Mobile/mieweb_push_auth/node_modules/framer-motion/dist/es/render/dom/DOMKeyframesResolver.mjs","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","topLevelAwait","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"web.browser"},"sourceFileName":"node_modules/framer-motion/dist/es/render/dom/DOMKeyframesResolver.mjs","filename":"/Users/anshul/Masters/Internship/POC/Meteor_Mobile/mieweb_push_auth/node_modules/framer-motion/dist/es/render/dom/DOMKeyframesResolver.mjs","inputSourceMap":{"version":3,"names":["isNone","getVariableValue","isCSSVariableToken","positionalKeys","isNumOrPxType","positionalValues","findDimensionValueType","KeyframeResolver","makeNoneKeyframesAnimatable","DOMKeyframesResolver","constructor","unresolvedKeyframes","onComplete","name","motionValue","element","readKeyframes","current","i","length","keyframe","trim","resolved","undefined","finalKeyframe","resolveNoneKeyframes","has","origin","target","originType","targetType","value","parseFloat","needsMeasurement","noneKeyframeIndexes","push","measureInitialState","suspendedScrollY","window","pageYOffset","measuredOrigin","measureViewportBox","getComputedStyle","measureKeyframe","getValue","jump","measureEndState","_a","finalKeyframeIndex","removedTransforms","forEach","unsetTransformName","unsetTransformValue","set"],"sources":["node_modules/framer-motion/dist/es/render/dom/DOMKeyframesResolver.mjs"],"sourcesContent":["import { isNone } from '../../animation/utils/is-none.mjs';\nimport { getVariableValue } from './utils/css-variables-conversion.mjs';\nimport { isCSSVariableToken } from './utils/is-css-variable.mjs';\nimport { positionalKeys, isNumOrPxType, positionalValues } from './utils/unit-conversion.mjs';\nimport { findDimensionValueType } from './value-types/dimensions.mjs';\nimport { KeyframeResolver } from '../utils/KeyframesResolver.mjs';\nimport { makeNoneKeyframesAnimatable } from '../html/utils/make-none-animatable.mjs';\n\nclass DOMKeyframesResolver extends KeyframeResolver {\n    constructor(unresolvedKeyframes, onComplete, name, motionValue, element) {\n        super(unresolvedKeyframes, onComplete, name, motionValue, element, true);\n    }\n    readKeyframes() {\n        const { unresolvedKeyframes, element, name } = this;\n        if (!element || !element.current)\n            return;\n        super.readKeyframes();\n        /**\n         * If any keyframe is a CSS variable, we need to find its value by sampling the element\n         */\n        for (let i = 0; i < unresolvedKeyframes.length; i++) {\n            let keyframe = unresolvedKeyframes[i];\n            if (typeof keyframe === \"string\") {\n                keyframe = keyframe.trim();\n                if (isCSSVariableToken(keyframe)) {\n                    const resolved = getVariableValue(keyframe, element.current);\n                    if (resolved !== undefined) {\n                        unresolvedKeyframes[i] = resolved;\n                    }\n                    if (i === unresolvedKeyframes.length - 1) {\n                        this.finalKeyframe = keyframe;\n                    }\n                }\n            }\n        }\n        /**\n         * Resolve \"none\" values. We do this potentially twice - once before and once after measuring keyframes.\n         * This could be seen as inefficient but it's a trade-off to avoid measurements in more situations, which\n         * have a far bigger performance impact.\n         */\n        this.resolveNoneKeyframes();\n        /**\n         * Check to see if unit type has changed. If so schedule jobs that will\n         * temporarily set styles to the destination keyframes.\n         * Skip if we have more than two keyframes or this isn't a positional value.\n         * TODO: We can throw if there are multiple keyframes and the value type changes.\n         */\n        if (!positionalKeys.has(name) || unresolvedKeyframes.length !== 2) {\n            return;\n        }\n        const [origin, target] = unresolvedKeyframes;\n        const originType = findDimensionValueType(origin);\n        const targetType = findDimensionValueType(target);\n        /**\n         * Either we don't recognise these value types or we can animate between them.\n         */\n        if (originType === targetType)\n            return;\n        /**\n         * If both values are numbers or pixels, we can animate between them by\n         * converting them to numbers.\n         */\n        if (isNumOrPxType(originType) && isNumOrPxType(targetType)) {\n            for (let i = 0; i < unresolvedKeyframes.length; i++) {\n                const value = unresolvedKeyframes[i];\n                if (typeof value === \"string\") {\n                    unresolvedKeyframes[i] = parseFloat(value);\n                }\n            }\n        }\n        else {\n            /**\n             * Else, the only way to resolve this is by measuring the element.\n             */\n            this.needsMeasurement = true;\n        }\n    }\n    resolveNoneKeyframes() {\n        const { unresolvedKeyframes, name } = this;\n        const noneKeyframeIndexes = [];\n        for (let i = 0; i < unresolvedKeyframes.length; i++) {\n            if (isNone(unresolvedKeyframes[i])) {\n                noneKeyframeIndexes.push(i);\n            }\n        }\n        if (noneKeyframeIndexes.length) {\n            makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name);\n        }\n    }\n    measureInitialState() {\n        const { element, unresolvedKeyframes, name } = this;\n        if (!element || !element.current)\n            return;\n        if (name === \"height\") {\n            this.suspendedScrollY = window.pageYOffset;\n        }\n        this.measuredOrigin = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));\n        unresolvedKeyframes[0] = this.measuredOrigin;\n        // Set final key frame to measure after next render\n        const measureKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];\n        if (measureKeyframe !== undefined) {\n            element.getValue(name, measureKeyframe).jump(measureKeyframe, false);\n        }\n    }\n    measureEndState() {\n        var _a;\n        const { element, name, unresolvedKeyframes } = this;\n        if (!element || !element.current)\n            return;\n        const value = element.getValue(name);\n        value && value.jump(this.measuredOrigin, false);\n        const finalKeyframeIndex = unresolvedKeyframes.length - 1;\n        const finalKeyframe = unresolvedKeyframes[finalKeyframeIndex];\n        unresolvedKeyframes[finalKeyframeIndex] = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));\n        if (finalKeyframe !== null && this.finalKeyframe === undefined) {\n            this.finalKeyframe = finalKeyframe;\n        }\n        // If we removed transform values, reapply them before the next render\n        if ((_a = this.removedTransforms) === null || _a === void 0 ? void 0 : _a.length) {\n            this.removedTransforms.forEach(([unsetTransformName, unsetTransformValue]) => {\n                element\n                    .getValue(unsetTransformName)\n                    .set(unsetTransformValue);\n            });\n        }\n        this.resolveNoneKeyframes();\n    }\n}\n\nexport { DOMKeyframesResolver };\n"],"mappings":"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","ignoreList":[]},"targets":{},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/Users/anshul/Masters/Internship/POC/Meteor_Mobile/mieweb_push_auth","root":"/Users/anshul/Masters/Internship/POC/Meteor_Mobile/mieweb_push_auth","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true},"externalDependencies":[]},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.17.2","helpers":true,"useESModules":false,"corejs":false},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-react-jsx","visitor":{"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXFragment":{"exit":[null]},"JSXElement":{"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false},"externalDependencies":[]},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-nullish-coalescing-operator","visitor":{"LogicalExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-chaining","visitor":{"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-catch-binding","visitor":{"CatchClause":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"proposal-logical-assignment-operators","visitor":{"AssignmentExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]}],"presets":[],"generatorOpts":{"filename":"/Users/anshul/Masters/Internship/POC/Meteor_Mobile/mieweb_push_auth/node_modules/framer-motion/dist/es/render/dom/DOMKeyframesResolver.mjs","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"node_modules/framer-motion/dist/es/render/dom/DOMKeyframesResolver.mjs","inputSourceMap":{"version":3,"names":["isNone","getVariableValue","isCSSVariableToken","positionalKeys","isNumOrPxType","positionalValues","findDimensionValueType","KeyframeResolver","makeNoneKeyframesAnimatable","DOMKeyframesResolver","constructor","unresolvedKeyframes","onComplete","name","motionValue","element","readKeyframes","current","i","length","keyframe","trim","resolved","undefined","finalKeyframe","resolveNoneKeyframes","has","origin","target","originType","targetType","value","parseFloat","needsMeasurement","noneKeyframeIndexes","push","measureInitialState","suspendedScrollY","window","pageYOffset","measuredOrigin","measureViewportBox","getComputedStyle","measureKeyframe","getValue","jump","measureEndState","_a","finalKeyframeIndex","removedTransforms","forEach","unsetTransformName","unsetTransformValue","set"],"sources":["node_modules/framer-motion/dist/es/render/dom/DOMKeyframesResolver.mjs"],"sourcesContent":["import { isNone } from '../../animation/utils/is-none.mjs';\nimport { getVariableValue } from './utils/css-variables-conversion.mjs';\nimport { isCSSVariableToken } from './utils/is-css-variable.mjs';\nimport { positionalKeys, isNumOrPxType, positionalValues } from './utils/unit-conversion.mjs';\nimport { findDimensionValueType } from './value-types/dimensions.mjs';\nimport { KeyframeResolver } from '../utils/KeyframesResolver.mjs';\nimport { makeNoneKeyframesAnimatable } from '../html/utils/make-none-animatable.mjs';\n\nclass DOMKeyframesResolver extends KeyframeResolver {\n    constructor(unresolvedKeyframes, onComplete, name, motionValue, element) {\n        super(unresolvedKeyframes, onComplete, name, motionValue, element, true);\n    }\n    readKeyframes() {\n        const { unresolvedKeyframes, element, name } = this;\n        if (!element || !element.current)\n            return;\n        super.readKeyframes();\n        /**\n         * If any keyframe is a CSS variable, we need to find its value by sampling the element\n         */\n        for (let i = 0; i < unresolvedKeyframes.length; i++) {\n            let keyframe = unresolvedKeyframes[i];\n            if (typeof keyframe === \"string\") {\n                keyframe = keyframe.trim();\n                if (isCSSVariableToken(keyframe)) {\n                    const resolved = getVariableValue(keyframe, element.current);\n                    if (resolved !== undefined) {\n                        unresolvedKeyframes[i] = resolved;\n                    }\n                    if (i === unresolvedKeyframes.length - 1) {\n                        this.finalKeyframe = keyframe;\n                    }\n                }\n            }\n        }\n        /**\n         * Resolve \"none\" values. We do this potentially twice - once before and once after measuring keyframes.\n         * This could be seen as inefficient but it's a trade-off to avoid measurements in more situations, which\n         * have a far bigger performance impact.\n         */\n        this.resolveNoneKeyframes();\n        /**\n         * Check to see if unit type has changed. If so schedule jobs that will\n         * temporarily set styles to the destination keyframes.\n         * Skip if we have more than two keyframes or this isn't a positional value.\n         * TODO: We can throw if there are multiple keyframes and the value type changes.\n         */\n        if (!positionalKeys.has(name) || unresolvedKeyframes.length !== 2) {\n            return;\n        }\n        const [origin, target] = unresolvedKeyframes;\n        const originType = findDimensionValueType(origin);\n        const targetType = findDimensionValueType(target);\n        /**\n         * Either we don't recognise these value types or we can animate between them.\n         */\n        if (originType === targetType)\n            return;\n        /**\n         * If both values are numbers or pixels, we can animate between them by\n         * converting them to numbers.\n         */\n        if (isNumOrPxType(originType) && isNumOrPxType(targetType)) {\n            for (let i = 0; i < unresolvedKeyframes.length; i++) {\n                const value = unresolvedKeyframes[i];\n                if (typeof value === \"string\") {\n                    unresolvedKeyframes[i] = parseFloat(value);\n                }\n            }\n        }\n        else {\n            /**\n             * Else, the only way to resolve this is by measuring the element.\n             */\n            this.needsMeasurement = true;\n        }\n    }\n    resolveNoneKeyframes() {\n        const { unresolvedKeyframes, name } = this;\n        const noneKeyframeIndexes = [];\n        for (let i = 0; i < unresolvedKeyframes.length; i++) {\n            if (isNone(unresolvedKeyframes[i])) {\n                noneKeyframeIndexes.push(i);\n            }\n        }\n        if (noneKeyframeIndexes.length) {\n            makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name);\n        }\n    }\n    measureInitialState() {\n        const { element, unresolvedKeyframes, name } = this;\n        if (!element || !element.current)\n            return;\n        if (name === \"height\") {\n            this.suspendedScrollY = window.pageYOffset;\n        }\n        this.measuredOrigin = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));\n        unresolvedKeyframes[0] = this.measuredOrigin;\n        // Set final key frame to measure after next render\n        const measureKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];\n        if (measureKeyframe !== undefined) {\n            element.getValue(name, measureKeyframe).jump(measureKeyframe, false);\n        }\n    }\n    measureEndState() {\n        var _a;\n        const { element, name, unresolvedKeyframes } = this;\n        if (!element || !element.current)\n            return;\n        const value = element.getValue(name);\n        value && value.jump(this.measuredOrigin, false);\n        const finalKeyframeIndex = unresolvedKeyframes.length - 1;\n        const finalKeyframe = unresolvedKeyframes[finalKeyframeIndex];\n        unresolvedKeyframes[finalKeyframeIndex] = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));\n        if (finalKeyframe !== null && this.finalKeyframe === undefined) {\n            this.finalKeyframe = finalKeyframe;\n        }\n        // If we removed transform values, reapply them before the next render\n        if ((_a = this.removedTransforms) === null || _a === void 0 ? void 0 : _a.length) {\n            this.removedTransforms.forEach(([unsetTransformName, unsetTransformValue]) => {\n                element\n                    .getValue(unsetTransformName)\n                    .set(unsetTransformValue);\n            });\n        }\n        this.resolveNoneKeyframes();\n    }\n}\n\nexport { DOMKeyframesResolver };\n"],"mappings":"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","ignoreList":[]}}},"code":"!function (module1) {\n  module1.export({\n    DOMKeyframesResolver: () => DOMKeyframesResolver\n  });\n  let isNone;\n  module1.link(\"../../animation/utils/is-none.mjs\", {\n    isNone(v) {\n      isNone = v;\n    }\n  }, 0);\n  let getVariableValue;\n  module1.link(\"./utils/css-variables-conversion.mjs\", {\n    getVariableValue(v) {\n      getVariableValue = v;\n    }\n  }, 1);\n  let isCSSVariableToken;\n  module1.link(\"./utils/is-css-variable.mjs\", {\n    isCSSVariableToken(v) {\n      isCSSVariableToken = v;\n    }\n  }, 2);\n  let positionalKeys, isNumOrPxType, positionalValues;\n  module1.link(\"./utils/unit-conversion.mjs\", {\n    positionalKeys(v) {\n      positionalKeys = v;\n    },\n    isNumOrPxType(v) {\n      isNumOrPxType = v;\n    },\n    positionalValues(v) {\n      positionalValues = v;\n    }\n  }, 3);\n  let findDimensionValueType;\n  module1.link(\"./value-types/dimensions.mjs\", {\n    findDimensionValueType(v) {\n      findDimensionValueType = v;\n    }\n  }, 4);\n  let KeyframeResolver;\n  module1.link(\"../utils/KeyframesResolver.mjs\", {\n    KeyframeResolver(v) {\n      KeyframeResolver = v;\n    }\n  }, 5);\n  let makeNoneKeyframesAnimatable;\n  module1.link(\"../html/utils/make-none-animatable.mjs\", {\n    makeNoneKeyframesAnimatable(v) {\n      makeNoneKeyframesAnimatable = v;\n    }\n  }, 6);\n  ___INIT_METEOR_FAST_REFRESH(module);\n  class DOMKeyframesResolver extends KeyframeResolver {\n    constructor(unresolvedKeyframes, onComplete, name, motionValue, element) {\n      super(unresolvedKeyframes, onComplete, name, motionValue, element, true);\n    }\n    readKeyframes() {\n      const {\n        unresolvedKeyframes,\n        element,\n        name\n      } = this;\n      if (!element || !element.current) return;\n      super.readKeyframes();\n      /**\n       * If any keyframe is a CSS variable, we need to find its value by sampling the element\n       */\n      for (let i = 0; i < unresolvedKeyframes.length; i++) {\n        let keyframe = unresolvedKeyframes[i];\n        if (typeof keyframe === \"string\") {\n          keyframe = keyframe.trim();\n          if (isCSSVariableToken(keyframe)) {\n            const resolved = getVariableValue(keyframe, element.current);\n            if (resolved !== undefined) {\n              unresolvedKeyframes[i] = resolved;\n            }\n            if (i === unresolvedKeyframes.length - 1) {\n              this.finalKeyframe = keyframe;\n            }\n          }\n        }\n      }\n      /**\n       * Resolve \"none\" values. We do this potentially twice - once before and once after measuring keyframes.\n       * This could be seen as inefficient but it's a trade-off to avoid measurements in more situations, which\n       * have a far bigger performance impact.\n       */\n      this.resolveNoneKeyframes();\n      /**\n       * Check to see if unit type has changed. If so schedule jobs that will\n       * temporarily set styles to the destination keyframes.\n       * Skip if we have more than two keyframes or this isn't a positional value.\n       * TODO: We can throw if there are multiple keyframes and the value type changes.\n       */\n      if (!positionalKeys.has(name) || unresolvedKeyframes.length !== 2) {\n        return;\n      }\n      const [origin, target] = unresolvedKeyframes;\n      const originType = findDimensionValueType(origin);\n      const targetType = findDimensionValueType(target);\n      /**\n       * Either we don't recognise these value types or we can animate between them.\n       */\n      if (originType === targetType) return;\n      /**\n       * If both values are numbers or pixels, we can animate between them by\n       * converting them to numbers.\n       */\n      if (isNumOrPxType(originType) && isNumOrPxType(targetType)) {\n        for (let i = 0; i < unresolvedKeyframes.length; i++) {\n          const value = unresolvedKeyframes[i];\n          if (typeof value === \"string\") {\n            unresolvedKeyframes[i] = parseFloat(value);\n          }\n        }\n      } else {\n        /**\n         * Else, the only way to resolve this is by measuring the element.\n         */\n        this.needsMeasurement = true;\n      }\n    }\n    resolveNoneKeyframes() {\n      const {\n        unresolvedKeyframes,\n        name\n      } = this;\n      const noneKeyframeIndexes = [];\n      for (let i = 0; i < unresolvedKeyframes.length; i++) {\n        if (isNone(unresolvedKeyframes[i])) {\n          noneKeyframeIndexes.push(i);\n        }\n      }\n      if (noneKeyframeIndexes.length) {\n        makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name);\n      }\n    }\n    measureInitialState() {\n      const {\n        element,\n        unresolvedKeyframes,\n        name\n      } = this;\n      if (!element || !element.current) return;\n      if (name === \"height\") {\n        this.suspendedScrollY = window.pageYOffset;\n      }\n      this.measuredOrigin = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));\n      unresolvedKeyframes[0] = this.measuredOrigin;\n      // Set final key frame to measure after next render\n      const measureKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];\n      if (measureKeyframe !== undefined) {\n        element.getValue(name, measureKeyframe).jump(measureKeyframe, false);\n      }\n    }\n    measureEndState() {\n      var _a;\n      const {\n        element,\n        name,\n        unresolvedKeyframes\n      } = this;\n      if (!element || !element.current) return;\n      const value = element.getValue(name);\n      value && value.jump(this.measuredOrigin, false);\n      const finalKeyframeIndex = unresolvedKeyframes.length - 1;\n      const finalKeyframe = unresolvedKeyframes[finalKeyframeIndex];\n      unresolvedKeyframes[finalKeyframeIndex] = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));\n      if (finalKeyframe !== null && this.finalKeyframe === undefined) {\n        this.finalKeyframe = finalKeyframe;\n      }\n      // If we removed transform values, reapply them before the next render\n      if ((_a = this.removedTransforms) === null || _a === void 0 ? void 0 : _a.length) {\n        this.removedTransforms.forEach(_ref => {\n          let [unsetTransformName, unsetTransformValue] = _ref;\n          element.getValue(unsetTransformName).set(unsetTransformValue);\n        });\n      }\n      this.resolveNoneKeyframes();\n    }\n  }\n}.call(this, module);","map":{"version":3,"names":["DOMKeyframesResolver","KeyframeResolver","constructor","unresolvedKeyframes","onComplete","name","motionValue","element","readKeyframes","current","i","length","keyframe","trim","isCSSVariableToken","resolved","getVariableValue","undefined","finalKeyframe","resolveNoneKeyframes","positionalKeys","has","origin","target","originType","findDimensionValueType","targetType","isNumOrPxType","value","parseFloat","needsMeasurement","noneKeyframeIndexes","isNone","push","makeNoneKeyframesAnimatable","measureInitialState","suspendedScrollY","window","pageYOffset","measuredOrigin","positionalValues","measureViewportBox","getComputedStyle","measureKeyframe","getValue","jump","measureEndState","_a","finalKeyframeIndex","removedTransforms","forEach","_ref","unsetTransformName","unsetTransformValue","set","call","module"],"sources":["node_modules/framer-motion/dist/es/render/dom/DOMKeyframesResolver.mjs"],"sourcesContent":["import { isNone } from '../../animation/utils/is-none.mjs';\nimport { getVariableValue } from './utils/css-variables-conversion.mjs';\nimport { isCSSVariableToken } from './utils/is-css-variable.mjs';\nimport { positionalKeys, isNumOrPxType, positionalValues } from './utils/unit-conversion.mjs';\nimport { findDimensionValueType } from './value-types/dimensions.mjs';\nimport { KeyframeResolver } from '../utils/KeyframesResolver.mjs';\nimport { makeNoneKeyframesAnimatable } from '../html/utils/make-none-animatable.mjs';\n\nclass DOMKeyframesResolver extends KeyframeResolver {\n    constructor(unresolvedKeyframes, onComplete, name, motionValue, element) {\n        super(unresolvedKeyframes, onComplete, name, motionValue, element, true);\n    }\n    readKeyframes() {\n        const { unresolvedKeyframes, element, name } = this;\n        if (!element || !element.current)\n            return;\n        super.readKeyframes();\n        /**\n         * If any keyframe is a CSS variable, we need to find its value by sampling the element\n         */\n        for (let i = 0; i < unresolvedKeyframes.length; i++) {\n            let keyframe = unresolvedKeyframes[i];\n            if (typeof keyframe === \"string\") {\n                keyframe = keyframe.trim();\n                if (isCSSVariableToken(keyframe)) {\n                    const resolved = getVariableValue(keyframe, element.current);\n                    if (resolved !== undefined) {\n                        unresolvedKeyframes[i] = resolved;\n                    }\n                    if (i === unresolvedKeyframes.length - 1) {\n                        this.finalKeyframe = keyframe;\n                    }\n                }\n            }\n        }\n        /**\n         * Resolve \"none\" values. We do this potentially twice - once before and once after measuring keyframes.\n         * This could be seen as inefficient but it's a trade-off to avoid measurements in more situations, which\n         * have a far bigger performance impact.\n         */\n        this.resolveNoneKeyframes();\n        /**\n         * Check to see if unit type has changed. If so schedule jobs that will\n         * temporarily set styles to the destination keyframes.\n         * Skip if we have more than two keyframes or this isn't a positional value.\n         * TODO: We can throw if there are multiple keyframes and the value type changes.\n         */\n        if (!positionalKeys.has(name) || unresolvedKeyframes.length !== 2) {\n            return;\n        }\n        const [origin, target] = unresolvedKeyframes;\n        const originType = findDimensionValueType(origin);\n        const targetType = findDimensionValueType(target);\n        /**\n         * Either we don't recognise these value types or we can animate between them.\n         */\n        if (originType === targetType)\n            return;\n        /**\n         * If both values are numbers or pixels, we can animate between them by\n         * converting them to numbers.\n         */\n        if (isNumOrPxType(originType) && isNumOrPxType(targetType)) {\n            for (let i = 0; i < unresolvedKeyframes.length; i++) {\n                const value = unresolvedKeyframes[i];\n                if (typeof value === \"string\") {\n                    unresolvedKeyframes[i] = parseFloat(value);\n                }\n            }\n        }\n        else {\n            /**\n             * Else, the only way to resolve this is by measuring the element.\n             */\n            this.needsMeasurement = true;\n        }\n    }\n    resolveNoneKeyframes() {\n        const { unresolvedKeyframes, name } = this;\n        const noneKeyframeIndexes = [];\n        for (let i = 0; i < unresolvedKeyframes.length; i++) {\n            if (isNone(unresolvedKeyframes[i])) {\n                noneKeyframeIndexes.push(i);\n            }\n        }\n        if (noneKeyframeIndexes.length) {\n            makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name);\n        }\n    }\n    measureInitialState() {\n        const { element, unresolvedKeyframes, name } = this;\n        if (!element || !element.current)\n            return;\n        if (name === \"height\") {\n            this.suspendedScrollY = window.pageYOffset;\n        }\n        this.measuredOrigin = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));\n        unresolvedKeyframes[0] = this.measuredOrigin;\n        // Set final key frame to measure after next render\n        const measureKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];\n        if (measureKeyframe !== undefined) {\n            element.getValue(name, measureKeyframe).jump(measureKeyframe, false);\n        }\n    }\n    measureEndState() {\n        var _a;\n        const { element, name, unresolvedKeyframes } = this;\n        if (!element || !element.current)\n            return;\n        const value = element.getValue(name);\n        value && value.jump(this.measuredOrigin, false);\n        const finalKeyframeIndex = unresolvedKeyframes.length - 1;\n        const finalKeyframe = unresolvedKeyframes[finalKeyframeIndex];\n        unresolvedKeyframes[finalKeyframeIndex] = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));\n        if (finalKeyframe !== null && this.finalKeyframe === undefined) {\n            this.finalKeyframe = finalKeyframe;\n        }\n        // If we removed transform values, reapply them before the next render\n        if ((_a = this.removedTransforms) === null || _a === void 0 ? void 0 : _a.length) {\n            this.removedTransforms.forEach(([unsetTransformName, unsetTransformValue]) => {\n                element\n                    .getValue(unsetTransformName)\n                    .set(unsetTransformValue);\n            });\n        }\n        this.resolveNoneKeyframes();\n    }\n}\n\nexport { DOMKeyframesResolver };\n"],"mappings":"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","ignoreList":[]},"sourceType":"module","externalDependencies":{},"hash":"ffb0b98916a67e3837f48b33238de93b7685dfb3"}
